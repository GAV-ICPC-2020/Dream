#**A计划_阶段1**




[TOC]





# 1.数据结构

【1】树状数组：成段修改，区间最大值，前缀最大值

【2】主席树

1.http://www.lydsy.com/JudgeOnline/problem.php?id=3932

2.http://codeforces.com/contest/787/problem/E

3.http://codeforces.com/contest/588/problem/E

4.http://codeforces.com/contest/707/problem/D

5.http://www.lydsy.com/JudgeOnline/problem.php?id=3956

6.http://www.lydsy.com/JudgeOnline/problem.php?id=2006

7.http://www.lydsy.com/JudgeOnline/problem.php?id=4448

8.http://codeforces.com/problemset/problem/916/D

9.http://codeforces.com/problemset/problem/484/E

注：二分+可持久化线段树，离线从大到小插入权值，维护01串，查询区间最长"1"段的长度，典型的三段论线段树

特别注意：merge函数，不要把参数设置成const node &p形式，让其自然的拷贝，

避免x=merge(x,y)中x自更新不完全导致的错误

10.https://www.lydsy.com/JudgeOnline/problem.php?id=5494

11.https://www.lydsy.com/JudgeOnline/problem.php?id=5361

12.http://acm.hdu.edu.cn/showproblem.php?pid=6601

首先考虑区间最大的三个数能否形成三角形，如果不能，考虑区间第二大、第三大、第四大的三个数，以此类推，直到能形成三角形。由三角形最小的两条边大于第三边的性质可知，只需要考虑区间的前 $44$ 大数即可（最坏情况下区间前几大数形成了斐波那契数列）。

时间复杂度$O(nlog_2n*44)$ 。





【3】树链剖分

指定题目：

1.http://www.lydsy.com/JudgeOnline/problem.php?id=4034

https://www.cnblogs.com/skylee03/p/8066974.html#commentform

树剖做法比其他两个多了log，但是比较通用。其他两个暂时还不知道有啥用。

2.http://www.lydsy.com/JudgeOnline/problem.php?id=3626

3.http://www.lydsy.com/JudgeOnline/problem.php?id=3531

4.http://www.lydsy.com/JudgeOnline/problem.php?id=2243

5.http://www.lydsy.com/JudgeOnline/problem.php?id=2543

6.https://www.lydsy.com/JudgeOnline/problem.php?id=1146

7.https://www.lydsy.com/JudgeOnline/problem.php?id=4712

8.https://www.lydsy.com/JudgeOnline/problem.php?id=3083

9.https://www.lydsy.com/JudgeOnline/problem.php?id=5210

10.http://clatisus.com/Discover%20Vladivostok%202018%20day%202#i.-kindom-and-roads

11.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=010435 A






【4】动态树lct

先看论文：https://wenku.baidu.com/view/7857b870aaea998fcc220ed8.html

指定题目：

1.http://www.lydsy.com/JudgeOnline/problem.php?id=1036

2.http://www.lydsy.com/JudgeOnline/problem.php?id=2002

3.http://www.lydsy.com/JudgeOnline/problem.php?id=2759

4.http://www.lydsy.com/JudgeOnline/problem.php?id=4012

**解法一：**

点分治可以查询块内的点与当前重心的信息，点分树是将这个信息减去重复统计的。

通常先把点分树建出来，然后像点分治那样正常统计。

统计的细节稍微推一下。

**解法二：**

dis(a, b) = dis(a) + dis(b) - 2 * dis(lca(a, b))

离线：和bzoj3626差不多。线段树的部分可以标记不下传。

在线：用主席树。

5.http://codeforces.com/contest/482/problem/E

6.http://www.lydsy.com/JudgeOnline/problem.php?id=2049

7.http://www.lydsy.com/JudgeOnline/problem.php?id=3669

8.http://www.lydsy.com/JudgeOnline/problem.php?id=4025

`3` `20190607` `bzoj4025` `LCT` `线段树分治` `可撤销并查集`

9.http://www.lydsy.com/JudgeOnline/problem.php?id=2843

10.http://www.lydsy.com/JudgeOnline/problem.php?id=2959

11.http://acm.hdu.edu.cn/showproblem.php?pid=5002

12.http://acm.hdu.edu.cn/showproblem.php?pid=4836

13.http://acm.hdu.edu.cn/showproblem.php?pid=5314

14.http://acm.hdu.edu.cn/showproblem.php?pid=5398

15.http://acm.hdu.edu.cn/showproblem.php?pid=4677

16.http://acm.hdu.edu.cn/showproblem.php?pid=4010

17.http://uoj.ac/problem/207

18.http://acm.hdu.edu.cn/showproblem.php?pid=6394

19.https://www.lydsy.com/JudgeOnline/problem.php?id=4229

20.https://www.lydsy.com/JudgeOnline/problem.php?id=1969

21.https://www.lydsy.com/JudgeOnline/problem.php?id=4530

22.https://www.lydsy.com/JudgeOnline/problem.php?id=2631

23.https://www.lydsy.com/JudgeOnline/problem.php?id=3091

24.https://www.lydsy.com/JudgeOnline/problem.php?id=4668

25.https://www.lydsy.com/JudgeOnline/problem.php?id=3282

26.https://www.lydsy.com/JudgeOnline/problem.php?id=4998

27.https://www.lydsy.com/JudgeOnline/problem.php?id=3159

28.https://www.lydsy.com/JudgeOnline/problem.php?id=2555

29.https://www.lydsy.com/JudgeOnline/problem.php?id=5212

30.https://www.lydsy.com/JudgeOnline/problem.php?id=3510

31.https://www.lydsy.com/JudgeOnline/problem.php?id=4736

或者：http://uoj.ac/problem/274

32.https://www.lydsy.com/JudgeOnline/problem.php?id=3639

33.https://www.lydsy.com/JudgeOnline/problem.php?id=3514

34.https://www.lydsy.com/JudgeOnline/problem.php?id=5048

35.https://www.lydsy.com/JudgeOnline/problem.php?id=2001

36.https://www.lydsy.com/JudgeOnline/problem.php?id=5379

37.https://www.lydsy.com/JudgeOnline/problem.php?id=4817

38.https://www.lydsy.com/JudgeOnline/problem.php?id=2594

39.https://www.lydsy.com/JudgeOnline/problem.php?id=2594

40.https://www.lydsy.com/JudgeOnline/problem.php?id=2836

41.https://www.lydsy.com/JudgeOnline/problem.php?id=4764

42.https://www.lydsy.com/JudgeOnline/problem.php?id=3779

43.http://codeforces.com/problemset/problem/891/C

44.http://codeforces.com/problemset/problem/603/E

45.https://www.lydsy.com/JudgeOnline/problem.php?id=5192

`3` `20190615` `bzoj5912` `点分树` `动态点分治` `树直径`












【5】SBT/treap旋转版本

注意：了解只是说不要求掌握到很深的程度，但是不代表不看不学  

   最好找点零碎的时间，一点点学掉，不需要做很多题目

   


【6】斜堆/左偏树







【7】可持久化数据结构与启发式合并学习



1）利用熟练剖分或者动态树套主席树，来复习主席树，学习标记永久化，历史最值问题（看论文）

1.BZOJ 1513

2.http://www.lydsy.com/JudgeOnline/problem.php?id=3110

3.http://poj.org/problem?id=2155

历史最值与区间最值操作

1.http://www.lydsy.com/JudgeOnline/problem.php?id=3064

2.http://acm.hdu.edu.cn/showproblem.php?pid=5306

3.http://uoj.ac/problem/164

4.http://www.tyvj.cn/p/1518

5.http://uoj.ac/problem/25

6.http://uoj.ac/problem/169

7.http://blog.csdn.net/s_g_g/article/details/53065776



2）学习可持久化并查集/带撤销与回滚功能的并查集/可持久化数组，与一些重要的应用

1.http://www.lydsy.com/JudgeOnline/problem.php?id=3674

2.http://www.lydsy.com/JudgeOnline/problem.php?id=3673

3.http://acm.hdu.edu.cn/showproblem.php?pid=5923

4.https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=229&page=show_problem&problem=3138

5.http://codeforces.com/contest/892/problem/E




3）学习非旋转版本的treap,与启发式合并，以及如何可持久化treap

1.https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=441&page=show_problem&problem=3983

2.http://codeforces.com/problemset/problem/702/F

3.http://codeforces.com/group/aUVPeyEnI2/contest/243687 L题

注：维护序列切割经典题





4）可持久化队列

http://www.cnblogs.com/qscqesze/p/4738165.html





5）可持久化字典树

1.http://www.lydsy.com/JudgeOnline/problem.php?id=2741

2.http://blog.csdn.net/u014609452/article/details/51416634

3.http://blog.csdn.net/u014609452/article/details/51416605

4.http://acm.hdu.edu.cn/showproblem.php?pid=4757

5.http://codeforces.com/problemset/problem/916/D



6）可持久化块状链表




7）启发式合并

并查集
1.http://codeforces.com/contest/778/problem/C

伸展树
2.http://www.lydsy.com/JudgeOnline/problem.php?id=2809

链表
3.http://www.lydsy.com/JudgeOnline/problem.php?id=1483

treap
4.http://www.lydsy.com/JudgeOnline/problem.php?id=2733

treap
5.http://poj.org/problem?id=1471

map
6.http://acm.uestc.edu.cn/#/problem/show/1284

LCT
7.http://www.cnblogs.com/geng4512/p/5296855.html

主席树
8.http://www.lydsy.com/JudgeOnline/problem.php?id=3123

set
9.http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=775&pid=1002

10.http://codeforces.com/contest/375/problem/D

线段树

https://wenku.baidu.com/view/88f4e134e518964bcf847c95.html

11.http://codeforces.com/contest/893/problem/F

12.http://www.lydsy.com/JudgeOnline/problem.php?id=4552

13.https://nanti.jisuanke.com/t/30997

【8】树上分治算法

1）点分治

1.http://poj.org/problem?id=1741

2.http://acm.hdu.edu.cn/showproblem.php?pid=4812

3.http://codeforces.com/contest/161/problem/D

4.http://www.lydsy.com/JudgeOnline/problem.php?id=3697

5.http://www.lydsy.com/JudgeOnline/problem.php?id=2152

6.http://www.lydsy.com/JudgeOnline/problem.php?id=3648

7.http://www.lydsy.com/JudgeOnline/problem.php?id=3784

`3` `20190605` `bzoj3784` `点分治` `思维`

解法一：二分下界。可以先把sort过的数组存起来优化复杂度。

解法二：转化成 `bzoj2006` 做。

解法二会好写点。

8.http://www.lydsy.com/JudgeOnline/problem.php?id=1095

9.http://uoj.ac/problem/33

10.http://www.spoj.com/problems/FTOUR2/

11.http://www.lydsy.com/JudgeOnline/problem.php?id=4016

`3` `20190606` `bzoj4016` `点分治` `最短路径树`

12.http://www.lydsy.com/JudgeOnline/problem.php?id=1758

13.http://www.lydsy.com/JudgeOnline/problem.php?id=2599

14.http://www.lydsy.com/JudgeOnline/problem.php?id=1468

15.http://poj.org/problem?id=1987

16.http://www.lydsy.com/JudgeOnline/problem.php?id=3730

17.http://www.lydsy.com/JudgeOnline/problem.php?id=3365

18.http://www.lydsy.com/JudgeOnline/problem.php?id=1316

19.http://www.lydsy.com/JudgeOnline/problem.php?id=2006

20.http://www.lydsy.com/JudgeOnline/problem.php?id=3451

21.http://www.spoj.com/problems/QTREE5/

22.https://cn.vjudge.net/contest/187749#problem/G

23.http://codeforces.com/problemset/problem/914/E

24.http://codeforces.com/problemset/problem/960/E

25.https://codeforces.com/problemset/problem/1019/E

26.http://acm.hdu.edu.cn/showproblem.php?pid=6605

计算路径条数显然用点分治。

将两条路径拼起来，写出方程 $10 ^hx + y \equiv 0 \; (mod \; k)$，这个方程在将所有项同除以 $gcd(10^h, k)$ 下只有一个解。观察到 $k / gcd(10^h, k)$ 只有 log 个，预处理出这 log 个。

复杂度 $O(nlog_2nlog_2k)$ 。

2）边分治

1.http://www.lydsy.com/JudgeOnline/problem.php?id=5152

2.http://www.lydsy.com/JudgeOnline/problem.php?id=5341

3.http://acm.hdu.edu.cn/showproblem.php?pid=6594

注：

首先对第一棵树进行边分治，假设当前我们正在考虑经过中心边 $(st, ed)$ 的所有路径，我们不妨把切掉中心边之后所有和 $st$ 联通的点标成黑色，所有和 $ed$  联通的点标成白色。

定义黑点 $u$ 的权值 $h(u) = T_1.dis(u, st) + T_1.val(st, ed) / 2 + val(u) $

定义白点 $v$ 的权值 $h(v) = T_1.dis(v, ed) + T_1.val(st, ed) / 2 + val(v) $ 

那么

$$
T_1.dis(u, v) + T_2.dis(u, v) + val(u) + val(v) \\
\begin{align}
&= T_1.dis(u, st) + T_1.dis(ed, v) + T_1.val(st, ed) + val(u) + val(v) + T_2.dis(u, v) \\
&= h(u) + h(v) + T_2.dis(u, v)
\end{align}
$$
现在对于边分治的每个联通块，我们需要考虑第二棵树。第二棵树上有些点是白色，有些点是黑色，有些点无色，对于每次修改，我们需要找一个黑点 $u$，一个白点 $v$ 使得 $h(u) + h(v) + T_2.dis(u, v)$ 最大。

首先我们有一个结论：

**对于一棵边权全是正的树，假如这棵树上有一个点集 A 的最长路端点分别是 u, v，另有一个点集 B 的最长路端点分别是 a, b，那么点集 A ∪ B 的最长路端点 ∈ {u, v, a, b}。**

因为有修改操作，所以 $h(i)$ 的值是在动态变化的，我们用四元组 $(i, l, r, w)$ 表示 $i$ 点在时刻 $[l, r]$ 的权值 $h(i) = w$。对其进行线段树分治，则修改操作就变成了只有加边操作。


3）动态点分治

1.https://www.lydsy.com/JudgeOnline/problem.php?id=4372

`2` `20190610` `bzoj4372` `点分树` `线段树`

2.https://www.lydsy.com/JudgeOnline/problem.php?id=5192

`3` `20190615` `bzoj5912` `点分树` `动态点分治` `树直径`



【9】动态树问题的几个扩展与经典应用

1）EET

2）Top Tree

【10】各类树套树与动态经典问题

1）线段树套平衡树

1.http://blog.csdn.net/u014609452/article/details/51428431

2.http://www.lydsy.com/JudgeOnline/problem.php?id=3196

3.http://www.lydsy.com/JudgeOnline/problem.php?id=2141

4.http://www.cnblogs.com/iwtwiioi/p/3925416.html

5.http://www.lydsy.com/JudgeOnline/problem.php?id=3295

6.http://www.lydsy.com/JudgeOnline/problem.php?id=1058

7.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2112

8.http://codeforces.com/problemset/problem/785/E

9.http://codeforces.com/problemset/problem/19/D

注：线段树维护一组set中最大值的变化，查询>=pos下标中值>=x的最小下标，在指定set中进一步维护或者查询

2）树状数组套主席树

1.http://www.lydsy.com/JudgeOnline/problem.php?id=2120

2.http://blog.csdn.net/clove_unique/article/details/54318285

3.http://www.lydsy.com/JudgeOnline/problem.php?id=3110

4.http://www.lydsy.com/JudgeOnline/problem.php?id=4785

5.http://www.lydsy.com/JudgeOnline/problem.php?id=3932


3）动态仙人掌问题

4）动态凸包问题

5）线段树静态标记与二维线段树

1. 区间修改、区间求和

sum[]: 当前节点下方的和（包括当前节点）

la[]: 当前节点的标记

```c++
void upd(int L, int R, ll c, int l = 1, int r = n, int rt = 1) {
	sum[rt] += c * (min(R, r) - max(L, l) + 1); 
	if(L <= l && r <= R) return la[rt] += c, void();
	int mid = l + r >> 1;
	if(L <= mid) upd(L, R, c, l, mid, ls);
	if(R > mid) upd(L, R, c, mid + 1, r, rs);
}
ll qry(int L, int R, int l = 1, int r = n, int rt = 1) {
	if(L <= l && r <= R) return sum[rt];
	ll ans = la[rt] * (min(R, r) - max(L, l) + 1);
	int mid = l + r >> 1;
	if(L <= mid) ans += qry(L, R, l, mid, ls);
	if(R > mid) ans += qry(L, R, mid + 1, r, rs);
	return ans;
}
```

2. 区间加、区间最值

```c++
void upd(int L, int R, ll c, int l = 1, int r = n, int rt = 1) {
	if(L <= l && r <= R) return la[rt] += c, ma[rt] += c, void();
	int mid = l + r >> 1;
	if(L <= mid) upd(L, R, c, l, mid, ls);
	if(R > mid) upd(L, R, c, mid + 1, r, rs);
	ma[rt] = max(ma[ls], ma[rs]) + la[rt];
}
ll qry(int L, int R, int l = 1, int r = n, int rt = 1) {
	if(L <= l && r <= R) return ma[rt];
	int mid = l + r >> 1; ll ans = -inf;
	if(L <= mid) ans = max(ans, qry(L, R, l, mid, ls));
	if(R > mid) ans = max(ans, qry(L, R, mid + 1, r, rs));
	return ans + la[rt];
}
```



题目：

1.http://acm.hdu.edu.cn/showproblem.php?pid=4819

注：模板题，矩形区间查询双最值，单点替换



【11】STL中的pd_bs库和rope大法

【12】kd-tree

1.http://www.lydsy.com/JudgeOnline/problem.php?id=4358

2.http://www.lydsy.com/JudgeOnline/problem.php?id=2683

3.http://www.lydsy.com/JudgeOnline/problem.php?id=4066

4.http://www.lydsy.com/JudgeOnline/problem.php?id=2850

5.http://www.lydsy.com/JudgeOnline/problem.php?id=2626

6.http://www.lydsy.com/JudgeOnline/problem.php?id=4520

7.http://www.lydsy.com/JudgeOnline/problem.php?id=2989

8.http://www.lydsy.com/JudgeOnline/problem.php?id=4130

9.http://www.lydsy.com/JudgeOnline/problem.php?id=2648

10.http://www.lydsy.com/JudgeOnline/problem.php?id=2716

11.http://www.lydsy.com/JudgeOnline/problem.php?id=3053

12.http://www.lydsy.com/JudgeOnline/problem.php?id=3489

13.http://www.lydsy.com/JudgeOnline/problem.php?id=4154

14.http://www.lydsy.com/JudgeOnline/problem.php?id=3007

15.http://www.lydsy.com/JudgeOnline/problem.php?id=4219

16.http://www.lydsy.com/JudgeOnline/problem.php?id=4605

17.http://acm.hdu.edu.cn/showproblem.php?pid=2966

18.http://acm.hdu.edu.cn/showproblem.php?pid=4347

19.http://acm.hdu.edu.cn/showproblem.php?pid=5992

20.http://www.lydsy.com/JudgeOnline/problem.php?id=1941

21.https://nanti.jisuanke.com/t/31451




【13】veb树（van Emde Boas）

1.https://www.lydsy.com/JudgeOnline/problem.php?id=3685



【14】基础数据结构经典题

不交区间并set：

1.http://codeforces.com/problemset/problem/915/E

2.http://codeforces.com/problemset/problem/915/F

3.http://codeforces.com/problemset/problem/926/J

离散化线段树：

1.http://codeforces.com/problemset/problem/817/F

线段树+自然hash+递归开关:

1.http://codeforces.com/problemset/problem/914/D

优先队列+全局非负减/全局标记：

1.http://codeforces.com/problemset/problem/923/B

2.https://vjudge.net/contest/274500#problem/K

二分+贪心+单调队列/双指针:

1.http://codeforces.com/problemset/problem/924/B

数形结合+逆序对：

1.http://codeforces.com/problemset/problem/924/D

字典树+贪心式处理：

1.http://codeforces.com/problemset/problem/928/D

动态地树上倍增：

1.http://codeforces.com/problemset/problem/932/D

优先队列模拟题：

1.http://codeforces.com/problemset/problem/962/D

线段树模拟费用流：

1.https://www.lydsy.com/JudgeOnline/problem.php?id=4977

线段树单点修改+查询pos右侧第一个大于/小于x的下标：
(维护区间最值，左子树合法时优先查询，有解直接返回，然后考虑右子树)

1.https://nanti.jisuanke.com/t/30996

无穷序列逆序对问题：

1.http://codeforces.com/problemset/problem/540/E

http://acm.hdu.edu.cn/showproblem.php?pid=6291







【15】数据结构中档题

1.http://codeforces.com/problemset/problem/961/E

2.https://nanti.jisuanke.com/t/31459

3.https://nanti.jisuanke.com/t/31460

4.https://nanti.jisuanke.com/t/31714

5.http://codeforces.com/problemset/problem/1000/F

6.http://codeforces.com/problemset/problem/1083/C

注：线段树合并式dp，一个节点[l,r]存储树上包含此闭区间数值的最小链端点对，此信息可单点修改，合并维护

查询最小非法前缀，查询时，带一个动态修改的查询参数，表示当前区间[l,r]严格前面的区间[0,l-1]的信息并

查询时，左子树不可并，递归去左子树，否则右子树；叶节点特判是否符合

7.https://ac.nowcoder.com/acm/contest/883/F

注：扫面线+单调队列，子矩形类经典题

8.https://ac.nowcoder.com/acm/contest/883/J

注：利用链表思想，维护中间快速删除元素的序列

9.http://acm.hdu.edu.cn/showproblem.php?pid=6602

注：如果右端点固定，对于每种元素，可行的左端点下标是两段连续的区间。

对于每种元素，将它的可行左端点区间在线段树中加一。

当右端点右移的时候，维护 $C$ 种元素的可行左端点。

查询时只需要询问线段树中最小的、值为 $C$ 的下标即可。

10.https://ac.nowcoder.com/acm/contest/885/J

11.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001482 G

12.https://codeforces.com/contest/1252/problem/K

注：中档题；二元组$(a,b)$遇到$A$指令变成$(a+b,b)$，遇到$B$指令变成$(a,a+b)$，给定长度为$n$的指令字符串(只含$AB$两字母)，支持区间翻转($AB$互换)，区间查询(带初始二元组值($a,b$)，输出结果二元组)；将指令作用表示为$2*2$矩阵，线段树维护区间矩阵乘法，每个节点存该区间内的矩阵积和翻转之后的矩阵积，区间翻转打标记时$swap$二者即可。

13.https://codeforces.com/contest/1252/problem/G

注：中档题，题意较复杂，追踪一些变量，最终转化为后缀加减，全局查询最小值。

14.http://acm.hdu.edu.cn/showproblem.php?pid=5537

注：中档题，经过转化后，线段树求矩形面积并(整点个数)

15.http://acm.hdu.edu.cn/showproblem.php?pid=4822

注：中档题，$2013icpc$长春$J$题，树上倍增；题意：给定$n \le 10^5$点的无根树，多次询问$(x,y,z)$，需要给出三个答案，分别表示三者占据节点的个数，一个节点被$x$占据，当且仅当到$x$距离严格小于到$y$或$z$的距离。为了简化题目，不妨考虑$2$个点的版本，等价于寻找这条树上链的中心，断开后$x$将占据无根树的一棵子树；显然，三个点版本实质是两棵子树的交。为了精确描述问题，以$1$为根定$dfs$序，得到每个节点的子树区间，后面将用此表达子树。询问拆为对称的三个，只考虑$x$占据的节点，再拆为两个，即只考虑相对于$y$的答案；先得到中心节点$k$，这通过求树上距离，$lca$等稍加讨论即可得到，回答若换根为$y$，则中心节点$k$占据的子树区间；而这是经典的树上换根$dfs$序问题，形式只可能是一个区间，或者一个区间的补，实际上均可以广义的表达为若干不交区间的并形式。下面要求两个并的交，根据德摩根定律，只要完全拆开，求第一个并$A$中的区间$p$和第二个并$B$中的区间$q$的交即可，答案叠加其长度。

- 换根为$r$，若$x$是$r$的严格祖先，$x$子树为$[1,n]-[L_x,R_x]=[1,L_x)\cup(R_x,n]$；否则$x$子树区间不变，即$[L_x,R_x]$

16.https://codeforces.com/gym/102431/   $K$题

注：基础题，$CCPC\_Final2019$，给定一棵树($1$为根)，对每棵子树计算子树内所有标号构成的集合里，连续自然数的段数；启发式合并或者枚举相邻标号的树上$lca$计算贡献等。








【15】双指针

1.http://codeforces.com/problemset/problem/901/C

2.http://codeforces.com/problemset/problem/939/E

3.http://codeforces.com/problemset/problem/958/F2



【16】延迟操作/懒标记思想/相对运动懒标记/隐式删除/差分思想与前缀和/数学变换的表达与转化

1.http://codeforces.com/problemset/problem/924/C

2.http://codeforces.com/problemset/problem/960/D



【17】长链剖分

参考资料：

https://blog.bill.moe/long-chain-subdivision-notes/

https://www.cnblogs.com/zzqsblog/articles/6700133.html

http://www.cnblogs.com/zhoushuyu/p/9468669.html

https://www.cnblogs.com/meowww/p/6403515.html

https://zhuanlan.zhihu.com/p/25984772

题目：

1.https://vijos.org/d/Bashu_OIers/p/5a79a3e1d3d8a103be7e2b81

2.https://www.lydsy.com/JudgeOnline/problem.php?id=4543

`5` `20190610` `bzoj4543` `长链剖分` `dp`

- 前置题目 bzoj3522，其实没啥联系
- dp状态不好想
  - $g[u][i]$ 表示 u 的子树中有多少个 pair 对只要在 u 顶上加一条长度 i 的就凑成一个合法的三元组了
  - $f[u][i]$ 表示 u 的子树中有多少个点与 u 距离 i
  - dep[u] 表示 u 与子树中最远的叶子距离
  - 显然 i 的范围是 0 到 dep[u]
- 转移
  - 一棵子树一棵子树的加，考虑新加子树与原来那一坨对答案的贡献
  - 考虑子树中已有的 g 数组，新子树与原来一坨对当前 g 的贡献
  - f 比较简单
- 长链剖分
  - f 比较简单
  - g 的过程就是把最前面那个删掉，在最后面加上两个。首先要倒着存，其次数组开两倍。坐标重定位推一推。

3.https://www.lydsy.com/JudgeOnline/problem.php?id=1758

4.http://codeforces.com/problemset/problem/1009/F

5.https://www.lydsy.com/JudgeOnline/problem.php?id=3252

6.https://www.lydsy.com/JudgeOnline/problem.php?id=3653








【18】Leafy Tree 及其实现的加权平衡树

论文：2018年集训队论文






【19】基环树

1.http://codeforces.com/problemset/problem/875/F

求最大生成基环树，把二分图一边度都为2的点当成边是个套路 

2.https://www.lydsy.com/JudgeOnline/problem.php?id=1040

求基环树带权最大点独立集，注意自环和二元环时的重边 

3.https://www.lydsy.com/JudgeOnline/problem.php?id=3242

求边上一点到基环树最远点距离最小，可以转化成基环树断一条环边使直径最小

分类讨论，处理选的两点在断掉一边和分在两边的情况 

4.https://www.lydsy.com/JudgeOnline/problem.php?id=1791

求基环树的直径

5.https://www.lydsy.com/JudgeOnline/problem.php?id=2791

类似于基环树上求lca，分类讨论，注意自环 

6.https://www.lydsy.com/JudgeOnline/problem.php?id=2878

求基环树上任意起点走的路径长度期望，比较复杂的dp，以及常见的树上换根套路，环比较小，环上可以暴力做

7.https://www.lydsy.com/JudgeOnline/problem.php?id=1116

判断图是否有子图是基环树，水题，可以认为边权为1求最大生成基环树

8.http://acm.hdu.edu.cn/showproblem.php?pid=6370

9.http://acm.hdu.edu.cn/showproblem.php?pid=6403

10.http://acm.hdu.edu.cn/showproblem.php?pid=5304

11.http://acm.hdu.edu.cn/showproblem.php?pid=6393

12.http://acm.hdu.edu.cn/showproblem.php?pid=5967

13.https://agc008.contest.atcoder.jp/tasks/agc008_e

14.https://www.lydsy.com/JudgeOnline/problem.php?id=5362




【20】斯坦纳树

参考资料：

https://www.cnblogs.com/ECJTUACM-873284962/p/7643445.html

https://blog.csdn.net/wu_tongtong/article/details/78992913

论文：https://wenku.baidu.com/view/6b8f5c0102020740be1e9ba8.html

题目：

1.https://www.lydsy.com/JudgeOnline/problem.php?id=2959

2.https://www.lydsy.com/JudgeOnline/problem.php?id=3205

注：关键在建图，以及因为边权为1可以用多源bfs

3.https://www.lydsy.com/JudgeOnline/problem.php?id=4774

4.https://www.lydsy.com/JudgeOnline/problem.php?id=5180

注：如果图比较大且为正权，用dijstra 

5.https://www.lydsy.com/JudgeOnline/problem.php?id=4006

注：只要一些点对之间联通，做完斯坦纳树后再dp一遍 

6.http://codeforces.com/problemset/problem/152/E

注：要会记录方案

7.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3613

注：要注意如果一个点是两类关键点，设dp初值时状态要合起来

8.http://acm.hdu.edu.cn/showproblem.php?pid=3832

注：如果关键点小于等于3其实可以分别跑最短路枚举中间点算，不用斯坦纳树

9.http://acm.hdu.edu.cn/showproblem.php?pid=3311

注：点边都有代价，联通快中的点只要有一个付出代价就行，建超级源的技巧 ，向所有点连边权为点权的边

10.http://acm.hdu.edu.cn/showproblem.php?pid=4085

11.http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1965





【21】虚树

1.https://www.lydsy.com/JudgeOnline/problem.php?id=3572

2.https://www.lydsy.com/JudgeOnline/problem.php?id=3991

`3` `20190605` `bzoj3991` `思维` `dfs序`

3.https://www.lydsy.com/JudgeOnline/problem.php?id=3611

4.https://www.lydsy.com/JudgeOnline/problem.php?id=2286

5.https://www.lydsy.com/JudgeOnline/problem.php?id=4912

`5` `20190615` `bzoj4912` `虚树` `前后缀优化建图` `dp`

6.https://www.lydsy.com/JudgeOnline/problem.php?id=3879

7.https://www.lydsy.com/JudgeOnline/problem.php?id=5287

8.https://www.lydsy.com/JudgeOnline/problem.php?id=5329

9.http://codeforces.com/problemset/problem/613/D

10.http://codeforces.com/problemset/problem/966/E

11.http://codeforces.com/problemset/problem/986/E

12.http://codeforces.com/problemset/problem/809/E

13.http://acm.hdu.edu.cn/showproblem.php?pid=6035

14.https://cn.vjudge.net/problem/CodeChef-BTREE

或者：https://www.codechef.com/problems/BTREE

15.http://codeforces.com/gym/102220/problem/D

注：一棵初始点权为0的树，树上链各种成段修改，建立虚树之后，注意到虚树上一小段的点权是一致的






【22】优化建图

## 线段树优化建图

### 题目

1.https://www.lydsy.com/JudgeOnline/problem.php?id=3073

2.https://www.lydsy.com/JudgeOnline/problem.php?id=4383

3.https://www.lydsy.com/JudgeOnline/problem.php?id=5017

4.http://codeforces.com/problemset/problem/786/B

5.http://acm.hdu.edu.cn/showproblem.php?pid=5669

6.http://uoj.ac/problem/77

7.https://arc069.contest.atcoder.jp/tasks/arc069_d

8.https://www.lydsy.com/JudgeOnline/problem.php?id=3218（与6重复）

9.https://www.lydsy.com/JudgeOnline/problem.php?id=4276

## 主席树优化建图

### 题目

https://www.lydsy.com/JudgeOnline/problem.php?id=3681

http://uoj.ac/problem/77

https://www.lydsy.com/JudgeOnline/problem.php?id=3218（与上一题是同一道）

https://www.luogu.org/problemnew/show/P5284

## 字典树优化建图

### 题目

https://www.luogu.org/problemnew/show/P5284

## 前后缀优化建图

### 题目

https://www.lydsy.com/JudgeOnline/problem.php?id=3495

https://www.lydsy.com/JudgeOnline/problem.php?id=4912

`5` `20190615` `bzoj4912` `虚树` `前后缀优化建图` `dp`

https://codeforces.com/problemset/problem/587/D

https://codeforces.com/problemset/problem/1007/D



【23】笛卡尔树

参考资料：

https://www.cnblogs.com/gtarcoder/p/4702853.html

https://blog.csdn.net/qq_15033645/article/details/80961472

http://www.cnblogs.com/CaptainSlow/p/9282507.html

https://blog.csdn.net/qq_36056315/article/details/79845193

https://en.wikipedia.org/wiki/Cartesian_tree#CITEREFSeidelAragon1996

题目：

1.http://acm.hdu.edu.cn/showproblem.php?pid=6305

2.http://acm.hdu.edu.cn/showproblem.php?pid=4095

3.http://acm.hdu.edu.cn/showproblem.php?pid=6044

4.http://acm.hdu.edu.cn/showproblem.php?pid=5324

5.http://acm.hdu.edu.cn/showproblem.php?pid=1506

6.http://acm.hdu.edu.cn/showproblem.php?pid=4125

7.http://acm.hdu.edu.cn/showproblem.php?pid=6406

8.http://acm.hdu.edu.cn/showproblem.php?pid=5412

9.https://www.lydsy.com/JudgeOnline/problem.php?id=2616

10.https://www.lydsy.com/JudgeOnline/problem.php?id=2658

11.http://poj.org/problem?id=1785

12.http://poj.org/problem?id=2201

13.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=010435 J

注：有思想的笛卡尔树好题

14.https://ac.nowcoder.com/acm/contest/881/A

注：笛卡尔树基础题





【24】李超树

【25】支配树

【26】高维偏序问题

【27】树上差分小专题

1.http://codeforces.com/gym/102012/problem/G


【28】曼哈顿距离和切比雪夫距离的转化

1.http://codeforces.com/problemset/problem/1093/G


【29】dsu on tree

1.http://codeforces.com/problemset/problem/600/E


【30】珂朵莉树

1.http://codeforces.com/problemset/problem/896/C

2.http://codeforces.com/problemset/problem/343/D

3.http://codeforces.com/problemset/problem/915/E

4.https://www.lydsy.com/JudgeOnline/problem.php?id=1858

5.https://www.lydsy.com/JudgeOnline/problem.php?id=4592

6.https://www.lydsy.com/JudgeOnline/problem.php?id=5168

7.https://www.luogu.org/problemnew/show/P2787

8.https://www.luogu.org/problemnew/show/P4979

9.https://www.luogu.org/problemnew/show/P1204

【31】kruskal重构树

https://blog.csdn.net/hwzzyr/article/details/81190442

## Kruskal重构树

### 性质

是一个二叉堆

原树两点之间的边权最大值 / 原图两点之间所有路径的最大边权最小值 -> 是重构树上两点Lca的权值

重构树中代表原树中的点的节点全是叶子节点，其余每个节点都代表了某条边

## 题目

1.![kruskal](kruskal.png)

**原树两点之间的边权最大值 / 原图两点之间所有路径的最大边权最小值 -> 是重构树上两点Lca的权值**

2.https://www.lydsy.com/JudgeOnline/problem.php?id=3551

点 v 向上爬到权值为 w 的内部节点，该节点的子树都是 v 能到达的点。

3.http://uoj.ac/problem/393

和上题差不多

4.http://uoj.ac/problem/407

本质是要判断两段 dfs 序是否有相同元素，将每个元素用 $(x, y)$ 表示它在第一段、第二段出现位置，问题转化为求二维矩形内部是否有点。

5.https://ac.nowcoder.com/acm/contest/883/E





---



# 2.图论

##【1】差分约束系统

学习博客：http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html

注：

**理解**

在有向图最长路模型中，如果x到y存在一条权值和为c的有向路径，那么显然x到y的最长路不会小于c，那么即有dist[y]-dist[x]>=c，大于等于模型应该使用最长路

**关于解的存在性讨论**：

标准型形如x[i]-x[j]<=a[k]，j->i(边权a[k])，求$(x[t]-x[s])_{max}$(s到t最短路)

1)无解：s到t最短路为-oo，亦即a[t]-a[s]<=-oo显然无解；等价于图中存在s可以走到的负权环，用spfa某个点入队次数大于n来判定

2)无数解：s到t最短路为OO，即s根本走不到t，亦即a[t]-a[s]<=OO，若a[s]=0，a[t]可以任意取值

3)有限解：其余情况为有限解(假设某个变量取定值)

**关于简单建图**：

先看最后求的是什么，求$(x[t]-x[s])_{max}$，方向转化为<=，求最短路；

而如果求的是最小值，方向转化为>=，求最长路；

限制条件转化：

a=b转化为a>=b，a<=b

a < b在整数意义下，转化为a<=b-1

a + b >= c(常数)，转化为 a - (-b) >= c

**建图优化**

1).集合A连集合B，引中间点c

2).区间A连单点x，线段树优化建图

3).区间A连区间B，引中间点c，转化为2

**特别当心**

1).注意当形如a < b或者a > b的限制，如果a==b特判无解

2).注意题目中的隐藏条件：比如某个变量值必须为正数，源点dist[s]这个变量比如为0等

3).一个差分约束系统有解，则必有无穷多组解，当限制每个变量均>=c时，仍然有无穷解；

因此，任何图模型，等价于新增超级源点，连接每个点，边权为c





指定题目：

1.http://www.lydsy.com/JudgeOnline/problem.php?id=2330

2.http://acm.hdu.edu.cn/showproblem.php?pid=3666

3.http://acm.hdu.edu.cn/showproblem.php?pid=1531

4.http://acm.hdu.edu.cn/showproblem.php?pid=1534

5.http://codeforces.com/gym/100015/attachments G题

6.http://codeforces.com/problemset/problem/1131/D

7.http://codeforces.com/problemset/problem/241/E

8.https://www.lydsy.com/JudgeOnline/problem.php?id=4500

9.https://www.lydsy.com/JudgeOnline/problem.php?id=1202

10.https://www.lydsy.com/JudgeOnline/problem.php?id=4383

注：线段树优化建图+差分约束+拓扑排序思想

11.https://www.lydsy.com/JudgeOnline/problem.php?id=3436

12.https://www.lydsy.com/JudgeOnline/problem.php?id=3373

13.https://www.lydsy.com/JudgeOnline/problem.php?id=1731

14.https://www.lydsy.com/JudgeOnline/problem.php?id=2788

注：tarjan缩点+差分约束+floyed求最长路最小值

题目求最大值，建<=模型跑最短路，每个强连通分量，超级源点s连每个点边权为1；

dist[]求最大值，跑最短路是模型要求满足限制，求最大值是题目最大化的目标；

在此模型下，所有边权取负，转化为跑最长路求最小值

15.https://www.lydsy.com/JudgeOnline/problem.php?id=1077

注：floyed求任两个变量差的最大最小值，求最大值跑最长路，初值为最小值

16.https://www.lydsy.com/JudgeOnline/problem.php?id=3126

17.http://acm.hdu.edu.cn/showproblem.php?pid=6252

18.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2770

19.http://acm.hdu.edu.cn/showproblem.php?pid=1535

20.http://acm.hdu.edu.cn/showproblem.php?pid=1317

21.http://acm.hdu.edu.cn/showproblem.php?pid=4109

22.http://acm.hdu.edu.cn/showproblem.php?pid=1529

23.http://acm.hdu.edu.cn/showproblem.php?pid=3592

24.http://acm.hdu.edu.cn/showproblem.php?pid=4598

25.http://acm.hdu.edu.cn/showproblem.php?pid=1384

26.https://codeforces.com/gym/101611/problem/G





##【2】K短路问题/次小生成树

指定题目：

1.http://acm.hdu.edu.cn/showproblem.php?pid=2449

2.http://acm.hdu.edu.cn/showproblem.php?pid=4081

3.https://nanti.jisuanke.com/t/31445

##【3】度限制最小生成树


##【4】生成树的计数问题

1.http://codeforces.com/problemset/problem/156/D

##【5】Tarjan初步：

求割点/桥/最近公公祖先/强连通分支（重点）

求点双连通分量/边双连通分量（了解）

指定题目：

1.http://www.lydsy.com/JudgeOnline/problem.php?id=2438

2.http://www.lydsy.com/JudgeOnline/problem.php?id=2140

3.http://www.lydsy.com/JudgeOnline/problem.php?id=1194

4.http://codeforces.com/problemset/problem/639/F

5.http://codeforces.com/problemset/problem/962/F

6.https://www.lydsy.com/JudgeOnline/problem.php?id=5303

##【6】Kosaraju算法与缩点

##【7】Menger定理

##【8】传递闭包

##【9】图论基础综合题

1.http://codeforces.com/problemset/problem/864/F

2.http://codeforces.com/problemset/problem/919/D

3.http://codeforces.com/problemset/problem/845/G

4.http://codeforces.com/problemset/problem/949/C

5.https://nanti.jisuanke.com/t/31462

6.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001538    $E$题

注：中档题，给定$n$个点$m$条边的无向图($n,m \le 2 \times 10^5$)，从空图开始按照读入顺序依次加边，一旦图中存在点$a$到点$b$的长度为$5$的简单路径，则输出此边的编号。二分之后，转化为给定图问题。先预处理每个点是否可以由$a$走两步到达，和是否可以从$b$走两步到达，如果可以，则分别保留三个前驱点(如果存在)；枚举一条边合并路径，$check$时枚举两边的前驱节点，使其构成简单路径。

###【最短路综合】

1.http://codeforces.com/problemset/problem/938/D

2.https://nanti.jisuanke.com/t/31001

3.http://codeforces.com/problemset/problem/1070/A

4.https://codeforces.com/problemset/problem/843/D

[经典]动态最短路问题：

每次一条边权++，可以证明残差图上增量最短路取值有限，单次修改可以O(n+m)

残差图使得最短路满足可加性，意思是新增的一些边权使得最短路产生一个增量，此增量叠加到原来的最短路长度数组dist[]中即得到新图的最短路数组

5.http://acm.hdu.edu.cn/showproblem.php?pid=5521







###【欧拉图综合】

1.http://codeforces.com/problemset/problem/1152/E

注：欧拉路径方案构造



###【平面图和平面嵌入】

1.https://codeforces.com/gym/101611/problem/C

注：树的平面嵌入，坐标范围[1..1000000]*[1..20]

2.http://acm.hdu.edu.cn/showproblem.php?pid=5539

注：中档题，给定$n \le 1000$条直线，满足无三线共点，对交点染色，求此平面图的色数和构造染色方案；容易发现，由于无三线共点，故对一对直线的交点$x$，其最多与$4$个点相邻，且存在一或两个$180$度相对点，即$x$左上角(含)最多$2$个点，故此图色数$\le 3$。取出所有点，构造平面图，按照$pair$规则排序，对此序列用贪心着色法，即对$x$染色时，取其相邻点中没用过的颜色里最小编号的颜色；最后判断此图是否可以二染色(是否是二分图)，一染色(全是孤点)即可。



###【支配树/支配点】

- 定义：semi[x]叫x的半支配点。定义如下：

- semi[x]=min{v | 有路径v=v0, v1, ..., vk=x使得dfn[vi]>dfn[x]对1<=i<=k-1成立}.(掐头去尾，都走的dfn大于它的点)

- 定义：idom[x]表示支配x的点中深度最深的点，叫x的支配点，也叫idom[x]支配了x。idom[x]就是x在支配树上的父亲。

- 显然有下面的性质：

  - 1. 每个点的半支配点是唯一的。
  - 2. 一个点的半支配点必定是它在dfs树上的祖先，dfn[semi[x]]<dfn[x]。
  - 3. 半支配点不一定是x的支配点。
  - 4. semi[x]的深度不小于idom[x]的深度，即idom[x]在semi[x]的祖先链上。
  - 5. 设节点v,w满足v->w。则v->idom[w]或者idom[w]->idom[v] (a->b表示a在b的祖先链上)。

1.http://codeforces.com/group/aUVPeyEnI2/contest/243687 H题

注：支配思想的应用



## 【10】一类边数很少的特殊图问题

https://www.lydsy.com/JudgeOnline/problem.php?id=5287

注：也可以用动态dp做

http://acm.hdu.edu.cn/showproblem.php?pid=5736

## 【11】环上问题

1.https://ac.nowcoder.com/acm/contest/885/D

对于每个 x ，取出对应的最大的 y 和最小的 y

如果 x 不在环上，对应的 y 只有一个

否则，对应的 y 有多个。设 x 的循环节为 xl ，对每个 y 向它向后走 xl 步走到的 y‘ 连边，倍增维护。

## 【12】仙人掌

### 圆方树dp

http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001482 A

##【13】曼哈顿最小生成树/欧几里得最小生成树

##【14】Borůvka's algorithm/Sollin's algorithm

https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm

https://www.statisticshowto.datasciencecentral.com/boruvkas-algorithm/

##【15】弦图、区间图，完美消除序列

- 弦(chord)：连接环中不相邻的两个点的边。

- 弦图(chordalgraph)：一个无向图称为弦图当且仅当图中任意长度大于3的环都至少有一个弦。

- 单纯点(simplicialvertex)：设N(v)表示与点v相邻的点集。一个点称为单纯点当{v} + N(v)的诱导子图为一个团。

- 完美消除序列(perfect elimination ordering)：这是一个序列{v[i]}，它满足v[i]在{v[i..n]}的诱导子图中为单纯点。

- 弦图的判定：存在完美消除序列的图为弦图。可以用MCS最大势算法求出完美消除序列。

- 最大势算法 Maximum Cardinality Search

  - 从n到1的顺序依次给点标号(标号为i的点出现在完美消除序列的第i个)。

  - 设label[i]表示第i个点与多少个已标号的点相邻，每次选择label[i]最大的未标号的点进行标号。

  - 用n个链表来保存label为i的是哪些点，可以使复杂度达到O(n+m)。

- 弦图上的问题：

  - 色数：完美消除序列从后往前依次给每个点染上可以染的最小的颜色。
  
  - 最大独立集：完美消除序列从前往后能选就选。
  
  - 极大团的形式一定是完美消除序列中的{v} + N(v)，但不一定都是极大团 
  
  - 团数 = 色数   最大独立集 = 最小团覆盖  团覆盖方案为点独立集的{v} + N(v)   

  - 判断一个序列是否为完美消除序列：设{vi+1,…,vn}中所有与vi相邻的点依次为vj1,…, vjk。只需判断vj1是否与vj2,…, vjk相邻即可。

- 区间图(Interval Graph)：给定一些区间，定义一个相交图为每个顶点表示一个区间，两个点有边当且仅当两个区间的交集非空。

- 区间图一定是弦图。

- 给定n个区间，所对应的区间图为G，G的一个完美消除序列：将所有的区间按照右端点从小到大排序。

1.https://www.luogu.org/problem/P3196

  求弦图的色数

##【16】最大团

##【17】最优比率生成树/最优比率环，01分数规划

**最优比率环的结论**：令$f[i][v]$表示从起点$1$开始走$i$步走到$v$点的(点可重复经过)最短距离，$O(nm)$复杂度
$$
\mu =\min _{v \in V} \max_{k=0}^{n-1}\frac{f[n][v]-f[k][v]}{n-k}
$$


1.http://poj.org/problem?id=2976

裸题

2.http://poj.org/problem?id=2728

二分后直接求最小生成树

3.http://poj.org/problem?id=3621

二分以后就转成有向图负环判断



##【18】最小树形图

##【19】2-sat问题

学习：

http://blog.csdn.net/jarjingx/article/details/8521690



1.http://www.lydsy.com/JudgeOnline/problem.php?id=1997

​	判断一个环上连一些边能不能平面嵌入，每条边有可以在内部和外部两种，处理出之间的限制看2-sat有没有解即可

2.https://www.lydsy.com/JudgeOnline/problem.php?id=2199

​	2-sat有两种解法，一种是缩点后求任意解，另一种是直接暴力dfs，可以确定字典序最小解，一个元素是不是必选之类的问题。

3.http://www.lydsy.com/JudgeOnline/problem.php?id=1823

4.http://poj.org/problem?id=3683

5.http://poj.org/problem?id=3207

6.http://www.lydsy.com/JudgeOnline/problem.php?id=4945

7.https://www.lydsy.com/JudgeOnline/problem.php?id=4078

​	把图中点分成两个集合，使两个集合内的最大距离相加最小，枚举大的集合限制，有奇偶环优化，即不行的边不能构成基环，以及构成偶环的最小边不会是限制，用并查集维护，判断方案是否可行用2-sat。

8.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=010435 B

首先建到达关系的图，缩完点后发现一个物品会被取到至少要访问到横线或竖线中一个，就是在新的DAG途中的两个点，题目转化为固定起点，判断在DAG中是否存在路径可以经过所有限制中至少一个，用2-sat建图求解。然后这个对普通应该图也是可行的，只是复杂度是O(n^2)的。
总结：

http://www.cnblogs.com/-ZZB-/p/6635483.html


9.http://codeforces.com/problemset/problem/780/D

裸题

10.http://codeforces.com/problemset/problem/776/D

裸题

11.http://codeforces.com/problemset/problem/587/D

一堆变量至多选一个的这种特殊限制可以用前后缀优化来实现

12.http://codeforces.com/problemset/problem/568/C

13.http://codeforces.com/problemset/problem/538/H

14.http://codeforces.com/problemset/problem/538/H

15.http://codeforces.com/problemset/problem/228/E

16.http://codeforces.com/problemset/problem/27/D

17.https://arc069.contest.atcoder.jp/tasks/arc069_d

二分后线段树优化建图，再用tarjan判断是否可行

19.http://codeforces.com/problemset/problem/1215/F

每个变量上有区间，需要确定$f$, 使选的变量区间都包含$f$，通过类似前后缀优化的思想，引入额外变量$m_i$表示选了这个变量就会有$f >= i$ ,即可优化限制数量。

20.http://codeforces.com/problemset/problem/193/A

21. http://acm.hdu.edu.cn/showproblem.php?pid=4115 

注：模板题



##【20】图论基础经典题·拓扑排序

1.http://codeforces.com/problemset/problem/915/D

2.http://codeforces.com/problemset/problem/909/E

##【21】图的搜索树的构造与应用

http://codeforces.com/problemset/problem/990/F


##【22】瓶颈路

1.https://www.lydsy.com/JudgeOnline/problem.php?id=3732

裸题，建最小生成树后转树上路径询问，倍增或树剖都可以

##【23】图的可图性质

注意简单图要求没有自环和多重边，以下任意度序列数值$\ge 0$即可

[Havel–Hakimi algorithm](http://acm.hdu.edu.cn/showproblem.php?pid=4797)：判定是否可图(**简单无向图**)，***构造性算法***

将度序列排序为非递增形式$S=(d_1,d_2,\cdots,d_n)$，删除$d_1$，从$d_2$开始(含)向后取连续$d_1$个，这些元素$-1$(对应着连边)，并且重新$sort$，开始新的一轮。每轮如果发现有元素被减为负数，或者所取数量不够，则无解。

[Erdős–Gallai theorem](https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Gallai_theorem)： 判定是否可图(**简单无向图**)

将度序列排序为非递增形式$S=(d_1,d_2,\cdots,d_n)$，要求度之和为偶数，且以下公式对任意$k \in [1,n]$均成立：
$$
\sum_{i=1}^{k} d_{i} \leq k(k-1)+\sum_{i=k+1}^{n} \min \left(d_{i}, k\right)
$$
[Gale–Ryser theorem](https://en.wikipedia.org/wiki/Gale%E2%80%93Ryser_theorem)：判定是否可图(**简单带标号二分图**)

给定$a[1..n],b[1..n]$满足$a[i]$非严格减($b[i]$不要求有序)，$sum(a)=sum(b)$且以下公式对任意$k \in [1,n]$均成立：
$$
\sum_{i=1}^{k} a_{i} \leq \sum_{i=1}^{n} \min \left(b_{i}, k\right)
$$
注：当左侧$n$个点，右侧$m$个点时，相当于补全$max(n,m)$个点，由于度可为$0$，不足补$0$即可

[Gale–Ryser theorem](https://en.wikipedia.org/wiki/Gale–Ryser_theorem)：判定是否可图(**简单可带自环有向图**)

因为可带自环的有向简单图与一个简单二分无向图一一对应 ，每个点拆点为$in,out$，每条边连接$out_x,in_y$无向边，原图每个点$x$的入度为$in_x$的度，出度为$out_x$的度，则得到一个二分图，沿用上述定理判定是否可简单二分图即可

[Fulkerson–Chen–Anstee theorem](https://en.wikipedia.org/wiki/Fulkerson%E2%80%93Chen%E2%80%93Anstee_theorem)：判定是否可图(**简单有向图**)

给定长度为$n$的$pair$序列$(a[i],b[i]),i \in [1,n]$满足$a[i]$非严格减($b[i]$不要求有序)，$sum(a)=sum(b)$且以下公式对任意$k \in [1,n]$均成立：
$$
\sum_{i=1}^ka_i\le \sum_{i=1}^k \min(b_i,k-1)+\sum_{i=k+1}^n \min(b_i,k)
$$
[Kleitman–Wang algorithms](https://en.wikipedia.org/wiki/Kleitman%E2%80%93Wang_algorithms)：判定是否可图(**简单有向图**)，***构造性算法***

- 给定$S=((a_1,b_1),\dots,(a_n,b_n))$满足有限长、非负且字典序不严格降，找到满足$b_i>0$的一个$pair$$(a_i,b_i)$；则序列化归为$S'=((a_1-1,b_1),\dots,(a_{b_i-1}-1,b_{b_i-1}),(a_{b_i},0),(a_{b_i+1},b_{b_i+1}),(a_{b_i+2},b_{b_i+2}),\dots,(a_n,b_n))$非负可图；此步方案构造：连接$(v_i,v_1),(v_i,v_2),\dots,(v_{i},v_{b_i-1}),(v_i,v_{b_i+1})$，最后由全$0$的$pair$组成时结束
- 给定$S=((a_1,b_1),\dots,(a_n,b_n))$满足有限长、非负且$\{a_i\}$不严格降，找到满足$(b_i,a_i)$在$\{(b_j,a_j)\}$中字典序最大的一个$pair$$(a_i,b_i)$；则序列化归为$S'=((a_1-1,b_1),\dots,(a_{b_i-1}-1,b_{b_i-1}),(a_{b_i},0),(a_{b_i+1},b_{b_i+1}),(a_{b_i+2},b_{b_i+2}),\dots,(a_n,b_n))$非负可图；此步方案构造：连接$(v_i,v_1),(v_i,v_2),\dots,(v_{i},v_{b_i-1}),(v_i,v_{b_i+1})$，最后由全$0$的$pair$组成时结束



1.http://codeforces.com/problemset/problem/1091/E

注：n+1个点的无向简单图，给定其中n个点的度序列，问最后一个点的度数取值集合

结论：握手定理，且答案构成或奇或偶一个连续区间

由Erdős–Gallai theorem知，需要符合n+1个不等式，最后一个显然成立，也就是要满足n个条件；对每个条件，单独计算答案的可能区间，区间加1；全部做完，看哪些值的标记达到n；使用差分思想，时间复杂度O(n)

2.http://acm.hdu.edu.cn/showproblem.php?pid=4797

注：$2013icpc$长沙$G$题，给定无向简单图的节点度序列，判断是否可图，并指出是否有唯一解，唯一解构造一组解，多解构造两组解。$HH$算法，当算法到某个阶段时，选择一系列点度减$1$，如果被选择的点中度最小的一种度可以有多种不同选择，想办法通过交换，构造第二组解(唯一性有待验证)。



## 【24】一般图匹配

1.https://www.51nod.com/Challenge/Problem.html#problemId=1857

注：中档题，给定长度为$n$的$01$串$s,t$；要将$s$变为$t$，每次花费$w[l][r]$的代价使得区间$[l,r]$的部分$01$翻转，求最小代价和。考虑到每次相当于区间异或(二进制不进位加法)，如果对其进行差分，则可转化为对两个单点的翻转；故对$s,t$进行差分得到$s',t'$；每次修改两个不同下标，满足一些下标总计被修改奇数次，一些下标总计被修改偶数次。将每个下标看成点，一次修改看成边，则使得部分点度数为奇数，另一些为偶数。考虑每次选取一条路径匹配掉两个奇度点，中间可以途径任何点，则提取所有奇度点，构造新图，边权为两点最短路径；对此完全图做一般图最大带权匹配，可以证明解必定存在。

2.2019CCPC厦门$B$题

3.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001531 $A$题

## 【25】 树哈希(树hash)

1.https://codeforces.com/contest/1252/problem/F

注：基础题，求无根树树上一个点$x$，要求度最大；且删去此点之后，各个联通块在无根树意义下同构；树$hash$模板题。










# 3.网络流



《网络流$24$题》题库

https://www.luogu.org/problem/list?tag=332



【1】最大流/最小割

1.http://codeforces.com/problemset/problem/1082/G

注：经典问题，边权非负的最大子图，图的关联二分图构造最大权闭合图模型

2.http://www.lydsy.com/JudgeOnline/problem.php?id=1001

注：经典题目，平面图最小割，转对偶图最短路；本质将无穷远点，分裂成$s'$和$t'$，求$s'$到$t'$最短路

3.http://www.lydsy.com/JudgeOnline/problem.php?id=1797

注：经典问题，问哪些边是最小割的可行边/必选边；对残量网络强连通缩点，满流边中，可行边连接不同强连通分量，必选边连接$S$和$T$分别所在的强连通分量；等价的，若$x\to y$满流：$x$可以到$y$等价于可行边，$S$可以到$x$且$y$可以到$T$等价于必选边

4.http://www.lydsy.com/JudgeOnline/problem.php?id=2561

注：不错的最小割基础题，给定带权无向图，询问至少删除多少边，某条边才会同时出现在其最小生成树和最大生成树上；假设边为$(u,v,w)$，则其在图最小生成树上，等价于仅保留图中边权$<w$的边，$u,v$不连通，故删边最少等价于最小割；注意两个条件独立，两个答案相加即可

5.http://acm.hdu.edu.cn/showproblem.php?pid=6582

注：经典的最短路图上的最小割问题


【2】费用流/带负权环

1.http://www.lydsy.com/JudgeOnline/problem.php?id=1877

注：模板题，拆点费用流

2.http://www.lydsy.com/JudgeOnline/problem.php?id=2668

注：难题，交换棋子问题；给定$n\times m(n,m\le 20)$的棋盘，每次可以$8$连通的选择两个棋子交换，求给定棋盘状态$A$到状态$B$的最小交换次数，棋盘上铺满黑白二色棋子。其次，每个格子有个$a_{i,j}$表示最多交换的次数。

基本分析：

- 无解情况：黑色棋子个数不等
- 交换操作比较复杂，不妨看成黑色棋子的移动；则显然，只有$A$黑$B$白的棋子会率先移动，移动到一个$A$白$B$黑的格子；且移动过程中，不可能遇到黑色棋子，即移动路径中只有起点会是黑色棋子。
- 考虑格子的交换次数，对于一条移动路径，只有起点和终点的格子交换了$1$次，其余中间的格子均交换$2$次；考虑拆点来表达次数的限制，假设不考虑两边的特殊情况，则一个格子可以拆为两个点$in,out$；显然，之间引一条有向边容量为$a_{i,j}/2$。
- 为体现路径端点的区别，一个格子再拆一个点$mid$，$in\to mid \to out$，源点$S$连接$A$黑$B$白的格子$mid$，$A$白$B$黑的格子$mid$连接汇点$T$(容量为$1$，费用为$0$)，如果$in\to mid \to out$容量仍然为$a_{i,j}/2$，那么仍然无法体现端点区别
- 考虑一个格子被经过的情况，它会被在中间经过若干次，在端点最多一次；如果次数为奇数，那么显然有一个零头可以给端点处用，因为端点只消耗$1$；如果是偶数，则很不幸，端点与中间无本质差异，因为消耗$1$同消耗$2$，剩余的$1$不会再被使用；故入口$mid \to out$容量设置为$a_{i,j}+1>>1$；出口$in \to mid$容量设置为$a_{i,j}+1>>1$；注意不作为出入口的格子容量不变
- $8$连通$out \to in$，容量为$inf$，费用为$0$；所有$in \to mid$，费用为$1$，其他费用为$0$
- 考虑一个流的路线，恰好对应一条移动棋子的路径；故跑最小费用最大流，如果最大流小于黑色棋子个数，则亦无解

总结：注意三拆点的技巧应用

3.http://www.lydsy.com/JudgeOnline/problem.php?id=2597

注：经典问题，竞赛图的定向问题，目标使得其无序三元环数量最大；容斥原理+费用流

考虑补集转化，一个三角形不是有向三元环，则必存在一个点有两个出度，二者一一对应；

等价于最小化$\sum_{x}\binom{d(x)}{2}$，其中$d(x)$表示$x$出度；混合图使用自然依赖构造二分图：左部为边，右部为点，若边已定向，由于我们追踪出度，故连到起点；未定向，连向两个端点；容量均为$1$，费用为$0$；源连所有边，容量为$1$，右部所有点连汇点，容量为$n$，费用是关于流$x$的函数$C(x)=x(x-1)/2=0+1+2+..$，拆边构造费用函数即可

总结：定向问题，考虑用一个流表示一条边的决策，定向常常追踪度的变化；拆边构造费用函数，要求满足差分非负且递增，即凸函数

4.http://www.lydsy.com/JudgeOnline/problem.php?id=1834

注：基础题，问所给网络中为了使得最大流增加$k$，我们可以增大一些边的容量，每条边增大每个单位容量代价已知；求最小代价。每条边添加平行边，容量为$inf$，费用为已知代价；追加超级源点，限制最大流不超过$f+k$。

5.http://codeforces.com/problemset/problem/813/D

注：下一题的弱化版

6.http://codeforces.com/problemset/problem/818/G

注：好题，给定$n\le3000$，$a_i \in[1,10^5]$；定义其一个子序列为$melody$为：任意相邻两个元素差绝对值为$1$或者模$7$同余。取不超过$4$个不交的$melody$子序列，最大化点数之和。

先证明其满足几个性质：

- 子序列强分拆性：序列$a$的任两个不同的$melody$子序列$p,q$，一定可以重新组织分拆为两个新的**不交**子序列$p',q'$；使得$|p' \cup q'|=|p \cup q|$
- 可达性：任意两个下标$i<j$，若$a_i,a_j$可以相邻，则在所构造的有向图中$i$要能够走到$j$
- 可贪心：点权非负，这样任何一个合法的$melody$子序列都可以被一个$s-t$路覆盖

由贪心知：我们可以选择几条可以相交的$s-t$路，使得点集的并的$size$最大化

- $n$个点$1..n$排成一排，每个点连接右边第一次与自己同余的，比自己大$1$和比自己小$1$的元素，容量为$1$，费用$0$
- 每个点的价值只能取$1$次，拆点引两条内部边，费用为$-1$和$0$，容量为$1$和$inf$
- 源点$S$连第一个余数出现的元素，最后一个连汇点$T$，容量为$1$，费用为$0$
- 控制流$f\le 4$

总结：这是求可以交的子序列并的最大价值和的经典模型

- 证明：强分拆性
  - 假设两个子序列$a,b$相交，令其交点$P$；首先如果$P$为某个子序列的开头或者结尾，则该子序列一定可以出让这个点给对方，下面只考虑有前后继的情况
  - 令$P$的两个入口为$r1,r2$；出口为$c1,c2$；则$r1!=r2$。假设$c1=c2$，则$P$后面的一个点也为交点，二者合并为一个点，可以化归问题；下面考虑$c1!=c2$
  - 考虑$\{r1,r2,c1,c2\}$，一共只有上中下三种取值，由抽屉原理，必有二者相等；而同侧两个必然不等，故设左侧$x=$右侧$y$，则显然$x,y$同余，因为如果$x,y$不从中间穿过；则必然值相等。故将$x$与$y$匹配，出让$P$给另一对接口匹配
  - 这样调整构造了两个不交的子序列

7.http://codeforces.com/problemset/problem/802/C

注：好题，题目：图书馆最多可以保存$k$本书，共$n$天，第$i$天要求存在书$a_i$，不存在则购买并放入，如果放满了，则替换掉某一本；购买书$x$的价格为$c[x]$，求满足要求的最小代价。考虑图书馆存在一个$k$格书架；注意到第$i$格的迭代序列必为序列$a$的一个子序列。故考虑将下标分划为不超过$k$个子序列，使得总代价最小；一个子序列$p$的代价为$C(p)=c[a[p[1]]+\sum_{i=2}^L(a[p[i]]!=a[p[i-1]])c[a[p[i]]]$，子序列间不能相交，且并之为全集。

- 考虑$n$个点$1..n$排成一排，连成竞赛图，$\forall i<j,i \to j$，费用：书编号相等则为$0$，否则为新买入后者代价
- 源点$S$连接每个点，费用为买入书代价；每个点连接汇点$T$，费用为$0$
- 点不能重复选，且流需要诱导，使其经过所有点，才能满足要求；故$i \in [1,n]$这个点拆点，引容量为$1$，费用$-inf$
- 所有边容量为$1$，考虑方案的对应，一个流对应一个格子的迭代过程，故控制流$f\le k$

总结：本质为不交子序列的最优化分拆问题，经典模型；注意无穷费用边的诱导作用

【3】二分图最大匹配：匈牙利

【4】模型：最小点/边/路径覆盖/最大独立集/最小支配集

【5】模型：稳定婚姻系统

【6】带上下界的流：上下界费用流

【7】最小割树 [Gomory–Hu tree](https://en.wikipedia.org/wiki/Gomory%E2%80%93Hu_tree)
1.https://www.luogu.org/problem/P3329
  http://www.lydsy.com/JudgeOnline/problem.php?id=2229

2.https://www.luogu.org/problem/P4123

3.https://www.luogu.org/problem/P4897

模板题，主要就是最小割只有n-1种，以及可以通过递归建出一个特殊的最小割树，有两点间最小割为树上路径最小值的性质	

4.https://www.lydsy.com/JudgeOnline/problem.php?id=4435







【二分图综合】

1.http://www.lydsy.com/JudgeOnline/problem.php?id=4205

2.https://www.byvoid.com/zhs/blog/noi-2009-transform

http://www.lydsy.com/JudgeOnline/problem.php?id=1562

3.http://www.lydsy.com/JudgeOnline/problem.php?id=1059

4.http://www.lydsy.com/JudgeOnline/problem.php?id=1191

5.http://www.lydsy.com/JudgeOnline/problem.php?id=1854

6.http://www.lydsy.com/JudgeOnline/problem.php?id=2150

7.http://www.lydsy.com/JudgeOnline/problem.php?id=1143

8.http://www.lydsy.com/JudgeOnline/problem.php?id=2744

9.http://www.lydsy.com/JudgeOnline/problem.php?id=2437

10.http://www.lydsy.com/JudgeOnline/problem.php?id=4443

11.http://www.lydsy.com/JudgeOnline/problem.php?id=4950

12.http://www.lydsy.com/JudgeOnline/problem.php?id=1433

13.http://www.lydsy.com/JudgeOnline/problem.php?id=3175

14.http://www.lydsy.com/JudgeOnline/problem.php?id=4554

15.http://www.lydsy.com/JudgeOnline/problem.php?id=4025

16.http://www.lydsy.com/JudgeOnline/problem.php?id=1934

17.http://www.lydsy.com/JudgeOnline/problem.php?id=2539

18.http://www.lydsy.com/JudgeOnline/problem.php?id=1189

19.http://www.lydsy.com/JudgeOnline/problem.php?id=3140

20.http://www.lydsy.com/JudgeOnline/problem.php?id=3291

21.http://www.lydsy.com/JudgeOnline/problem.php?id=1443

22.http://www.lydsy.com/JudgeOnline/problem.php?id=1475

23.http://www.lydsy.com/JudgeOnline/problem.php?id=1997

24.http://www.lydsy.com/JudgeOnline/problem.php?id=1741

25.http://www.lydsy.com/JudgeOnline/problem.php?id=4080

26.http://codeforces.com/group/aUVPeyEnI2/contest/243686 H题





【网络流综合】

阅读：https://wenku.baidu.com/view/a22336727fd5360cba1adb83.html
《最小割模型在信息学竞赛中的应用》

http://blog.csdn.net/qq_35649707/article/details/77482691

**最小割方案相关**：

最小割的方案应该从点集分配的角度理解会比较科学，S和T代表两边集合，s和t代表源汇。

被分配到S的点可以认为都是源点，分配到T的都是汇点，割掉所有S到T的边

**1.割边**

想要割掉一条边u -> v，需要u属于S，v属于T ：

对于没有满流的边，说明还有u -> v的流量，如果这样分配u，v，流量会增大，与最大流最小割定理冲突，所以没满流的边不会在最小割中

对于一条满流的边，同样的，因为流量不能增大，所以在残余网络中不能有u - > v的流量，所以这条边可以在最小割中的的条件是u不能到达v


同样的，一条边可以不在最小割中的条件是  (u，v属于S)  或者  (u，v属于T)  或者  (v属于S，u属于T)，且不使流量增大，那么显然要求  (s到u，v没有流量)  或  (u，v到t没有流量)  或  (v到t没有流量，s到u没有流量)，因为一个点不会同时存在s能到它和它能到t，所以上述要求就是不能出现s到u有流量且v到t有流量。

对于没有满流的边，说明还有u -> v的流量，由于已是最大流的残余网络，所以不会出现s到u有流量，v到t有流量，所以没满流的边可以不在最小割中。

对于一条满流的边，条件为存在 u -> v 的路或者s到u没流量或v到t没流量

由上讨论可以得出**割边的判定条件**：

1.没有满流，则一定不在最小割中
2.如果满流，在残余网络中u不能到达v，可以为割边，否则不能为割边
3.如果满流且s能到u且v能到t，一定在割边中

**割边和SCC的关系**：

可以发现，满流的边v可以通过反边到u，所以u不能到v等价于SCC[u] != scc[v],而一定在最小割的条件为s能到u，v能到t，由于u到v满流，所以一定有u到s的反向路，同理t能到v，所以条件等价于SCC[u] == SCC[s], SCC[v] == SCC[t]



**2.点集分配**

s能到的点一定要在S中，不然会增加流量，同理能到t的点一定在T中。那么考虑剩下的点，可以发现，一个点能分配到S的条件是所由它能到达的点都应该被分配到S中，否则流量会增加，一个点能分到T的条件是所有能到它的点都应该分配到T中。     



由以上结论可得到以下构造算法：

**1.求最小割方案（任意）**

由s开始bfs，bfs到的点为属于S，剩下的点属于T，S和T之间的都是割边。

**2.最小边字典序最小割方案**

从编号小的边开始枚举，判断是否可以是割边，可以就选中，需要消除它的影响，可以将这条边正反边都删除，然后u到s退流1，t到v退流1。

**3.最小点字典序最小割方案**

如果字典序是定义在与点分配给S还是T有关，那么先根据点集分配所述的要求，确定固定的点，然后从小到大枚举点，如果还没确定，就优先确定它的集合，然后更新所有与它有限制关系的点的集合。

**4.最少割边的最小割方案**

做完一次最小割后，令所有满流边容量为1，非满流边容量为无穷。再做一次最小割，此时的任意最小割方案割边都最少。

**5.最少割边字典序最小最小割方案**

先做一次最小割，按照最少割边的方式处理后再做一次，再跑最小字典序的最小割方案。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            



1.http://www.lydsy.com/JudgeOnline/problem.php?id=4514

注：中档题，匹配模型；取每种权值为一个点，可匹配连无向边，则构成一个二分图

考虑函数$\omega(x)$表示$x$的质因子个数，对其奇偶性分成二部，同部无边

简单构图，求费用非负意义下，最大流；注意费用关于流的函数$C(f)$是凸函数，故可三分二分

事实上，直接在费用流增广过程中，运行到费用为负，停止即可

总结：重视流算法的内部基本原理及过程，适当应用

2.http://www.lydsy.com/JudgeOnline/problem.php?id=1433

注：基础题，二分图匹配；每个人是左部，每张床是右部，首先每个在校不回家的人连接自己的床，每个在校的不回家的人或者每个不在校的人连接在校且认识的人的床，看最大匹配是否等于没回家的人的总数

3.http://www.lydsy.com/JudgeOnline/problem.php?id=1934

注：基础题，经典的一分图模型(双权分划)；给定一个无向图，点带权$0$或$1$，修改若干个点权，之后边权为两点权异或，求$修改次数+边权和$最小。用$S$集合和$T$集合分别表示点权为$0$和$1$的，源汇边为修改与否的代价。

4.http://www.lydsy.com/JudgeOnline/problem.php?id=1854

注：不错的题目，给定$n$个二元组，每个二元组只可以选择一维使用，问能够组成的$1..x$的最大$x$值；二元组编号$i$连边$x \to i,y \to i$；对左侧点按顺序增广(匈牙利匹配)，一旦失配就可以停止。注意本题有并查集的巧妙做法，复杂度是$O(n+maxV)$。

5.https://hihocoder.com/problemset/problem/1252

注：难题，$2015icpc$北京$D$题，经典的$DAG$破坏最小割模型；题意稍更改为：给定$n$个点$m$条有向边的$DAG$，指定终结节点集合$A$，每个点有两个点权$a_i,b_i$，表示每次可以选择一个入度为$0$的点$i$删除支付代价$a_i$，或者无条件直接删除节点$i$支付代价$b_i$，或者支付$w_{xy}$删除一条边$x \to y$，求使得$A$集合中的点全部被删完所需的最小代价。为了精确的刻画节点被删除的模型，我们尝试将$x$节点在原图中被删除，与$S$不能走到$x$的性质相对应：

- 考虑第二种删除方式，直接删除点$x$，点割转化为边割，拆点为$x_{in},x_{out}$，连有向边，容量为$b_i$；本质上相当于直接删除这条内部边，而所有经过$x$的有向链都要经过这条内部边，故$S$与$x_{out}$不再联通
- 考虑删除一条有向边$x \to y$，连接$x_{out} \to y_{in}$，容量$w_{xy}$，割去此边可以断绝前驱$x$与$y$的联系却不能断绝其他前驱的联系，故对应是正确的
- 考虑如何刻画第一种方式，点$x$入度为$0$，等价于前驱都被删除，故$S$走不到任何前驱$t$的$t_{out}$节点，本来自然$S$就不会走到$x_{in},x_{out}$，为了使其满足我们等价的性质定义，$S$连接$x_{in}$，容量为$a_i$，表示在此条件下$S$仍然可以走到$x$，即$x$尚未被删除，欲使得其被删除，可以割去此条源边，支付$a_i$，这样$S$与$x_{out}$即不再联通；注意第一种不影响第二种的正确性
- 考虑源汇边，源边已经足够，所有$A$中的点连接汇点$T$，容量正无穷，$S$走不到$T$即走不到$T$的所有前驱的$out$节点，表示这些点已经全被删除
- 总结：用与源点连通与否表示一个点的存在情况，一个点不存在的三种可能都可以很好的对应

6.http://www.lydsy.com/JudgeOnline/problem.php?id=1927

注：基础题，$DAG$最小路径覆盖扩展或者不交路径覆盖模型；边带权的$DAG$需要找一条路经过所有点费用最小，刚开始在无穷远处，在任何时候任何位置穿越到点$i$需要$a_i$费用。经过所有点可以用无穷费用诱导。

7.http://www.lydsy.com/JudgeOnline/problem.php?id=2673

注：好题，$WF2011D$，经典的环形流模型(消圈)，给定一个$n*n(n\le 40)$的矩阵，每个元素$\in \{-1,0,1\}$，你需要将一些$0$替换成$1$，使得以下条件成立：令$S_i,T_i$分别表示第$i$行，第$i$列的$1$的个数，则$S_i=T_i \le \frac{A}{B}M$，$M$表示总的$1$的个数。最大化总$1$个数。

- 把矩阵看成是有向图的邻接矩阵，首先连成完全有向图，如果$a_{i,j}=-1$则去掉这条$i \to j$的边
- 所有边容量为$1$，$i \to j$的一个流，表示$a_{i,j}$设置为$1$，如果$a_{i,j}=1$，则是必选的边，将其费用设为$inf$诱导；其他的有向边，费用为$1$，则最大费用体现为最大化总的$1$的个数。
- 由于没有源汇，这是一个环形流网络，每个点由于流量守恒，正好对应着$S_i=T_i$；一个点表示编号相同的一行和一列。
- 枚举所有行的流量上界$m$，即每个点最多有$m$流通过，拆点设置点容量。$m \in [0,n]$依序枚举，可以复用之前的流网络结果，不必重新计算。$check:\frac{A}{B}M\ge m$，即真实限制比我们假设的要宽松才合法。

8.http://www.lydsy.com/JudgeOnline/problem.php?id=3876

注：基础题，给定$DAG$，边带权，每次可以从$1$号点任意游走，可重复走，每个点至少经过一次，求最小花费。

经典的有下界的有源汇最小费用流(注意不是最大流)；本质为$DAG$的可重覆盖，可以用无下界(下界为$0$)的普通费用流，用无穷费用诱导每个点都必须通过即可。

9.http://www.lydsy.com/JudgeOnline/problem.php?id=3698

注：中档题，有源汇上下界最大流，行列二分图模型

注意到每条边上下界都是相邻整数，且是$int$流，故最大流方案中每条边必取到上下界之一；

答案要求所有元素之和最大值，其实就是最大流的$3$倍

10.http://www.lydsy.com/JudgeOnline/problem.php?id=2502

注：基础题，$DAG$最小路径边覆盖(起点任意，边可重复)；经典题，有源汇上下界最小流，边必走，下界设置为$1$即可；也可以用无穷费用(这里$1$就可以)诱导的费用流模型，渐增流量，费用满了(即每个点都经过了)便停止

11.http://www.lydsy.com/JudgeOnline/problem.php?id=2055

注：基础题，$DAG$最小费用路径点覆盖(点严格经过$v_i$次)；经典题，点有上下界容量的费用流模型；即有源汇上下界最小费用可行流

12.http://poj.org/problem?id=2396

注：基础题，矩阵填数，每个元素和行列之和有上下界限制，构造一个方案；经典的行列二分图模型，有源汇上下界可行流

13.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3229

注：基础题，有源汇上下界最大流，二分图模型，按照题目给的限制填充上下界即可

14.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2314

注：模板题，无源汇上下界可行流

15.http://www.lydsy.com/JudgeOnline/problem.php?id=2406

注：不难的中档题，矩阵填数，行列二分图模型，构造方案；二分+有源汇上下界可行流

16.http://www.lydsy.com/JudgeOnline/problem.php?id=3280

注：难题，学生-医院模型，题目：

- 完成任务需要$n$天，每天需要$a_i$学生；每个学生只能使用一天，之后若再使用必须先去医院，出院可以再使用(不使用就可以不治)
- 有$cnt$个学校，第$i$个学校有$l_i$学生，招募一个需要$p_i$代价
- 有$k$个医院，第$i$个救治一个学生需要$d_i$天，需要$q_i$代价
- 问满足$n$天要求需要的最小代价

最小费用最大流模型：两个二分图组合，第一个二分图表达从学校招生，第二个表示一些学生延迟在某天送去医院，然后重返工作：

- 第$x$天拆点为$x',x''$，之间没有连边
- 源点$S$连接每个学校$j$，容量$l_j$，费用为$p_j$，一个单位流表示从该学校招募一个学生
- 每个学校$j$连接每一天$x''$，容量$inf$，费用$0$，表示将招募过来的学生分配到每一天使用(不花钱)
- 源点$S$连接每一天$x'$，容量$a_x$，费用$0$，表示第$x$天选择了流量个学生待操作
- $x'$连接$(x+1)'$，容量为$inf$，费用为$0$；表示有流量个学生从第$x$天待操作状态进入第$x+1$待操作状态
- 对于每一天$x$，和每一家医院$j$，如果$x+d_j+1 \le n$，则$x'$连接$(x+d_j+1)'$，容量为$inf$，费用为$q_j$；表示有流量个学生在第$x$天被送去医院$j$，待了$d_j$天后，在$x+d_j+1$天被重新利用了，每个花费$q_j$；注意不存在出了医院不被利用的情况，或者出院之后$n$天已经结束；一个学生如果出院之后，没有立即被用；那么根据贪心，可以想方设法延迟其送往医院，直到其出院立即工作
- 每天$x''$连接汇点$T$，容量为$a_x$，费用为$0$；表示有流量个学生被召集，准备这一天的工作
- 对模型跑最小费用最大流，要求汇边满流，否则无解

总结：一些比较复杂，量比较多的题目，可以分解成一些子任务，构造子网络

17.http://www.lydsy.com/JudgeOnline/problem.php?id=3112

注：难题，经典题，一类线性规划的对偶，松弛差分技术；化归成每个变量只有一正一负两次出现，等式约数；用最小费用最大流模型；参见$2016$国家集训队论文《线性规划及其对偶》

18.http://www.lydsy.com/JudgeOnline/problem.php?id=1917

注：难题，树形$dp$解决树上网络流问题

19.http://www.lydsy.com/JudgeOnline/problem.php?id=3218

或者：http://uoj.ac/problem/77

http://blog.csdn.net/outer_form/article/details/50847581

注：难题，一分图(双权分划)模型，经典的主席树优化建图，将$O(n^2)$转化为$O(nlogn)$的点和边；

题意：有$n(n \le 5000)$个格子放在一行，第$i$个格子是奇怪的当且仅当存在$j<i$满足$j$白$i$黑，且$a_j \in [l_i,r_i]$。

最大化以下公式，注意每个点有$6$个点权，$a_i \in [1,1e9]$：
$$
\begin{equation}
\sum_{\text{方格}i\text{为黑色}}{b_i} + \sum_{\text{方格}i\text{为白色}}{w_i} - \sum_{\text{方格}i\text{为奇怪的方格}}{p_i}
\end{equation}
$$

- 先考虑个简单的一分图模型：$<S,i,b_i>,<i,T,w_i>,<i,j,p_i>$，其中$j \in [1,i-1]$且$a_j \in [l_i,r_i]$，其中$S$集合表示黑色点集
- 这样建图每个$(i,j)$的奇怪关系，都会导致$p_i$可能被算了一次；事实上，$p_i$实际上是一种点割，全局只会被割一次；因此我们修改所有$<i,j,p_i>$边，从$i$点中拆出一个$i'$点，$<i,i',p_i>,<i',j,inf>$；其余边不变
- 考虑最小割割去源汇边之后的$S$到$T$的剩余一条通路$S \to i \to i' \to j \to T$，由于最小割未选择$S \to i,j \to T$，而$i' \to j$是无穷容量边，故只会割去$i \to i'$的容量$p_i$，且有多个$i' \to j_1,j_2,j_3...$，也只会割一次
- 考虑主席树优化建图，$i' \to j$，这里的$j$是在主席树(权值)上一个版本上的一段权值区间，连向$log$个节点即可；树上边方向向下，容量$inf$；求最小割即可，$ans=\sum_{i=1}^n{w_i+b_i}-flow$
- 注意点：主席树上新建一条链，除了链上的边，注意另一个儿子的连边；注意最好离散化时，加一维数据强行区分所有权值，因为相同权值后者可能会覆盖前者

20.http://www.lydsy.com/JudgeOnline/problem.php?id=1570

注：中档题，分层图模型；给定$n$个点$m$条边的有向图，每条边时间为$1$，$T$个人$0$时刻从$1$号点出发走到$n$，每条边每个时刻最多有$a_{i,j}$个人通过，求最晚时间每个人都到目的地；显然要独立考虑每一天的限制，故考虑分层图，每层为一天；同一层节点不连边，$S$向第$0$层的$1$连边，容量为无穷，若有向图$x\to y$，则当前层的$x$连向下一层$y$，容量为一天限制$a_{x,y}$；每层$n$连向$T$，容量无穷；二分天数，即层数，求最大流，考虑一个流的含义，对应一个人的时间行走路线，与人数比较$check$；也可以不二分，直接复用上次结果，在残量网络上追加边

21.http://www.lydsy.com/JudgeOnline/problem.php?id=3532

注：中档题，最短路割问题(点割)，最小割字典序最小方案；给定序列$a$，删除$a_i$需要代价$b_i$，另给$c_i$作为优先级；求使得$a$的$len(LIS)$严格减少的最小代价，并构造按优先级字典序最小的方案。对$i<j,a_i<a_j$的数对连边$ i \to j$，求出其最长路$DAG$，$S$连接每个点，每个点连接$T$，对其求最小点割；这等价于，对$dp[i]+1=dp[j]$的数对连边，$S$连接$i$满足$dp[i]=1$，$i$连接$T$满足$dp[i]=len(LIS)$。

求字典序最小的方案，首先所有点(边)，按照优先级排序；按照贪心逐个确定，一条边如果可选即选，选了之后，即删之，重新跑最大流，或者用退流技巧；如果不选跳过即可。

**退流技巧**：边$x\to y$退流，在$DAG$中，$x \to y$为$x$与$y$之间唯一流边(流为$f$)，因此，$run(x,S)$退流$f$，$run(T,y)$退流$f$。

22.http://www.lydsy.com/JudgeOnline/problem.php?id=3158

注：不错的题，简单数论分析+最小割，给定$a$序列，下标$i$有利益$b_i\ge 0$，求选出一个子集，使得利益和最大；满足任两个元素，符合下面条件之一：不存在$T$，$a_i^2+a_j^2=T^2$；$gcd(a_i,a_j)>1$。联想到独立集模型，连无向边$i \to j$，如果$i,j$同时不满足两个条件；注意到两个奇数之间无边(必定满足条件$1$)，两个偶数之间无边(必定满足条件$2$)，故此图是个二分图，求其最大带权点独立集。$S$连有向边到每个点，每个点连有向边到$T$，容量为$b_i$；二分图中间边化有向边，容量为$inf$。被最小割割去的，即是抛弃的元素。

23.

24.

25.http://www.lydsy.com/JudgeOnline/problem.php?id=1412

注：基础题，最小割，给定$n \times m$的矩阵，只含$0,1,2$，在线段处加些篱笆使得$1$，$2$不连通；$S$连向所有$1$，所有$2$连向$T$，容量$inf$，相邻边根据四连通连无向边。

26.http://www.lydsy.com/JudgeOnline/problem.php?id=3993

注：基础题，二分+最大流，有$n$个武器要消灭$m$个怪物，已知$map[i][j]$表示$i$武器是否可以攻击$j$怪物，$a_i$表示怪物血量，$p_i$表示武器每秒攻击力(注意时间是连续的，即可以使用非整数秒)，求最小时间消灭所有怪物；$S$连接所有武器，连接所有怪物，连接$T$；容量依次为：$t*p_i,inf,a_i$。二分时间$t$，用最大流$f=\sum_{i=1}^ma_i$check即可。

27.http://codeforces.com/gym/100548/attachments C题

注：模板题，最大密度子图；给定长度为$n$的序列$a$，求其子序列$s$使得$r(s)/len(s)$最大，$r(S)$为其逆序对数量；对逆序对下标建双向边，等价于求边数/点数的最大密度子图；做法可以二分+最大权闭合图，有复杂度更优的做法。

28.http://www.lydsy.com/JudgeOnline/problem.php?id=1070

注：好题，有$n$量车要修($0$时刻一起送来)，$m$位技术工人，$a[i][j]$表示$i$修$j$需要的时间，求平均等待时间(从送来到修好)最小值；每人一个时间只能修一辆车，等价于求最小总等待时间，最小费用最大流模型+动态加边。

- 考虑一个工人，假设有若干辆车按顺序修，则总时间为$t_1*1+t2*2+...t_k*k$，其中$t_i$表示倒数第$i$量车修的时间
- 考虑车和工人的对应是不够的，因为还与此量车是此工人倒数第几量修的(即顺序)有关。考虑车与元祖$(u,k)$的对应，$(u,k)$即$u$这个工人，修倒数第$k$量车的动作，这样是更精确且可算代价的。
- 建立二分图模型，左边是车，右边是动作元祖；$<t,(u,k),1,k*a[u][t]>$有向边表示$t$在$u$作为倒数$k$量车被修；$<S,t,1,0>,<(u,k),T,1,0>$，本质是二分图最小带权匹配；注意由于边权非负，在贪心意义下，不会出现非法的情况，比如某个工人倒数第$2$量车没修，却修了倒数第$3$量车
- 优化：由于点数太多，可能会超时；则当$<(u,k),T>$有流之后，再建$(u,k+1)$的所有入边，继续增广；由于这些边在之前不可能被增广，故是正确的

29.http://www.lydsy.com/JudgeOnline/problem.php?id=1458

注：基础题，士兵占领，行列二分图模型，下界最小可行流转最大流；矩阵有一些格子是障碍，选择一些格子，使每行每列达到所给界；可以转化为每行每列最多删除多少，即最大流中容量限制

30.http://www.lydsy.com/JudgeOnline/problem.php?id=4823

或者https://www.luogu.org/problem/P3756

注：难题，最小割；给定$R \times C$矩阵网格，和$n$个占据的格子坐标$(x_i,y_i)$以及删除其需要的代价$c_i$；格子中有一些线段是关键边，为使得图中不出现下列图形，问删除一些格子的最小代价和；

![3](\pic\网络流\3.png)

![4](pic\网络流\4.png)

对其进行二染色，然后在关键线段两侧的格子再进行二染色，亦即对原图染了$4$种颜色：

<img src="pic\网络流\1.png" alt="1" style="zoom:75%;" />

观察一下，不难发现，所给的形状都是$4$种颜色恰好均出现一次的形状；考虑如何破坏之，为此，画出一个局部的单位格子组：

![2](\pic\网络流\2.png)

- 注意到我们可以采用下列策略删除格子：
  - 删除红色和蓝色格子之一(显然删除代价较小的)
  - 不然，删除所有黄色的，或者删除所有绿色的格子
- 因此，采用如下的建图：
  - $<S,Yellow,c_i>$，$<Green,T,c_i>$
  - $<Yellow,Red,inf>$，$<Blue,Green,inf>$
  - $<Red,Blue,min(c_i,c_j)>$
- 想办法对格子编号，建图跑最小割

31.http://www.lydsy.com/JudgeOnline/problem.php?id=1822

注：中档题，二分+计算几何+最大流；大致题意：根据计算几何计算出每个巫师可以杀哪些精灵；

显然，巫师在左，精灵在右构造二分图；$S$连接巫师，容量表示此巫师的击杀数量上界；精灵连接$T$，容量为$1$，满流表明此精灵被击杀；中间边向右，容量为$1$，表示击杀关系

分析时间：考虑一个巫师击杀$k$个精灵花费时间$(k-1)t$，则若知道时间上界$t_0$，则即知道了每个巫师的击杀数量上界，二分时间，设置容量，看最大流时汇边是否都满流即可

思考：如果要求击杀所有精灵所需最小总时间，如何修改？

32.http://www.lydsy.com/JudgeOnline/problem.php?id=3681

注：难题，$dsu \space on \space tree/$线段树合并优化建图

33.http://www.lydsy.com/JudgeOnline/problem.php?id=1497

注：模板题，$NOI2006$最大获利，无向图自然依赖关系，最大权闭合图

34.http://www.lydsy.com/JudgeOnline/problem.php?id=1266

注：基础题，最短路割

35.

36.

37.http://www.lydsy.com/JudgeOnline/problem.php?id=1324

注：中档题，注意到相当于一个格子取了，周围$4$个格子都不能取；考虑黑白染色，$S$连向黑，黑连向白，白连向汇$T$，构造二分图；中间容量为$inf$，两边容量为价值；最小割表示抛弃的总价值

38.http://www.lydsy.com/JudgeOnline/problem.php?id=2095

注：先看下面一个更基础的问题：

基础题，定向问题，经典的无向图定向，使其存在欧拉回路，求最小代价(每条边两种代价)；根据有向图欧拉回路的存在条件，每个点入度等于出度，因此若原图中存在奇度点，无解；一个原图度为$d$的点，入度需要等于$d/2$，而无向边定向实质上增加了一个端点的入度；$S$连接每条边代表的点，容量为$1$，表示追加一个入度；每条边连接两个端点，容量为$1$，费用为两个方向的花费；每个端点连接汇点$T$，容量为度的一半，表示接受的入度上限；求最小费用最大流，最后汇边要满流

原问题：给定$n$个点$m$条双向边的图，每条边有两个边权表示两个方向；求一个最大边权最小的有向欧拉回路。

中档题，二分参数$t$，只保留不大于$t$的有向边，因此一些边相当于已经定向了；只需$check$在此图中，是否存在欧拉回路即可，典型的混合图欧拉回路问题。先对此图中所有无向边任意定向，求出每个点的出入度，令$h(x)=r(x)-c(x)$，若图不连通特判无解，若存在点$x$使得$h(x)$为奇数亦无解；考虑构造一个新的有向图$G$，将原来的无向边所定的方向反向，其余的边去掉。对$h(x)>0$，源点$S$连接$x$，容量为$h(x)/2$；对$h(x)<0$，$x$连接汇点$T$，容量为$|h(x)|/2$；考虑一个流的含义，表示选择一条链路取反，使得起点的$h-=2$，终点$h+=2$。源汇边要求满流。

注意对比，两种定向模型。

39.http://acm.hdu.edu.cn/showproblem.php?pid=4807

注：中档题，给定有向图，边权表示同一秒最多通过的人数，有$k$个人从$0$到$n-1$，求最少时间让所有人到达；二分时间$T$，将路径长度看成费用，按照费用流增广，每次通过人数$+=(T-L)*f$，$L$为路径长度。比较通过人数与$k$，调整二分参数。

40.https://vjudge.net/contest/189689#problem/I

或者https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=5552

注：基础题，上下界费用流，带下界的最大费用可行流；$n$个程序员开发$m$个应用，给定程序员开发应用的获利表，给出一些程序员和应用是必选的，求最大获利；构造基本的二分图即可，设立下界；或者对必选的边，设立负无穷费用，诱导流的决策。

41.https://loj.ac/problem/6005

注：基础题，网络流$24$题之$LIS$，问每个点只能取一次意义下，可以取出多少个$len(LIS)$的$LIS$子序列

在$dp$数组基础上建图，前面的例子已经讲过，跑最大流即可；若首尾项可选多次，修改容量即可

42.https://www.luogu.org/problem/P3358

注：中档题，网络流$24$题之最长$k$可重区间集问题，给定开区间集合，选择一个子集，使得对于任意一个点，其最多被覆盖$k$次，最大化区间长度之和；注意到问题可转化为寻找$k$条不交的链，链由不交的区间构成，且链之间无相同区间(集合中同一元素)；每个区间看成点，向右边连接与之不交的区间；拆点控制区间不重复取，拆源点控制流上限为$k$

43.https://www.luogu.org/problem/P4016

注：基础题，网络流$24$题之负载平衡问题，环形货物运输，每次可以将一个点的一个货物运送到相邻点，求最小运输量；先求平均值，然后源点连接有剩余的点，残缺的点连接汇点；一个流表示一点货物运输，非源汇边费用为$1$，总费用为总运输量

44.https://www.luogu.org/problem/P2764

注：基础题，网络流$24$题之最小路径覆盖

45.http://www.lydsy.com/JudgeOnline/problem.php?id=3308

注：难题，$n\le 2\times 10^5$，在$1..n$中选择若干个数要求两两互质，求最大之和；考虑选取所有质数的最大幂次，在此方案上调整；一个结论，最优解的方案，每个数最多包含两个质因子，且一个大于$\sqrt{n}$，一个小于$\sqrt{n}$；将这两部分的质数，作为二分图的两部分，若一对质数$p,q$联系在一起比分开更加优，则连边且增加的贡献为费用，容量为$1$；源汇边容量为$1$，费用为$0$；跑最大费用流。注意建图时，若$p>n/2$，则$p$不需要连边。

46.http://www.lydsy.com/JudgeOnline/problem.php?id=3996

注：中档题，线性代数+最小割，公式化为：$\sum_{i=1}^n \sum_{j=1}^n B_{ij} \times A_i \times A_j – \sum_{i=1}^n A_i \times C_i$，这是最大权闭合图的最优化目标函数，使用自然依赖，将$i$看成点，$A_i$表示$i$选不选，$B_{i,j}$表示边权邻接矩阵，$C_i$表示点权；选取此无向图的一个边导出子图，边权为利润，点权为花费，二者均非负。

47.http://www.lydsy.com/JudgeOnline/problem.php?id=3272

注：难题，线段树模拟费用流

48.http://www.lydsy.com/JudgeOnline/problem.php?id=3931

注：基础题，最短路径图上求最大流

49.

50.http://www.lydsy.com/JudgeOnline/problem.php?id=3894

注：难题，双权分划模型扩展；给定$n\times m$的网格，对每个格子黑白染色，每个格子染成白色获得$w_{i,j}$，黑色获得$b_{i,j}$，若其为白色且相邻均为白色，则额外获得$ww_{i,j}$；其为黑色，且相邻均为黑色，则额外获得$bb_{i,j}$，求最大和；

$S$集合表示白色，$T$集合表示黑色，割去的边表示抛弃，最终答案等于总和减去最小割；

$S$连接每个点，每个点连接$T$，分别以$w,h$为容量；这是模型框架，考虑一个方案，一些点被染成黑色；考虑一个相邻的五格子集合，若全部是白色则获得$ww$；即有一个为黑，则损失$ww$；则为每个五元祖，新建一个点$x$，$S$连接$x$，容量为$ww$，$x$连接这$5$个格子代表的每个点，容量$inf$；对称的连接五格子集合全为黑色的贡献。注意，这三个网络柔和在一起时，对同一个五元组，$ww$和$bb$是不可能同时取到的，故模型是兼容的。

总结：注意最小割模型中，如何表示一组对象染同种颜色的贡献。

51.http://www.lydsy.com/JudgeOnline/problem.php?id=1283

注：中档题，区间频率限制，通路流模型，线性规划；给定一个序列，选择一个子序列使得权值之和最大，且长度为$m$的区间，选择的数的频数不超过$k$；线性规划基础题，直接转化为对偶线性规划，建立费用流模型；

或者：转化为$k$个通路流，每个流，选择的相邻两个元素下标之差不小于$k$；$<S,1,k,0>,<n,T,k,0>,<i,i+1,inf/k,0>,<i,i+k,1,a_i>$

52.http://www.lydsy.com/JudgeOnline/problem.php?id=3144

注：中档题，经典题，最小割，通路流之间的影响与限制；给定$n \times m $矩阵，要求填数$(x,y)$填$z$得到$f(x,y,z)$；要求相邻的数相差不超过$d$，最大化$f$之和；为每个格子，拆$|Z|$点，构造通路流结构；$(x,y,z)$连接相邻的$(x',y',z-d)$，求最小割

53.http://www.lydsy.com/JudgeOnline/problem.php?id=2756

注：中档题，矩阵填数类问题，给定矩阵$A$，已知各元素，每次可以将相邻两个元素$+1$，使得所有元素相等，求最小次数；假设所有元素均为$x$，则构图如下$check$：$<S,u,x-a[u]>,<v,T,x-a[v]>,<u,v,inf>$，$u$为黑色，$v$为白色且与$u$相连。考虑有$num1$黑色格子，$num2$白色格子，注意到一次操作，黑色格子数值之和与白色的差是不变的，故$num1*x-num2*x=sum1-sum2$；故当$num1=num2$时，即棋盘可被多米诺骨牌覆盖，$x$有单调性，显然可以二分；否则，$x$值确定，直接解出来$check$即可

54.http://www.lydsy.com/JudgeOnline/problem.php?id=2400

注：中档题，异或割模型；给定$n(n\le 500)$个点的无向图，部分点给定点权(非负)，其余点需要自己赋值，边权为点权异或和；使得所有边权之和最小，在此意义下，使得点权之和最小；考虑二进制拆位，独立考虑每一位，故点权均为$01$变量；将边权赋值$1$，$S$连向取值为$0$的点，取值为$1$的点连向$T$，容量为$inf$；求最小割，和使得$S$集合点数最少的最小割；后者，直接取$S$能走到的点即可。或者用进制压位的思想，将边权赋值为$M$，$S$点连接每个点，容量为$1$；求最小割$ans$，然后用进制$ans/M,ans\%M$拆分即可。

55.http://acm.hdu.edu.cn/showproblem.php?pid=5520

注：中档题，最小路径覆盖模型；给定$n \times m$的矩形网格$(n,m \in [1,50])$，每个格子有个正整数值或者为空，从每个格子向上下左右四连通的相邻格子的边权给定；要求选择一些路径覆盖所有格子，且路径不交，使得路径边权之和最小；路径边权计算方法：第一类路径，选择一个奇数权格子作为起点，偶数权格子作为终点(中间不能经过其他数字)，途径边权之和；第二类路径，选择一个回路且每个格子要求为空，路径边权定义为边权之和的两倍(也可以选择任两个相邻的空格子，路径权值也是那条边的边权两倍)。特判奇数格子数量是否等于偶数格子数量，不等无解；首先，回路路径总是可以拆分为若干相邻空格子二元组的，代价不变；这是因为回路长度总是偶数的。每个格子拆点$in,out$两点，之间不连边；源点$S$连接每个奇数点$in$和空白格子$in$；每个偶数点$out$和空白格子$out$连接汇点$T$；每个格子$in$连接四连通周围四个格子$out$，费用为边权，容量为$1$；求最小费用最大流，检查源边是否满流。注意此模型在奇数格子数量等于偶数格子数量时，不会出现一条路径从奇数出发，终止于空白格子，因为总是存在另一条路径从空白格子出发，终止于偶数格子，二者可合并，使得最大流增大(否则存在$S$连向空白格子的$in$的边没有满流，即存在空白格子没有走出去)。

56.http://www.lydsy.com/JudgeOnline/problem.php?id=2718

注：基础题，经典题，$DAG$上最长反链，$Dilworth$定理，转最小路径点覆盖

57.http://www.lydsy.com/JudgeOnline/problem.php?id=2895

注：中档题，题意较复杂，费用流平方费用拆边表示；先假设所有比赛所有队伍都失败，然后调整，一场比赛状态改变为某个队伍胜利，另一个队伍花费是不会变的，胜利的队伍胜利场次$x+=1$，失败场次$y-=1$；容易计算，在此情况下多得到的花费：$c_i*(x+1)^2+d_i*(y-1)^2-c_i*x^2-d_i*y^2$。建图参考无向图定向的自然依赖模型；$S$连接每场比赛，容量为$1$；每场比赛，连接两个队伍，容量分别为$1$；每个队伍连接$T$，拆边，费用依次为上面的公式；先取出$x,y$初值，每连接一条边，定好费用之后，$x++,y--$维护一下。一个流的含义是，修改一个比赛的状态，定一个队伍为获胜方。

58.http://www.lydsy.com/JudgeOnline/problem.php?id=1565

题面建议：https://wenku.baidu.com/view/d0b12618650e52ea551898fd.html

注：中档题，$NOI2009$植物大战僵尸，拓扑排序+最大权闭合图，题意较复杂，首先把保护关系连成有向图，注意右侧的植物对左侧相邻的植物也有保护作用，其次拓扑排序取出不经过环的元素，构造新图；求最大权闭合图。

59.http://www.lydsy.com/JudgeOnline/problem.php?id=2007

注：基础题，$NOI2010$海拔，显然点只能标$0,1$；转化为带双向边的平面图最小割问题，转对偶图最短路，注意对偶图边方向相当于原图边方向旋转$90$度，$S,T$位置决定其是顺时针还是逆时针。

60.http://www.lydsy.com/JudgeOnline/problem.php?id=2893

注：基础题，强连通缩点+费用流/上下界费用流，给定有向图，问限制起点和终点的，点可重最小路径点覆盖；基础的费用流诱导，不断增广直到达到最大费用，取最小流；或者使用带下界的最小流。

61.http://www.lydsy.com/JudgeOnline/problem.php?id=2929

注：模板题，最大流裸题

62.http://www.lydsy.com/JudgeOnline/problem.php?id=1520

注：基础题，二分图完美匹配模型，最小费用最大流；满流则有解

63.http://www.lydsy.com/JudgeOnline/problem.php?id=2324

注：中档题，$floyed$+最小路径覆盖模型；等价于一种序列切割模型，预处理$dist[x][y]$表示$x$在只经过$\le y$的点编号的意义下到$y$的最短路，作为有向图的边权；此图点编号$0..n$，需要选择不超过$k$条从$0$出发的路径，覆盖所有点，且每个点(除$0$之外)都只经过一次；有三种建模方法：

- 一个流表示一条链，采用负无穷费用诱导每个点至少经过一次
- 一个流表示一条链，每个点设置一个下界表示必须经过一次
- 最小路径覆盖模型，每个点拆点，$S$连接出点，入点连接$T$，$<S,0,k,0>$，每个点出点连接可以走到的点的入点，费用为边权；考虑此图的最大流的含义，表示一棵树，结构上对应从$0$出发的不超过$k$条的链，故最大流恰好为$n$；因此每种最大流方案与链的划分方案对应，求最小费用最大流即可

64.http://www.lydsy.com/JudgeOnline/problem.php?id=3396

65.http://www.lydsy.com/JudgeOnline/problem.php?id=3504

66.http://www.lydsy.com/JudgeOnline/problem.php?id=1532

67.http://www.lydsy.com/JudgeOnline/problem.php?id=1930

68.http://www.lydsy.com/JudgeOnline/problem.php?id=2661

69.http://www.lydsy.com/JudgeOnline/problem.php?id=1061

70.http://www.lydsy.com/JudgeOnline/problem.php?id=1711

71.http://www.lydsy.com/JudgeOnline/problem.php?id=2879

72.http://www.lydsy.com/JudgeOnline/problem.php?id=3275

73.http://www.lydsy.com/JudgeOnline/problem.php?id=2768

74.http://www.lydsy.com/JudgeOnline/problem.php?id=2245

75.http://www.lydsy.com/JudgeOnline/problem.php?id=1391

76.http://www.lydsy.com/JudgeOnline/problem.php?id=2127

77.http://www.lydsy.com/JudgeOnline/problem.php?id=2132

78.http://www.lydsy.com/JudgeOnline/problem.php?id=3171

79.http://www.lydsy.com/JudgeOnline/problem.php?id=2424

80.http://www.lydsy.com/JudgeOnline/problem.php?id=1221

81.http://www.lydsy.com/JudgeOnline/problem.php?id=1305

82.http://www.lydsy.com/JudgeOnline/problem.php?id=1066

83.http://poj.org/problem?id=1637

84.http://hihocoder.com/problemset/problem/1393

85.http://hihocoder.com/problemset/problem/1394

86.http://hihocoder.com/problemset/problem/1398

87.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1325

88.http://acm.split.hdu.edu.cn/showproblem.php?pid=3879

89.http://acm.split.hdu.edu.cn/showproblem.php?pid=3871

90.https://nanti.jisuanke.com/t/15549

91.http://acm.split.hdu.edu.cn/showproblem.php?pid=5772

92.http://acm.split.hdu.edu.cn/showproblem.php?pid=4888

93.http://acm.split.hdu.edu.cn/showproblem.php?pid=6214

94.http://acm.split.hdu.edu.cn/showproblem.php?pid=1569

95.http://www.lydsy.com/JudgeOnline/problem.php?id=4873

96.http://www.lydsy.com/JudgeOnline/problem.php?id=3232

97.http://www.lydsy.com/JudgeOnline/problem.php?id=5037

98.http://www.lydsy.com/JudgeOnline/problem.php?id=3438

99.http://www.lydsy.com/JudgeOnline/problem.php?id=3041

100.http://poj.org/problem?id=2125

101.http://acm.split.hdu.edu.cn/showproblem.php?pid=1530

102.http://acm.split.hdu.edu.cn/showproblem.php?pid=3585

103.http://acm.split.hdu.edu.cn/showproblem.php?pid=5277

104.http://acm.split.hdu.edu.cn/showproblem.php?pid=5458

105.http://acm.split.hdu.edu.cn/showproblem.php?pid=5556

106.http://poj.org/problem?id=2400

107.http://poj.org/problem?id=3281

108.http://poj.org/problem?id=3469

109.http://poj.org/problem?id=2195

110.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2071

111.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2760

112.https://cn.vjudge.net/problem/SGU-242

113.http://poj.org/problem?id=1149

114.http://poj.org/problem?id=3498

115.http://poj.org/problem?id=2391

116.http://poj.org/problem?id=2112

117.http://poj.org/problem?id=2455

118.http://poj.org/problem?id=1698

119.http://poj.org/problem?id=1459

120.http://poj.org/problem?id=1087

121.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3976

122.https://cn.vjudge.net/problem/SGU-438

123.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2071

124.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2532

125.http://poj.org/problem?id=1815

126.http://poj.org/problem?id=3204

127.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2587

128.http://poj.org/problem?id=1966

129.http://www.spoj.com/problems/OPTM/

130.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2676

131.http://poj.org/problem?id=3155

132.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3241

133.http://acm.hdu.edu.cn/showproblem.php?pid=3157

134.https://cn.vjudge.net/problem/SGU-176

135.http://poj.org/problem?id=2175

136.http://poj.org/problem?id=3422

137.http://poj.org/problem?id=2516

138.http://poj.org/problem?id=2699

139.http://poj.org/problem?id=3084

140.http://poj.org/problem?id=3189

141.http://poj.org/problem?id=3308

142.http://codeforces.com/problemset/problem/884/F

143.http://codeforces.com/problemset/problem/877/F

144.http://codeforces.com/problemset/problem/818/G

145.http://codeforces.com/gym/101564   （D题）

146.http://codeforces.com/gym/101981/attachments I题

147.http://acm.hdu.edu.cn/showproblem.php?pid=6598

注：对每个士兵建立一个点 $x$ ，点 $x$ 向源点 $s$ 连一条边，向汇点 $t$ 连一条边，分别表示选择两种职业，然后就可以先加上所有的贡献，通过两点关系用最小割建模。

设一条边的三种贡献为 $A，B，C$，可以得到以下方程：

$a + b = A + B $（$x， y$ 都选 Mage）

$c + d = C + B $（$x， y$ 都选 Warrior）

$a + d + e = A + C $（$x$ 选 Mage， $y$ 选 Warrior ）

$b + c + e = A + C $（$x$ 选 Warrior， $y$ 选 Mage ）

可得一组解 $ a = b =（A + B）/ 2， c = d = (C + B) / 2, e = -B + (A + C) / 2$ ，然后将所有有关系的两点的图合并，用所有贡献减掉这个图的最小割即可。

148.https://ac.nowcoder.com/acm/contest/163/I?&headNav=www

149.http://uoj.ac/contest/32/problem/217

150.http://uoj.ac/problem/455

151.https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=6541&tdsourcetag=s_pctim_aiomsg

152.https://codeforces.com/contest/1252/problem/L

注：基础题，最大流；给定一棵$n$个点的基环树(边无向)，边上带一个集合作为点权；有$k$个工人，每个有个点权，当此人点权出现在某条边上的集合中时，此人可以被分配在这条边上；人和边不一定都要用完，但是不能重复使用；修好的路要求使得所有点联通，构造方案。三分图模型，左边是路，中间是颜色，右边是工人，这样还可以稍加简化减少边数；为了使得图联通，基环树上的树边必全取，环边允许有一条不取，故将路分为两类，每类引一个源点设容量控制上界(防止环边全取)，判断最大流是否为$n-1$。

153.http://acm.hdu.edu.cn/showproblem.php?pid=5535

注：给一个二分图，已经给定一些点颜色，要给剩下点黑白染色，使得两端颜色不同的边数量最多，且要构造字典序最小方案。

- 所有边两边颜色不同，加入答案，减掉最小割，最小割建图：定义$S$和$T$集合，分到$S$集合点表示二分图左部的黑点和右部的白点，$T$集合点表示左部白点和右部黑点。对原图的一条边$<u,v>$,建立从$u$到$v$容量为$1$的边,从$v$到$u$容量为$1$的边.从源点向左部黑点以及右部白点连容量为$+\infin$的边,从左部白点以及右部黑点向汇点连容量为$+\infin$的边.
- 可以发现这样一个割集表示的是割的那些边两端颜色相同，这和方案是一一对应的，因为原图二分图的性质，可以发现一条流从左黑右黑结束时，长度一定是奇数，中间一定有一条边冲突，从左黑左白结束时，长度一定是偶数，中间也一定有边冲突，右白出发同理。
- 所以只剩下求字典序最小方案，由于字典序定义在点上，所以使用最小点字典序最小割方案求法即可。

- 另一个想法来自于颜色的翻转：由于目标函数是使得异色边最大化，这与最小割的优化方向不一致，考虑一个最优的染色方案，将该方案二分图右侧所有点颜色黑白翻转，那么异色边最大，转化为同色边最大，而总边数$m$是固定的，剩余的边即异色边数量最小化，这与最小割优化方向一致；故将二分图右侧点颜色翻转之后，使用一分图模型，源点$S$向所有黑色点连有向边，容量为$+\infin$，所有白色点向汇点$T$连有向边容量为$+\infin$，其余边为双向边，容量为$1$；容易发现这与之前的模型是完全一样的。





【网络流复习·强化】


1.http://codeforces.com/problemset/problem/808/F

2.http://codeforces.com/problemset/problem/818/G

3.http://codeforces.com/problemset/problem/813/D

4.http://codeforces.com/problemset/problem/802/O

5.http://codeforces.com/problemset/problem/793/G

6.http://codeforces.com/problemset/problem/786/E

7.http://codeforces.com/problemset/problem/736/E

8.http://codeforces.com/problemset/problem/739/E

9.http://codeforces.com/problemset/problem/730/I

10.http://codeforces.com/problemset/problem/727/D

11.http://codeforces.com/problemset/problem/724/E

12.http://codeforces.com/problemset/problem/723/E

13.http://codeforces.com/problemset/problem/717/G

14.http://codeforces.com/problemset/problem/708/D

15.http://codeforces.com/problemset/problem/704/D

16.http://codeforces.com/problemset/problem/720/B

17.http://codeforces.com/problemset/problem/653/D

18.http://codeforces.com/problemset/problem/628/F

19.http://codeforces.com/problemset/problem/611/H

20.http://codeforces.com/problemset/problem/589/F

21.http://codeforces.com/problemset/problem/546/E

22.http://codeforces.com/problemset/problem/498/C

23.http://codeforces.com/problemset/problem/491/C

24.http://codeforces.com/problemset/problem/78/E

25.http://codeforces.com/problemset/problem/863/F

26.http://uoj.ac/problem/132

27.http://uoj.ac/problem/85







# 4.字符串

##【1】KMP与扩展KMP

题目列表：

1.http://acm.hdu.edu.cn/showproblem.php?pid=4333

注：字符串循环同构问题

- 字符串$s=p+q$，且$p,q$均为公共前后缀，设$|p|<|q|$，则$p$为$q$的公共前后缀
- $s$具有正整周期$T=gcd(|p|,|q|)$，$T|\space|s|$
- $s$是循环自同构的，则其循环周期$T'$是$T$的倍数，$T$亦为其最小正循环周期，则$T|gcd(T',n)$
- 若字符串$s$是循环自同构的，则令其最长公共前后缀为$t$，则$s-t$亦为其公共前后缀
- 令周期数$num=|s|/T$，在$n$个循环字符串中，每种字符串出现次数是$num$倍数
- 两个串的循环同构问题：若串$s$和$t$是循环同构的，则令$p$为$s$和$t$的最长公共前后缀($s$取前缀)，令$q$为$t$和$s$的最长公共前后缀($t$取前缀)，则$p,s-p$和$q,s-q$至少一组为可行的前后缀拆分，亦即只需要判断两次即可判定两个字符串是否循环同构，其最小移位次数就是相应的$|s-p|$
- 复杂题目可借助于字符串$hash$

2.http://codeforces.com/contest/535/problem/D

注：给模式串$t$和$|s|$，及其在串$s$中的出现下标，求$s$的方案数；只要可以识别冲突即可

扫描线，$check$本质是检查公共前后缀，单串用$kmp/exkmp$，多串用后缀数组或者字符串$hash$

3.http://codeforces.com/contest/631/problem/D

注：给压缩形式的两个串$s,t$，问$t$在$s$中出现次数，简单讨论

4.http://www.lydsy.com/JudgeOnline/problem.php?id=3620

注：询问字符串$s$中有多少子串$[L,R]$，满足$s[L..R]$符合结构$A+B+A,|A|\ge k,|B|>0$

- 公共前后缀包含单调性($Border$包含单调性)：若字符串$s$的某个公共前后缀$t$满足某种性质或者存在某种解，则$s$本身也必定符合这种性质或者存在某种解
- 对每个后缀，单独考虑，每轮$kmp$ $O(n)$，令$f[i]$表示$s[0..i-1]$中公共前后缀长度$\ge k$的最小值，可以轻松的由$f[nxt[i]]$转移过来；$check$ $s[0..i-1]$中$f[i]$指示的公共前后缀是否接壤即可

5.http://poj.org/problem?id=2406

注：求字符串$s$的最小正整周期，即无非整周期残余，令$T$为所求周期，$n=|s|$

- 结论：若$n-nxt[n]|n$，$T=n-nxt[n]$；否则，$T=n$
- 若$s$可分为$n/T$段，且$T$最小($T<n$)，则$nxt[n]=n-T$；首先显然，$nxt[n]\ge n-T$，而如果取大于，由反证法知存在更小的最小正整周期，矛盾；因为$T|n$，故$n-nxt[n]|n$为必要条件，而观察知其亦为充分条件

6.http://poj.org/problem?id=3461

注：模板题

7.http://poj.org/problem?id=2752

注：求给定字符串所有公共前后缀长度，模板题

8.http://poj.org/problem?id=1961

注：求给定字符串每个前缀的最小正整周期，同$poj2406$

9.http://poj.org/problem?id=2185

注：给定二维字符矩阵，求面积最小的二维矩阵，可以周期性的覆盖之，注意边界可能残余(列数较少)

- 使用$kmp$求给定字符串$s$的最小带余正周期，只需要沿着$nxt[n]$遍历，视每个遍历到的长度为余部，去掉余部转化为前缀求整周期$T$，注意验证$T$不能小于余部长度；注意遍历时得到的合法周期可能不单调
- 本题每行做$kmp$得到该行所有可能的带余周期，求所有行交的最小值设为宽度
- 取每行的一个宽度为一个元素(可以$hash$)，最终有行数个元素再次做$kmp$获取最小带余正周期，即为所求的高

10.http://poj.org/problem?id=3080

注：求$10$个长度为$60$的字符串的最长公共子串，同条件求字典序最小，暴力$kmp$

11.http://acm.hdu.edu.cn/showproblem.php?pid=4763

注：给定字符串$s$，寻找一个长度最大的子串$E$，使得$s=EAEBE,|A| \ge 0,|B| \ge 0$，$2013$网络赛

只需要$kmp+exkmp$，沿着$nxt[n]$遍历$s$的所有公共前后缀长度，从大到小，此时中间$E$的起点是个连续区间，且在不断扩张，双指针维护$exkmp$求的$ext[]$数组在该区间的最大值即可

12.http://acm.hdu.edu.cn/showproblem.php?pid=3613

注：遍历字符串的回文后缀，可以将$s$与其反串拼接，沿着$nxt[n]$遍历即可

13.http://acm.hdu.edu.cn/showproblem.php?pid=4300

注：将原串看成模式串，转录串(加密之后的)看成主串，做$exkmp$

14.http://codeforces.com/problemset/problem/808/G

注：给定模式串$t$，带$*$主串$s$，求$t$在$s$中出现最多次数；设一维状态，转移讨论上一次放在哪里，不重叠部分处理前缀$max$，重叠部分沿着$nxt$指针走

15.http://acm.hdu.edu.cn/showproblem.php?pid=5782

注：两个串的循环同构问题，对每对等长前缀，回答是否循环同构，参见题目$1$

16.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001423 g

**S = A + k * T + B**

如果进行分治，那么 **k * T** 一定跨过某个分治中心。

对于每个分治中心，枚举 **|T|** ，计算 **k** 。

17.http://acm.hdu.edu.cn/showproblem.php?pid=5510

注：基础题，给定$n$个字符串，寻找最大下标$i$，满足存在$j<i$，$s_j$不是$s_i$子串；暴力枚举$i$，枚举$j$时，一旦发现$j$是$i$子串，即删除$j$(因为$i$对检查$j$后面的串没有贡献，如果$i$不是子串，那么$j$一定不是子串)；一旦发现$j$不是$i$子串，即$break$，$i++$；复杂度分析采用队列或者双指针方法，每次$check(j,i)$严格$O(2len)$，成功则有一个元素出队，失败则有一个元素进队，故总次数$O(n)$。







##【2】RK算法与字符串hash

学习资料：

$hash$冲突概率简单分析与例题

http://rng-58.blogspot.com/2017/02/hashing-and-probability-of-collision.html?m=1&tdsourcetag=s_pctim_aiomsg

http://codeforces.com/blog/entry/4898

一个定理

https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma



1.http://codeforces.com/contest/608/problem/E

注：思维题，转化为判定一个字符串是否存在一个前缀和另一个的翻转的相反串的后缀相同

2.http://acm.hdu.edu.cn/showproblem.php?pid=3973

注：线段树，单点修改，区间查询$hash$值

3.http://acm.hdu.edu.cn/showproblem.php?pid=6046

注：给定一个随机化算法，生成了一个确定的$10^6*10^6$的$01$矩阵，给定一个$10^3*10^3$矩阵，问小矩阵在大矩阵中出现的最早位置，或者指出没有出现

考虑此问题的一维版本，考虑插桩法，在长度为$10^6$的串中每隔$10^3$设立一个桩，这时候任取其长度为$10^3$的一个子串，必然包含一个桩；如果我们将每个桩为起点向左向右两个方向，处理两个长度为$L$的$hash$值，那么上述$10^3$子串必然至少覆盖一个长度为$L$的被处理的段，于是将给定串的所有长度为$L$的子串也处理出$hash$与坐标放入$map$中，枚举大串中每个被处理的段，判断其是否在$map$中提取坐标即可

这是经典的模糊匹配算法，当数据很大时，无法精确比较，那么就只能采用随机化思想的概率算法；大矩阵如果想要覆盖小矩阵，那么就必然要覆盖其至少一个子部分，如果这个子部分的覆盖概率在随机数据下是比较低的，我们就认为大矩阵一旦覆盖了一个子部分，那么就覆盖了小矩阵

4.http://acm.hdu.edu.cn/showproblem.php?pid=4821

注：字符串$hash$+双指针，将下标分类，每类存在单调性

5.http://acm.hdu.edu.cn/showproblem.php?pid=5414

注：思维题，给定两个字符串$s$和$t$，问$s$是否可以通过若干次操作得到$t$，每次选择一个字符，在后面添加一个不等于该字符的新字符；显然，要寻找$s$可以得到$t$的充要条件：将两个字符串看成等值的段状字符串，首先第一段要完全相同，因为$s$没有能力扩展或者压缩修改第一段；其次$s$只要在$t$中以子序列形式出现即可，可以逐字符证明，当前字符出现在$t$某处，则该下标之前的字符序列，都是可以插入的

6.http://acm.hdu.edu.cn/showproblem.php?pid=4622

注：平方算法求区间本质不同子串个数，后缀自动机或者后缀数组基本功能，另可字符串$hash$+$dp$

令$f[l][r]$表示答案，则有$f[l][r]=f[l][r-1]+1+f[l+1][r]-f[l+1][r-1]-g[l][r]$

其中$g[l][r]$表示$s[l..r]$的单纯$Border$个数，即有多少个严格的公共前后缀(长度严格小于$r-l+1$)且未在中间出现(一共只出现两次)；这是一种常见的本质不同字符串有关的字符串$hash$方法，枚举长度$L$，枚举每个长度为$L$的子串$t=s[l..r]$，利用$unordered\_map$或者$hash$表获取其上一次出现的最近左端点坐标$l'$，$g[l'][r]++$；还可以利用$kmp$算法，对一个固定的左端点$l$单独做一次$kmp$，考虑后缀$s[l'..n]$，若此后缀的一个真前缀在该后缀有另一次出现，则显然必存在一个下标$j>l'$，使得$nxt[j]=len(真前缀)$，每个$nxt$第一次出现的长度，即确定一个单纯$Border$，将其贡献叠加到$g$数组

该方法稍微改下，可以求长度之和类似的稍变化的问题

7.http://acdream.info/problem?pid=1019

注：单点修改，区间询问是否为回文子串，树状数组或者线段树维护$hash$值

8.http://codeforces.com/problemset/problem/580/E

注：线段树维护$hash$值，区间覆盖，区间询问给定$c$是否是一个带余周期；根据定义，询问只需一次判等；

注意双$hash$，$memset$以及$memcpy/memcmp$对$char$数组速度很快

9.http://codeforces.com/problemset/problem/835/D

注：平方$dp$+字符串$hash$，问给定串$s$中每种回文度的回文子串数量，不要求本质不同

10.http://codeforces.com/problemset/problem/7/D

注：求给定串$s$所有前缀的回文度之和，$O(n)$$dp$，字符串$hash$

11.http://codeforces.com/problemset/problem/25/E

注：给定三个字符串，求一个字符串包含他们，求最小长度；暴力枚举+字符串$hash/kmp$

12.http://codeforces.com/problemset/problem/119/D

注：枚举+双指针+字符串$hash$

13.http://codeforces.com/problemset/problem/958/A2

注：二维hash，每个方向一个base，公共模数，注意高低位统一

14.http://codeforces.com/group/aUVPeyEnI2/contest/243686 C题

注：对每个本质不同子串，抠出所有出现下标集合，利用字符串hash判等

15.https://ac.nowcoder.com/acm/contest/890/C

注：字符串$s$，初始为空；修改操作：在最前面或者最后面添加一个字符；查询每个时刻，带余周期种数

一个观察：注意到一个周期$T$，从$|s|=T$这个时刻开始出现，将持续一段时间之后消亡(存亡单调性)

考虑对$\forall T\in[1,|S|]$，二分其存在的最后时刻，用字符串$hash$ $check$某时刻字符串是否有周期$T$，$O(1)$

统计周期数目，本质上相当于区间加$1$，差分之后，化为单点修改，求前缀和即可

16.https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=22&page=show_problem&problem=1960

注：给定$N \times M$和$X \times Y$的字符矩阵，求后者在前者出现次数；二维字符串$hash$，与一维类似，可以选取两个进制基数，构造二元多项式；取子矩阵$hash$值时，容斥一下即可

17.https://www.lydsy.com/JudgeOnline/problem.php?id=4892

注：基础题，给定字符串$A,B$；问$A$中有多少子串，在最多修改$3$次意义下，变为$B$；直接枚举子串的左端点，二分$lcp$+$hash$check即可；多做几次，即得到左端点固定的答案。









##【3】字典Trie树/Manacher

01字典树专题：http://blog.csdn.net/miracle_ma/article/details/51484054

1.http://acm.hdu.edu.cn/showproblem.php?pid=1251

注：字典树模板题

2.http://codeforces.com/contest/159/problem/D

注：求给定字符串中下标不交的回文串对的数量

马拉车算法预处理$g[i]$表示前缀中所含回文串数量(差分，求二重前缀和)，平方$dp$

3.http://codeforces.com/problemset/problem/557/E

注：经典的01字典树上求k大值问题，形式类似于：问给定01串中所有子串字典序k大的子串，O(n^2)

4.http://www.lydsy.com/JudgeOnline/problem.php?id=4260

注：给定数组$a$，求两段不交的区间，使得区间异或和的和最大

字典树，正着倒着各做一次，依次插入，处理出$f[i]$表示前缀选两个数的最大异或和，前后合并

5.http://www.lydsy.com/JudgeOnline/problem.php?id=4567

注：贪心，题意较复杂

6.http://www.lydsy.com/JudgeOnline/problem.php?id=2741

注：区间询问，区间选两个数异或和最大，可持久化字典树+分块，预处理$f[i][j]$表示从第$i$个块的开头到下标$j$的答案

7.http://hihocoder.com/problemset/problem/1602

注：基础题，求本质不同回文串个数；马拉车+哈希：从左到右枚举回文中心，计算新出现的本质不同回文串个数，以及将他们的哈希值存入$hash$表；注意到判定关于半径$r$有单调性，即一个大半径若已经出现，则小半径则自然已经出现；只要从大到小枚举半径即可(枚举到重复出现停止)，因为总的本质不同回文子串个数是$O(n)$的







##【4】AC自动机/Trie图

1.http://codeforces.com/problemset/problem/697/F

注：给若干个串及其相应权值，构造一个长度为$l \le 10^{14}$的串，每包含一个给定串即得到相应权值(多次算多次贡献)，求最大可能得到的权值和；将所有模式串插入$trie$图，构建$fail$树，预处理每个点权值为该点到$fail$根路径上的关键点(模式串的点)的权值和，若有转移边$u \to v$，将$v$的点权作为边权，构建邻接矩阵；在$(max,+)$意义下做矩阵快速幂即可，等价于**图上定长最大带权可重路径**；此矩阵单位元为：对角线元素为$0$，其他元素为$-\infin$

2.http://codeforces.com/problemset/problem/710/F

注：经典的强制在线ac自动机，参见**二进制分组算法**(牺牲$log$时间复杂度，用以支持强制在线插入)

由于二进制分组算法不涉及删除，故利用容斥，把删除的串插入到另一个自动机森林

一个优化：在重建自动机时，由于字典树仍然是有效的，所以字典树可以合并，然后$build$构造失败指针(注意最好不要构造$trie$图)

3.http://codeforces.com/problemset/problem/86/C

注：给定$10$个长度不超过$10$的只含$4$中字符的串，问长度为$n$的串有多少种可能，使得可以由这些串拼凑而成，拼凑可重叠；分析：在$ac$自动机上做$dp$，令$dp[i][j][t]$表示长度为$i$的，走到$j$这个节点且末尾的$t$个字符未被覆盖的方案数，注意一个可行的方案，$j$代表的串是其最长公共前后缀($trie$前缀，自己后缀)，故不会算重；转移枚举每种字符，只有当$len(y) \ge t$才能转移到一个被标记的节点$y$，非标记节点不做要求

4.http://codeforces.com/problemset/problem/1110/H

注：很有思想的好题，trie图+数位dp+正则表达式通配符状态表示

题意：给两个长度$\le 800$的数字串$l,r(l \le r)$，构造一个长度为$n(n \le 2000)$的数字串(允许有前导$0$)，使其包含尽可能多的数值$\in [l,r]$的子串，相同子串可算多次；输出答案和字典序最小的方案

分析：

- 因为$l,r$范围实在太大，合法的子串空间很大，无法枚举模式串
- 考虑使用正则表达式来表示合法子串，使得子串空间可以划分成若干类，每类使用一个带通配符的正则表达式来描述，格式如下：
  - $[1..9]d_1d_2d_3d_4...d_{k-1}[0..9]\{t\}$，表示以非$0$数字开头，中间固定$k-1$数字，最末的$t$个字符任意
- 考虑$l\le x \le r$，若$|l|<|x|<|r|$，可用$9$个表达式表示；否则，有不超过$(|l|+|r|)9$表达式
- 考虑用双限制的数位$dp(dfs)$搜索出合法的表达式，将其插入到$trie$图中，且每个点标记$cnt[t]$表示使用$t$通配符的表达式个数
- 对$trie$中的每个点，$cnt$求前缀和，表示通配符长度不超过$t$的表达式个数
- 注意若长度足够，一个确定了$t$的表达式对应着一种合法的子串(虽然当前的具体串还不确定，但是总是需要确定的，而通配符接受所有字符，故只对应一种，而不是$10^t$)，因此我们求表达式个数
- 在$fail$树上做树$dp$，叠加$cnt$
- 令$dp[i][x]$表示走到了$x$这个点，还需要走$i$步，所可以产生的最大表达式个数
- 转移枚举字符$c$，走到$y$，考虑在当前串末尾追加字符$c$，本质上增加了很多后缀，增加的表达式个数保存在$cnt[y]$中，注意这里通配符有长度限制，也就是说实际获得了$cnt[y][i-1]$个表达式
- 选择转移到表达式最多的一个方向，记录追加的字符，即：$dp[i][x]=max_c\{dp[i-1][y]+cnt[y][i-1]\},y=go[x][c]$
- 答案为$dp[n][0]$

5.http://poj.org/problem?id=2778

注：经典题，不含病毒串的合法串计数；将病毒串插入到$trie$图，节点染色，在$fail$树上$dp$传递染色，将没被染色的节点提取出邻接矩阵，矩阵快速幂

6.http://www.lydsy.com/JudgeOnline/problem.php?id=1030

注：与上题类似，补集转化

7.http://acm.hdu.edu.cn/showproblem.php?pid=2222

注：模板题，统计母串所含模式串的种数

8.http://acm.hdu.edu.cn/showproblem.php?pid=3341

注：$trie$图基础$dp$，字符集$M=4$，给出每种字符的数量，构造一个字符串，包含尽可能多的模式串

令$dp[x][a][b][c][d]$表示从$x$这个点走，每种字符剩余这么多个，可以获得的最大数量，枚举字符转移即可

9.http://www.lydsy.com/JudgeOnline/problem.php?id=2434

注：$noi2011$经典题，给定一个串，包含小写字母和$B,P$，每个小写字母表示追加一个字符，$B$回退一个字符，$P$打印当前串，令$s_i$表示第$i$次打印的串，多组询问$(x,y)$表示$s_x$在$s_y$中出现的次数

分析：$trie$图处理多模式串，多主串问题，经典用法；首先$dfs$构造出字典树和$trie$图，考虑到本题主串也是模式串，故每次被标记的一定是字典树根到某个点的路径；考虑离线，询问$(x,y)$则$V[y].pb(x)$，对字典树$dfs$递归打标记，回溯撤销标记，走到$y$对应的点，回答所有$x$，等价于询问$fail$树子树和；取$fail$树$dfs$序，树状数组，单点修改，区间求和

10.http://www.lydsy.com/JudgeOnline/problem.php?id=1195

注：给定$n\le 12$个模式串，构造一个字符串包含所有模式串，最小化元祖$(长度，字典序)$

构造$trie$图，每个点求出$mask$表示包含的模式串，元祖$(x,S)$表示走到$x$当前$mask=S$的最短步数，若$go[x][c]=y$，$(x,S)\to (y,S|mask[y])$，$bfs$求最短路；由于本题每个点的出边没有相同的字母，直接求出最短路$DAG$，在其上贪心的$dfs$即可；如果有相同的字母，则逐层转移，用两个队列，保存连续两层，每层定节点优先级(父节点优先级，本节点字符)，每层$sort$之后转移

11.http://www.lydsy.com/JudgeOnline/problem.php?id=1009

注：求长度为$n \le 10^9$的不包含长度为$m \le 20$的给定的串的串的个数，矩阵快速幂，基础题

12.http://www.lydsy.com/JudgeOnline/problem.php?id=1212

注：给定若干个模式串，每次询问一个主串最多可以拼到多长的前缀；即不重叠不遗漏的覆盖。

令$f(i)$表示是否可以拼到$i$，每次走到$x$这个节点，沿着$fail$链遍历更新，$f(i)|=f(i-len(y)),y \in fail(x)$

13.http://www.lydsy.com/JudgeOnline/problem.php?id=3530

注：基础的$trie$图+数位$dp$，给定病毒数字串集合，给定数字串$k$，求不超过$k$的不包含病毒串的数个数

求出安全图，在上面做$dp$，长度小于$|k|$的，直接$dp$，长度等于$|k|$的，多记一维表示是否打破了限制

也可以矩阵快速幂，后面也可以直接枚举前缀，尝试每种可能的走法，然后叠加答案

14.http://poj.org/problem?id=3691

注：给定病毒串集合和一个主串，问至少修改几个字符，使得主串不包含病毒串，无解输出$-1$

令$dp[i][x]$表示走了$i$步走到$x$这个点，使得长度为$i$的前缀不含病毒串的最少修改次数

则$dp[i+1][y]=min\{dp[i+1][y],dp[i][x]+追加字符c!=s[i+1]\}$，注意转移跳过病毒节点

这个题目的本质是在安全图上求一条长度为$n$的路径，使其与原串$s$的汉明距离最小；属于安全图上的路径最优化问题，与计数问题无实质差异

15.http://www.lydsy.com/JudgeOnline/problem.php?id=1039

注：非常复杂的题目，给定若干个点列，询问每个点列在给定的主点列中出现的次数；匹配定义在点的平移，旋转，翻转，伸缩变换下；分析：将点列转化为相邻线段长度比例以及相邻线段夹角，可以使用叉积和点积表示出来；这是一种差分思想，后而转化为字符串经典问题

16.http://www.lydsy.com/JudgeOnline/problem.php?id=2553

注：给定$n(n \le 5)$个模式串(串长$\le 15$)，字符集($M\le 26$)意义下随机生成一个长度为$L$的串，令最多可不重叠的包含的模式串的数量为随机变量，求期望

- 首先贪心，走到某一个点，如果有多个串可选择，一定选长度最小的；即自动机上在某个点可选，然后将跳回起点
- $dp[i][x]$表示走了$i$步走到$x$这个点的期望，如果$x$是个危险节点直接跳回起点，然后转移枚举字符$c$，转移到$y$这个点，$dp[i+1][y]+=\frac{1}{M}dp[i][x]$，如果$y$是危险节点，注意初值有$dp[k][y]=1$
- 将上述转移改造成矩阵形式，矩阵快速幂即可，矩阵幂$A^k[x][y]$含义为从$x$点走$k$步走到$y$的新增的期望贡献

17.http://www.lydsy.com/JudgeOnline/problem.php?id=3172

注：基础题，给定$n$个模式串，一篇文章由其顺次拼接而成(空格隔开)，求每个模式串出现次数；经典应用

18.http://www.lydsy.com/JudgeOnline/problem.php?id=1444

注：给定$n$个模式串，按时间顺序随机生成一个字符序列，第一次包含模式串停止；$ac$自动机上的终结态的经过次数是个伯努利随机变量，故概率等于期望，我们把概率转期望，尝试构建线性方程组；转化为一个有向图，每个点可能有$m$种颜色之一，从起点随机游走，走到有颜色的点停止，最后求停止在每种颜色的概率

19.http://www.lydsy.com/JudgeOnline/problem.php?id=1559

注：给定$n\le 10$个模式串(串长$\le 10$)，求包含所有模式串且长度为$L$的字符串个数；基础的在$trie$图上做状压$dp$，令$dp[i][x][s]$表示走了$i$步走到$x$且二进制状态为$s$的方案数，预处理$g[x]$表示$x$这个点包含的模式串状态，转移容易

20.http://acm.hdu.edu.cn/showproblem.php?pid=5880

注：给定$n$个模式串，将给定主串中出现的模式串替换为$*$号；自动机上每个节点$x$预处理其$fail$链上的最长模式串长度$f(x)$，运行主串，在当前下标处记录当前节点最长长度即可$p[i]=f(x)$

21.http://acm.hdu.edu.cn/showproblem.php?pid=2896

注：稍复杂些的模板题

22.http://acm.hdu.edu.cn/showproblem.php?pid=3695

注：$2010$福州区域赛，模板题

23.http://acm.hdu.edu.cn/showproblem.php?pid=2296

注：基础$dp$+字典序最小方案构造；给定$n$个模式串(每个带价值)，构造(长度$\le k$，字典序)尽可能小的且价值最大的串(串价值为所包含的模式串价值之和)；等价于图论问题：在有向图上的起点开始走不超过$k$步，使得经过的价值和最大；字典序构造可以参见$bfs$最短路方案构造

24.http://acm.hdu.edu.cn/showproblem.php?pid=6138

注：给定$n$个模式串，$m \le 100$次询问，每次询问$(x,y)$表示$s_x$与$s_y$的最长公共子串长度，该子串要是某个$s_i$前缀；每次将$s_x$运行，将经过的点，包括$fail$链上经过的点打标记；运行$s_y$，遍历$fail$在经过的点中被标记的点处求最长长度

25.http://acm.hdu.edu.cn/showproblem.php?pid=4117

注：不错的题目，给定长度为$n$的字符串序列，求一个子序列，使得价值和最大，所取的元素中前一个串要是后一个串的子串；考虑将所有串插入构造$trie$图(记录每个串对应的节点编号)，$i \in [1,n]$，逐一考虑每个串，首先将对应节点打标记(激活)，然后运行下一个串，在每个走到的点中，考虑$fail$链上的$dp$最大值，最终从最大值转移过来；转化为对某棵子树$max$操作，取$dfs$序列，转化为线段树区间$max$操作，单点查询。亦可树链剖分；或者运行每个串时，从每个走到的节点，向上暴力跳$fail$树链，保证对于这个串来说，$fail$树上每个节点不重复访问，复杂度不超过$len \sqrt{len}$，具体分析详见广义后缀自动机

26.http://acm.hdu.edu.cn/showproblem.php?pid=4518

注：比较复杂的题目，令$a[i]$表示第$i$个数位中含有斐波那契数作为子串的自然数，令$b[i]=a[fib[i]]$，给定$n \le 10^{11}$，询问$b$中与$n$最接近的数

分析：考虑将$b$逐项求出来，因为$b$比$fib[]$渐进增长的速度还要快，故项数其实不会很多；相当于求$a[k]$。

考虑二分，令$f(x)$表示不超过$x$的数中$a$中的数的个数；则$a[k]=min\{x|f(x) \ge k\}$

考虑用数位$dp$求$f(x)$，将前若干个斐波那契数插入构造$trie$图；考虑长度严格小于$|x|$的串，实际可以补前导$0$，不会影响正确性，因为斐波那契数不含前导$0$；令$dp[op1][op2][i][x]$表示方案数，$op1$表示是否打破上界限制，$op2$表示是否已经含有了$fib$中数，即是否经过标记节点；走了$i$步走到$x$这个点；枚举追加的字符$c$，简单的转移

27.http://acm.hdu.edu.cn/showproblem.php?pid=5955

注：$2016$沈阳区域赛，同$bzoj1444$，即第$18$题

28.http://acm.hdu.edu.cn/showproblem.php?pid=4534

注：给定$n$个模式串和一个主串，要求可以删除主串中的一些字符，使其满足：必须包含某些特定的串，必须不包含某些特定的串，某些串出现每次均有个特定的价值，求满足条件下的最大价值和；分析：先求出安全图，预处理$mask(x)$表示$x$这个点包含的必须包含的串的状态，$f(x)$表示$x$的价值和；转化为，从起点开始走，在$mask$或为全$1$意义下，价值和最大；令$dp[i][x][S]$表示考虑到下标$i$，当前在$x$的，状态为$S$的最大价值；转移讨论是否删除当前字符

29.http://acm.hdu.edu.cn/showproblem.php?pid=6096

注：不错而又有趣的题目，$trie$图模式串对主串求分布；给定$n$个主串$s_i$，每次询问给出$p_j,q_j$，问有多少个主串满足以$p_j$开头，以$q_j$结尾，且二者不交；分析：一般字符串数据结构不容易同时考虑到前后缀，所以需要转化掉；令$S_i=s_i\#s_i$，$T_j=p_j \# q_j$，那么原条件等价于$T_j$在$S_i$中是否出现，注意到最多出现一次，所以相当于求某个模式串在所有主串中出现总次数；且要满足长度限制，考虑对所有串排序，从大到小的回答询问，插入主串

30.http://acm.hdu.edu.cn/showproblem.php?pid=6086

注：比较困难的题目，给定$n$个$01$串，构造长度为$2L$的$01$串包含所有模式串，且反对称，即$s[i]!=s[2L+1-i]$，问方案数；若无反对称的条件，是很朴素的在$trie$图上做状压$dp$；只考虑前$L$字符构成的字符串$s$，如果模式串$t$，在$s$中出现，就足够了，如果在右半边出现，则创造一个取反模式串；均插入到自动机中；现在考虑跨过分界线的模式串，如果在左边的长度小于右边的，那么总可以取反，得到左边长度大等于右边的，由于要满足反对称，右边的字符在左边确定之后就确定了，因此只要左边的模式串部分在$s$最末尾出现即可；因此等价于我们要寻一条路，使得所构造的串包含某些模式串，以及在末尾以一些串为后缀；对在任意位置可以包含的模式串，标记$1<<id$染色，在末端包含的打另一种标记染色$1<<id$，$dp$只需要考虑第一种；最终再枚举所有状态，并上第二种标记，如果是全$1$则叠加答案

31.http://acm.hdu.edu.cn/showproblem.php?pid=5384

注：模板题，对每个母串，求包含模式串的总次数

32.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2619

注：终止串只有一个的高斯消元，同27

33.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3494

注：$trie$图+数位$dp$，问区间$[L,R]$中有多少个数转化为$BCD$码之后不包含模式串；构造一张新图，处理出$x$遇到字符$c$的新的转移出边$go[x][c]=y$

34.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3545

注：$trie$图+状压$dp$，构造长度为$L$的串，使得包含模式串(数量不超过$10$)价值和最大，同一个模式串出现多次价值只算一次

35.http://acm.hdu.edu.cn/showproblem.php?pid=3247

注：不错的题目，第3题的扩展；给定$n$个模式串，将其互相重叠的拼凑(每串可用多次)，使得长度最短，且不含一些病毒串，求最短长度；需要根据$trie$图中的安全图构造新图，每个节点预处理$fail$链最长的模式串长度，从每个被染色的点出发$bfs$处理出任两个染色点$x$和$y$的不走其他染色点的最短路邻接矩阵$a[x][y]$，在此新图上做状压$dp$即可

36.https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=26&page=show_problem&problem=2463

注：给定$n$个模式串，随机生成长度为$L$的字符串，求不包含任何模式串的概率；已知生成每种字符的概率分布。简单的在安全图上做概率$dp$即可。

37.https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=22&page=show_problem&problem=1960

注：给定$N \times M$和$X \times Y$的字符矩阵，求后者在前者出现次数；此处用$ac$自动机做法

将模式矩阵按行拆成模式串插入自动机，逐行匹配母矩阵，对每行记录匹配的模式串行号；这样我们得到一个矩阵，矩阵中每个元素是个$vector$，表示以此格为起点向右可匹配的模式串编号，转化为求该矩阵中有多少个连续的列向量$1..n$即可；但是这样做可能会爆空间，所以最好把模式串相同的编号压缩表示(用最小编号表示)，这样就不用$vector$了，同时也将$1..n$压缩，然后逐列匹配叠加即可

38.http://acm.hdu.edu.cn/showproblem.php?pid=2243

注：经典题，求长度不超过$L$的至少包含一个模式串的字符串个数；补集转化，求出安全图，等价于在此图中从起点出发走不超过$L$步的路径个数；加一个带自环的松弛节点$T$，求起点$S$恰好走$L$步走到$T$的方案数；矩阵快速幂

39.https://www.lydsy.com/JudgeOnline/problem.php?id=4327

注：给定$n$个模式串，和一个主串；对每个模式串，求其最长前缀在主串中出现；多种做法，此处用$ac$自动机

模式串构造$trie$图，运行主串打标记，且沿着$fail$也打标记(注意不要重复走点)；逐个运行模式串，在只走标记点意义下，看最多可走多远

也可以对每个模式串的每个前缀打标记，然后运行主串，每向前转移一步，每次都要沿着$fail$链暴力向上走，途径标记的点，用标记的类型产生贡献

40.http://acm.hdu.edu.cn/showproblem.php?pid=2825

注：问长度为$n$的串中至少包含$k(k\le 10)$个模式串的个数；寻路径至少包含$k$个染色点，基础的状压$dp$

41.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3013

注：题意不明

42.http://acm.hdu.edu.cn/showproblem.php?pid=5566

注：给定$n$个点的带点权的树，点权为字符串，每次询问$x$到$y$的路径上在$s_i$中出现的最长的字符串长度；树链剖分+$trie$图，转化为线段树问题，线段树上每个点建$ac$自动机；线段树上每个点对管辖的所有串建自动机复杂度是串长之和，注意到线段树一层的总复杂度是所有串长和，有$log$层；一次区间查询，$|s_i|$最多$log$次

43.http://acm.hdu.edu.cn/showproblem.php?pid=4511

注：稍加转化后题意为：有$n$个点排成一列，编号为$1..n$，每个点可以向右走到一些特定点(有边权)，问从$1$到$n$的最短路，走过的编号序列不能有一些连续的给定编号序列；将禁止串插入自动机，在安全图上$dp$，$dp[i][x]$表示走到自动机上$x$这个点，在点列中的$i$号点的最短距离，简单转移即可

44.http://acm.hdu.edu.cn/showproblem.php?pid=4878

注：比较复杂的题目，$trie$图+$dp$+中国剩余定理+矩阵快速幂；给定$m$个模式串，构造长度为$n$的串$s$，若$s[i..j]$等于第$k$个匹配串，有$p[k]*(len[k]+j)$的得分，求总得分模$5047621$；首先模数可分解，用$crt$合并即可；对$trie$图每个点$x$预处理$f(x)=\sum p[k]$，$g(x)=\sum p[k]*len[k]$，令$dp[i][x]$表示$i$步走到$x$的总得分，$dp[i+1][y]+=dp[i][x]+g(y)+(i+1)f(y)$，注意到转移与$i$有关，故化为矩阵之后不是常系数的，一种解决方法是，由于模数分解得到的质数不大，故考虑将矩阵分类，每类是常系数的

45.http://acm.hdu.edu.cn/showproblem.php?pid=5069

注：不错的题目，给定$n$个模式串，$m$个询问$x,y$，回答$s_x$的后缀与$s_y$的前缀的最长匹配；此处给出$ac$自动机做法，只需要将$s_x$末端对应的点染色，然后运行$s_y$每步走到的点的子树须包含染色点；考虑离线，运行$s_y$回答所有$x$询问，就不要去染色了，直接用当前步长将子树取$max$，然后逐个$x$查询即可；在运行一次将走到的点的子树区间清零

46.http://acm.hdu.edu.cn/showproblem.php?pid=4758

注：$2013$南京网络赛，题意等价于：求包含$n$个$0$和$m$个$1$的$01$串方案数，不含任何模式串，经典模型

47.https://www.lydsy.com/JudgeOnline/problem.php?id=4861

或者 https://loj.ac/problem/2180

注：不错的题目，给定$n$个基本串($len \le 2$)，和$m$个病毒串，求方案数，将基本串按某种顺序顺次拼接(不能重叠)，每个基本串可用多次，要求不能包含病毒串；插入所有串，构造自动机，取安全图；预处理$a[i][k]$表示在$i$这个点，追加$k$这个基本串，可以转移到的节点编号；令$dp[i][x]$表示走了$i$步走到$x$这个点的方案数，$dp[i+len(s[k])][y]+=dp[i][x],a[x][k]=y$，注意到这里长度与$len(s[k])$有关，不便于转化成矩阵形式，但是长度不超过$2$；故我们考虑将转移按照$len$分成两类，均表示成矩阵形式，$T_1,T_2$；

由$dp_{i+2}=T_1dp_{i+1}+T_2dp_{i}$知：
$$
\begin{bmatrix}
dp_{i+2} \\
dp_{i+1}
\end{bmatrix} =
\begin{bmatrix}
T_1 & T_2 \\
E & 0
\end{bmatrix}
\begin{bmatrix} 
dp_{i+1} \\
dp_{i}
\end{bmatrix}
$$
重新构造矩阵和向量，做矩阵快速幂即可

总结：在矩阵类的题目中，如果有多种矩阵变换/转移，且他们产生的状态推进还不太一样的时候，我们应该将向量形式的矩阵递推式规整的写出来，然后整体构造一个分块的综合转移变换矩阵

48.http://acm.hdu.edu.cn/showproblem.php?pid=6208

注：挺基础的题，给定字符串集合，找出其中一个串，包含所有串；只需要验证最长串是否包含所有串，运行之，暴力遍历$fail$链，由于不需要知道具体次数，所以树上的点不需要重复访问

49.https://www.lydsy.com/JudgeOnline/problem.php?id=4231

注：不错的题目，给定$n$个点的一棵树，边权带权(一个小写字母)，每次询问$x$到$y$的有向路径包含$s_i$多少次；令$u=lca(x,y)$，显然在$u$处拐弯的匹配，可以通过暴力抠出串，$kmp$或者$hash$等求得匹配；考虑根到$y$的有向直链路径，我们需要求其匹配，只需在树上将所有这样的询问离线，$dfs$原树，递归时打标记，回溯时撤销，这样走到$x$这个点，仅有根到$x$的有向路径保留了标记，有查询，则查询子树和即可；考虑反向的直链，则将模式串的反串插入到自动机即可；我们要求的是$u$到$x$的，则稍加容斥，转化为$Q(x)-Q(x')$，$x'$为使得上端恰好溢出的下端节点编号

50.https://www.lydsy.com/JudgeOnline/problem.php?id=3940

注：不难的题目，给定$n$个模式串，和一个主串$s$，要求$s$中不能出现模式串，每次选取第一次的出现，在$s$中暴力删除，求最后的串$s'$，模式串满足两两不互相包含；由于模式串互不包含，意味着$fail$树上没有一个模式串节点是另一个模式串节点的祖先，做树$dp$，求得每个节点可能包含的唯一的模式串编号；在自动机上运行主串，同时维护走到的自动机上的节点编号组成的栈，遇到病毒节点，暴力弹栈，暴力删除字符，跳转到栈顶节点，然后继续匹配

51.https://www.lydsy.com/JudgeOnline/problem.php?id=3881

注：不错的题目，给定模式串集合$S$，主串集合$T$，初始$T$为空；动态加主串到$T$中，查询$S$中的某个模式串$S_i$在$T$中几个主串出现；经典的做法，用$S$构造自动机，每次插入主串$s$，在自动机上运行得到节点序列，按照$fail$树$dfs$序排序后令为$\{a_i\}$，则打标记，$a_i$处$+1$，$lca(a_i,a_{i-1})$处$-1$；查询直接查询模式串对应节点$fail$树上子树和即可

由于按照$dfs$序排列后，考虑每次加一个染色的点，其到根的路径必定只会交于当前轮廓(即上一个点到根的路径)，故交点即为这相邻两点的$lca$；而树上直链加$1$，可用差分

52.https://ac.nowcoder.com/acm/contest/888/H

注：比较难的题目，$trie$图+树链剖分+线段树+矩阵乘法，综合性比较强；给定一棵树($n$个点)，每条边上有一个字符集合，表示可以选择其中一个字符作为边权；给定一个模式串集合；每次询问$x$到$y$的有向路径中有多少种选择字符的方案使得顺次连接得到的字符串至少包含一个模式串；首先补集转化，求不含模式串的方案，用总方案即途径字符集合的$size$乘积，减去答案；用模式串集合构造$trie$图，导出安全图；为叙述方便，先讨论安全图的邻接矩阵及其幂：矩阵$A[x][y]$是说$x$是否可一步到达$y$，在给定的字符集合限制下，即只允许走集合中的字符转移边，则矩阵$A$中有些元素要清零；换句话说，一个给定的限制字符序列(一条边)，确定了一个受限制的邻接矩阵；若无任何限制$A^k[x][y]$表示从$x$走$k$步到$y$的方案数；当受一个字符集合序列(即一条链)的限制下，即每步都受限制，且限制可能不同，其有序的矩阵积$\prod A_{\sigma}[x][y]$表示这样的限制下，自动机上的$x$走指定步到$y$的方案数；因此，我们把一条边对应的矩阵令为边权，则一条链的有序矩阵积$B$的第一行的和即为方案数，而这等价于乘上全$1$列向量(右乘)；故问题的关键在于求链上矩阵积。

考虑树链剖分，用线段树维护矩阵积，$build$复杂度显然$O(nm^3)$；查询一条链，拆分为$log$段，每段线段树查询一次，$O(log*m^3)$；考虑一个优化，查询时只将矩阵取出，排好序，不做矩阵乘积，直接不断右乘一个向量，每乘一次是$O(m^2)$，故复杂度$O(log^2*m^2)$；考虑一个优化，由于树链剖分部分，查询一条链，用到的每个段，除了最顶部的之外，都是某条重链的前缀，故可以预处理全局的每条重链的前缀积；最顶部的仍然线段树查询$O(log)$，其他的每个段，都是$O(1)$取出，故我们得到了$2log$个矩阵，乘向量$O(log*m^2)$；但实际上，由于树链剖分常数很小，所以第二个优化不使用也可通过

注意：考虑到方向的不同，实际上取矩阵的时候，有时候会取出反方向的，即不是我们要的方向；考虑一个方法：对线段树，和重链前缀，都使用些时空消耗计算并保存反向的矩阵，取需要的方向即可

总结：对于这样的一些综合性强的题目，注意使用多个模板之间产生的耦合性；分块调试

53.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=1477 $A$题

注：模板题，字符集为$N$的$trie$图，可持久化线段树维护$trie$图；就是将$fail$树上$x$的父亲$p$的$nxt[]$可持久化的继承给$x$，然后用字典树上$x$的出边更新$nxt[]$；另一种方法：如果每次寻找$fail$过程中，不断的沿着$fail$链下滑，复杂度是$O(N*C)$，$N$是字典树大小，$C$是字符集大小，因为对每种字符(颜色)，最多遍历一整棵$fail$树；考虑到每个点悬挂的颜色总和数量是$O(N)$的，故令$cnt[c]$表示颜色$c$的数量，则$\sum_{c \in C}cnt[c]=N$，对$cnt[c]$分块；若$cnt[c] > B$，则寻找$nxt[x][c]$的$fail$指针的过程，可以沿着$fail$链暴力跳，该颜色$c$总复杂度$O(N)$，所有颜色总复杂度$O(N*N/B)$；若$cnt[c] \le B$，对颜色$c$，维护含有颜色$c$的节点序列$vector:V[c]$，暴力扫描里面的点，找出$x$的父亲中深度最大的候选点$y$，则$fail[x]=nxt[y][c]$；可以使用树上倍增判别父子关系，所有颜色总复杂度$\sum cnt[c]^2logN \le BNlogN$；令两类复杂度相等，得到$B=\sqrt{\frac{N}{logN}}$，总复杂度$O(N\sqrt{N}\sqrt{logN})$。

54.https://codeforces.com/contest/1252/problem/D

注：中档题，给定$n*m$字母矩阵($n,m \le 500$)；每次询问一个串$t$($\sum \le 2 \times 10^5$)，问在矩阵中以$7$字型(先向右，再向下)出现的次数。这里讲$trie$图做法，考虑将模式串插入构造$trie$图(长度大于$1000$直接忽略)，且记下每个串对应的节点编号$x$；枚举每一条极长的$7$字型路径，即$(i,1) \to (i,j) \to (n,j)$，运行此串，走过的点打上标记，然后做树$dp$，则每个串的节点$x$的$dp$值$cnt[x]$就是其出现次数。但是上述做法是错误的，方案算重了；考虑将不拐弯的情况单独处理；这里只计算拐弯的情况，则每条路径拐弯之后的每一步转移才打标记，且这里采用树链加的暴力操作，令$L$表示当前拐弯之后走的步数(即竖直长度)，从节点$t$向上倍增找第一个$len$值不超过$L$的节点$t'$，然后差分打标记，在$t$处$++$，在$t'$处$--$，最后树上$dfs$取得真实值$cnt[]$。注意这里复杂度为$O(500^3log10^3)$，将树上倍增换成长链剖分可以去掉$log$，复杂度$O(500^3)$。











##【5】后缀数组

1.http://poj.org/problem?id=2774

2.http://acm.hdu.edu.cn/showproblem.php?pid=4622

3.http://www.lydsy.com/JudgeOnline/problem.php?id=4310

4.http://www.lydsy.com/JudgeOnline/problem.php?id=4946

5.http://www.cnblogs.com/SiriusRen/p/6654401.html

6.http://www.lydsy.com/JudgeOnline/problem.php?id=3172

7.http://hzwer.com/3605.html

8.http://www.lydsy.com/JudgeOnline/problem.php?id=4552

9.http://hzwer.com/7454.html

10.http://codeforces.com/contest/204/problem/E

11.http://www.lydsy.com/JudgeOnline/problem.php?id=2119

12.http://www.lydsy.com/JudgeOnline/problem.php?id=4566

13.http://www.lydsy.com/JudgeOnline/problem.php?id=4516

14.http://www.lydsy.com/JudgeOnline/problem.php?id=3998

15.http://www.lydsy.com/JudgeOnline/problem.php?id=4199

或者：https://loj.ac/problem/2133

注：中档题，给定字符串$S$，对每个$r \in [1,n]$，回答$pair(x,y),x<y$的个数，使得$lcp(x,y) \ge r$；并且给定$a_i$，对每个$r$，给出最大的$a_x*a_y$；直接使用后缀数组子串扫描计数，并查集维护集合合并，集合记录最大值，最小值，元素个数。最后算出结果($lcp=r$)，取后缀$max$。

16.http://www.lydsy.com/JudgeOnline/problem.php?id=3238

`2` `20190605` `bzoj3238` `SAM` `后缀树`

17.http://www.lydsy.com/JudgeOnline/problem.php?id=1031

18.http://hzwer.com/4248.html

19.http://www.lydsy.com/JudgeOnline/problem.php?id=3879

`2` `20190605` `bzoj3879` `虚树` `SAM` `后缀树`

前置技能是 `bzoj3238`

20.http://www.lydsy.com/JudgeOnline/problem.php?id=2754

21.http://www.lydsy.com/JudgeOnline/problem.php?id=2534

22.http://www.lydsy.com/JudgeOnline/problem.php?id=3676

23.http://codeforces.com/contest/700/problem/E

24.http://codeforces.com/contest/427/problem/D

25.http://codeforces.com/contest/452/problem/E

26.http://codeforces.com/contest/432/problem/D

27.http://codeforces.com/contest/123/problem/D

28.http://codeforces.com/contest/128/problem/B

29.http://codeforces.com/problemset/problem/825/F

30.http://codeforces.com/problemset/problem/822/E

31.http://codeforces.com/problemset/problem/727/E

32.http://codeforces.com/problemset/problem/710/F

33.http://poj.org/problem?id=1743

34.http://poj.org/problem?id=3261

35.http://poj.org/problem?id=2406

36.http://poj.org/problem?id=3693

37.http://poj.org/problem?id=3294

38.http://poj.org/problem?id=3415

39.http://www.spoj.com/problems/DISUBSTR/

40.http://acm.timus.ru/problem.aspx?space=1&num=1297

41.http://acm.timus.ru/problem.aspx?space=1&num=1517

42.http://www.spoj.com/problems/REPEATS/

43.http://www.spoj.com/problems/PHRASES/

44.http://poj.org/problem?id=1226

45.http://hihocoder.com/problemset/problem/1419

46.http://hihocoder.com/problemset/problem/1403

47.http://hihocoder.com/problemset/problem/1407

48.http://hihocoder.com/problemset/problem/1415

49.https://nanti.jisuanke.com/t/31717

50.https://www.lydsy.com/JudgeOnline/problem.php?id=4340

51.https://www.lydsy.com/JudgeOnline/problem.php?id=5496

52.https://www.lydsy.com/JudgeOnline/problem.php?id=4556

53.https://www.lydsy.com/JudgeOnline/problem.php?id=5304

54.http://acm.hdu.edu.cn/showproblem.php?pid=5069

注：不错的题目，给定$n$个模式串，$m$个询问$x,y$，回答$s_x$的后缀与$s_y$的前缀的最长匹配；此处给出后缀数组做法，直接把所有串插入后缀数组，考虑离线，对同一$x$回答所有$y$，首先扫描$s_x$对每个后缀在$SA$数组上染色(元素在$SA$下标插入$set$)，每次单点查询$s_y$对应的位置，找到距离其最近的染色元素即可(在$set$中$lower\_bound$)

55.https://www.lydsy.com/JudgeOnline/problem.php?id=3145

注：难题，启发式合并+后缀数组$SA$；给定两个字符串$S,T$；求最多相差一位意义下二者的最长公共子串长度。本质相当于枚举下标对$(i,j)$，最大化$lcs(S_{i-1},T_{j-1})+lcp(S_{i+1},T_{j+1}+1)$。这里介绍只用后缀数组的做法：以$S,T$的连接串构建$SA$，用$SA$经典的子串扫描技术，从大到小扫描$lcp$，对后缀数组动态分组，使用并查集和$set$做启发式合并；在每一轮，正串的$lcp$长度每个集合视为都一样，每个集合轻松记录着其内部任两个下标对应的反串的$lcp$最大值，加上当前本身的$lcp$正串的，即构成答案；则在两个集合启发式合并的时候，注意扫描小集合中的每个元素，去大的里面二分前后继，用$ST$查询反串后缀数组的$lcp$，记录最大值，注意$set$中使用反串的后缀数组排名作为优先级。

56.https://www.lydsy.com/JudgeOnline/problem.php?id=4892

57.https://ac.nowcoder.com/acm/contest/366/J

或者http://codeforces.com/gym/102056/problem/J

注：难题，$2018EC-Final$  $J$题；后缀数组+分治+博弈论纳什均衡

给定字符串$S$，求$\max_{\{p_i\}} \left(\min_{j=1}^n\left(\sum_{k=1}^n p_k \mathrm{lcp}(s_k,s_j)\right)\right)$

- 纳什均衡：当你有若干种选择时，给出一种概率分布，指定你每种选择的概率；满足无论对方做何种决策(对方选择什么)，你的期望收益都是相同的
- 考虑两个后缀的$lcp$是$height$数组的区间最小值，那么令此最小值下标为$pos,pos+1$；显然这样画出的决策矩阵，具有可分治的性质，因为双方跨过最小值之后答案就是最小值，只要递归到没跨越最小值的情况即可
- 考虑函数$solve(l,r)$表示子问题$[l,r]$的答案，首先找到最小值的下标，然后递归$solve(l,pos),solve(pos+1,r)$；最后回溯合并的时候，利用纳什均衡分配概率$p_L,p_R$；使得无论对方决策到哪里(左边或者右边)，你的期望收益均相同，令两种可能期望收益相等，可以解出$p_L,p_R$，从而得到答案
- 总结：关键是利用纳什均衡的思想，在后缀数组上分治；而纳什均衡的决策矩阵是很关键的

58.https://codeforces.com/contest/1252/problem/D

注：中档题，给定$n*m$字母矩阵($n,m \le 500$)；每次询问一个串$t$($\sum \le 2 \times 10^5$)，问在矩阵中以$7$字型(先向右，再向下)出现的次数。对每个询问串，考虑枚举拐点，则可获得$7$字型串；等价于询问$n*m$矩阵中有多少个格子与此模式匹配，具体来说，从此格子与拐点向下和向左分别可以匹配一定长度。只考虑一个方向，我们将每一列字符串和每个询问串，插入到后缀数组，得到$sa[]$，注意到根据询问串后缀的排名，可以找到并且锁定$sa$数组中的元素，通过二分求$lcp$大等于某个长度$L$的区间边界，得到一个区间。另一个方向类似也得到一个区间(将每行的反串和询问串的反串插入)，每个矩形格子都有个二元$pair$表示在两个后缀数组中的排名，视此为二维点，问题转化为一系列矩形数点的离线查询，可以使用树状数组扫描线。时间复杂度$O(SlogS),S$为串总长。







##【6】后缀树



##【7】后缀自动机

1.http://hihocoder.com/problemset/problem/1441

注：模板题，输出中间信息

2.http://hihocoder.com/problemset/problem/1445

注：模板题，本质不同子串计数

3.http://hihocoder.com/problemset/problem/1449

注：基础题，求$cnt[k]$表示长度为$k$的本质不同子串出现的最大次数；注意有单调性，直接将标记打到区间右端点即可，求后缀最大值

4.http://hihocoder.com/problemset/problem/1457

注：模板题，求所有子串的数值之和$\%1e9+7$

5.http://hihocoder.com/problemset/problem/1465

注：中档题，给定字符串$s$，每次询问字符串$t$的循环同构串在$s$中的出现次数之和；考虑令$T=tt$，故$t$的循环同构串即$T$中长度为$n$的子串；在$SAM$中运行串$T$，每次运行到一个节点，沿着后缀链回退到长度恰好$\ge n$，为防止计算，先标记节点；从此节点继续运行串，时间复杂度为$O(|T|)$，因为每个字符进队一次出队一次(双指针)

6.http://hihocoder.com/problemset/problem/1466

注：难题，给定字符串$A$和$B$，若二人博弈，初始给出字符串$a\in A, b \in B$表示$a$是$A$的子串，$b$是$B$的子串；轮流操作，每人选择一个字符串，在后面追加任何一个字符，使之仍然是对应串的子串；不能操作者败。在所有使得先手必胜的可能的初始串$(a,b)$中，求字典序第$k$小的元祖。首先对$A,B$分别构造$SAM$，求出每个状态的$sg$值，且注意此值必然$\in [0,26]$。关键在于下面求字典序第$k$小的方案：先求$cnt_A[s][x],cnt_B[s][x]$表示$A$中以$s$开头的子串中$sg$值恰好为$x$的个数，$B$中$...$。$cnt_A[s][!x]$表示$sg$值不为$x$的个数。由于$SAM$在转移链下是个$DAG$，故可$dp$求之，然后在$DAG$上$dfs$，采用逐位确定的方法；首先确定$a$的第一位，再确定第二位；确定$a$之后，同理确定$b$，计算采用$cnt$值去确定。

7.http://www.lydsy.com/JudgeOnline/problem.php?id=3676

注：基础题，给定字符串$s$，求最大的回文子串值，定义为长度乘出现次数；此处考虑用后缀自动机：

沿用马拉车算法，可以识别出所有本质不同的回文子串及其区间$[l,r]$；对每个区间，在后缀自动机上找到对应的节点，可以使用倍增，即在前缀$r$对应的节点$x$，沿着后缀链倍增；即得到该子串出现的次数。

8.http://www.lydsy.com/JudgeOnline/problem.php?id=3238

注：中档题，$SAM$+树$dp$，给定字符串$s$，求其两两前缀的$lcp$之和；构造$SAM$，将所有前缀对应的节点染色；在$parent$树上做树$dp$，预处理出$cnt[x]$表示$x$节点包含的染色节点个数；枚举$lca$，计算每个点的贡献：$\binom{cnt[x]}{2}-\sum_{y \in sub(x)}\binom{cnt[y]}{2}$。

总结：注意本题用到$SAM$中$Parent$树上$lca$的含义，表示对应子串的$lcp$的对应节点

9.http://www.lydsy.com/JudgeOnline/problem.php?id=3926

注：中档题，$SAM$在$trie$树上的扩展；给定一棵树，点权为字符集$size=C$的字母；求所有有向路径构成的不同串个数，叶子节点个数不超过$20$；注意到任何一条有向路径必然在某一个叶子节点为根的有根树中，是一条竖直的直链；因此对每一棵有根树$dfs$，将该有根树插入到广义后缀自动机，详见国家集训队论文和模板；后而统计本质不同串数量即可。

10.http://www.lydsy.com/JudgeOnline/problem.php?id=1921
注：难题，$CTSC2010$珠宝商；点分治+后缀自动机；给定一棵点带字母的树，给定长度为$m$的串$S$，求所有树上有向路径代表的字符串在$S$中出现的次数之和；

- 考虑构造出$S$的$SAM$，考虑一个暴力：枚举树上的起点$x$，以$x$为根$dfs$这棵树，将途径的自动机上的点的$cnt$值相加即可；复杂度$O(n^2)$
- 考虑另一个暴力：使用点分治，对每一棵以$x$为根的分治子树(即$x$为重心)$dfs$，在自动机上走，识别$y \to x$的路径字符串，即终点固定为$x$的路径，走到的点打上标记(相当于在已经被识别的字符串左侧加字符，沿着$parent$树向下走即可)；并对$parent$树做树$dp$，求出每个叶子的标记之和，注意自动机上的叶子对应串的前缀；因此可以得到每个前缀$i$的$cnt[i]$表示$S$中以下标$i$为结尾的字符串个数(同一个字符串可能被算多次)，满足存在一条以树上$x$这个点为终点(即存在$y \to x$路径)的路径字符串恰好为此字符串；$cnt[i]$表示这样的路径条数。再考虑$x \to y$的路径，建立反串的$SAM$，类似的再做一次即可。
- 一个分治子树的答案即为：$ans=\sum_{i \in [1,m]}cnt[i]*cnt'[i]$；注意这样有多算的路径，他们的两个分支出现在了同一棵子树，递归回溯的时候，容斥一下，扣除同一棵子树的贡献即可；时间复杂度$O(nlogn+nm)$，注意后者复杂度在于$O(m)$做了树$dp$
- 考虑在点分治基础上优化，当分治子树$size \le B$时候，用第一个算法$O(size^2)$，否则用第二个算法$O(m)$；由于点分治的性质，第二类分治子树最多$n/B$个，故复杂度$O(n/Bm)$；第一类分治子树，由于每次递归到满足条件的时候，立即处理掉，没有递归下去，故相互之间不会交；则$\sum size \le n$，故复杂度$O(\sum size^2)\le O(B\sum size)=O(nB)$；考虑二者平衡，令$n/Bm=nB$，即得$B=\sqrt{m}$，总复杂度$O(nlogn+m+n\sqrt{m})$。

11.http://www.lydsy.com/JudgeOnline/problem.php?id=3473

或者https://www.lydsy.com/JudgeOnline/problem.php?id=3277

注：中档题，给定$n$个字符串，对每个字符串，回答其包含多少个子串，在这$n$个字符串中至少出现$k$次；广义$SAM$+启发式合并；如果用$map$，每个合法的节点直接将贡献叠加给字符串即可

12.http://www.lydsy.com/JudgeOnline/problem.php?id=1396

或者https://www.lydsy.com/JudgeOnline/problem.php?id=2865

注：中档题，$SAM$+线段树，给定字符串$S$，对每个下标$i$，找到子串$t \in S$，$t$包含下标$i$，且$t$只出现一次；构建自动机，对出现次数为$1$的节点，作出贡献即可；即考虑三元组$(l_1,l_2,r)$，对于$i \in [l_2,r]$，贡献为$r-l_2+1$，对于$i \in [l_1,l_2)$，贡献为$r-i+1$，由于$i$为贡献共有的成分，故提出，考虑$r+1$即可；用线段树，区间$max$操作，单点查询。

13.http://www.lydsy.com/JudgeOnline/problem.php?id=3145

注：难题，广义$SAM$+启发式合并+后缀数组$SA$；给定两个字符串$S,T$；求最多相差一位意义下二者的最长公共子串长度。这里介绍后缀自动机+后缀数组的做法：以$S$构造$SAM$，在$parent$树上启发式合并，求出$right$集合；对于一个自动机上的节点，若在两个串中都出现了，则枚举两个异色的$right$集合中的下标，要求他们在后缀数组中的$rank$接近且$lcp$最大；做法是在启发式合并过程中，合并前先查询，如左边的集合中的红色点，在后缀数组中打上标记，依次查询后边的集合中的蓝色点，寻找最接近的异色点，直接在$set$中二分即可，$set$按照后缀数组排名；在$set$中找到前驱后继，用$ST$表查询后缀数组中的区间最小值；若该节点是合法的(在两串中均出现)，则算出的当前答案更新最终答案。

14.http://acm.hdu.edu.cn/showproblem.php?pid=6583

注：中档题，贪心+$dp$+后缀自动机，给定一个字符串$S$，和整数$p,q$，表示初始有个空串$T$，每次可以在后面添加任何一个字符，代价为$p$；或者添加$T$中的一个子串，代价为$q$；求使得$T=S$的最小代价。

- 令$dp[i]$表示写出长度为$i$的前缀的最小代价，转移考虑追加一个字符，或者追加一个已经出现的最长子串
- 存在单调性，即若$dp[i]$更新了$dp[j]$，此处指的是第二种转移，则后面的$dp[i'],j>i'>i$，是不会用第二种转移更新$dp[j]$的
- 将$(i,j)$看做双指针，$i$推进向自动机中插入字符，$S[i+1..j]$需要先回退掉前面的一个字符，然后继续向右边走；对应在自动机上可能会沿着$parent$链向上走一步，然后沿着转移链前进。最终找到新的最远指针$j'$。
- 每次转移$dp[i+1]=min(dp[i+1],dp[i]+p),dp[j]=min(dp[j],dp[i]+q)$

15.https://ac.nowcoder.com/acm/contest/884/I

注：中档题，给定字符串$s$，问最多选择多少子串满足两两不等价；等价定义为，相等或者互为反串(翻转)；$SAM+PAM$

考虑$s$中的子串分类，回文串称为$c$类，假设出现$c$个本质不同的；而非回文且正反均出现的子串称为$a$类，假设有$2a$个本质不同的，非回文且只有正串出现的称$b$类，有$b$个本质不同的。答案显然为$a+b+c$，将串$s$直接插入到后缀自动机，可以得到$2a+b+c$，我们要求$a$，比较复杂；不如将串$s$和$rev(s)$一起插入到广义后缀自动机，可以得到$2a+2b+c$，我们只要求$c$即可，故再建个回文自动机即可

16.http://codeforces.com/problemset/problem/316/G3

注：基础题，广义$SAM$+树$dp$合并；给定字符串$S$，问有多少本质不同的子串符合$n$个限制；每个限制$(t_i,l_i,r_i)$表示该子串要在$t_i$中出现的次数$\in [l_i,r_i]$；直接将这$n+1$个字符串构建广义后缀自动机，做树$dp$统计次数；逐个$check$自动机上的每个点$x$是否符合要求，在$S$中出现，且在$t_i$中出现次数$cnt[x][i]$也符合要求，答案贡献为该点含的字符串数目。

17.http://www.lydsy.com/JudgeOnline/problem.php?id=4199

或者：https://loj.ac/problem/2133

注：中档题，给定字符串$S$，对每个$r \in [1,n]$，回答$pair(x,y),x<y$的个数，使得$lcp(x,y) \ge r$；并且给定$a_i$，对每个$r$，给出最大的$a_x*a_y$；串翻转，构造$SAM$，对每个前缀代表的节点染色，等价于对$parent$树上每个点$x$，求其子树内的染色$pair$数量，和最大权。树$dp$，求子树最大次大点权，最小次小点权，染色节点数量；贡献叠加到$x$的最大长度。

18.http://www.lydsy.com/JudgeOnline/problem.php?id=4545

注：难题，$trie$之$SAM$+$LCT$，给定一棵$trie$树，定义其子串为一条竖直直链，操作有三种：询问当前本质不同子串数目，在点$x$下插入一棵新的$trie$，询问字符串$S$在当前$trie$中出现的次数。

沿用以$trie$建$SAM$的方法，在线做，用$LCT$动态维护$parent$树，具体紧扣代码模板，将新建节点和修改$pre$操作同步到$LCT$核心操作中，询问次数，是求节点子树和，即原本是$dfs$时单点打标记，子树求和；改为树链加，单点查询即可。询问本质不同子串个数，就是维护集合$size$之和，每次只要考虑新加的点即可。

19.http://www.lydsy.com/JudgeOnline/problem.php?id=2780

 注：中档题，给定$n$个主串，每次询问一个模式串$s$在多少个主串中出现；这里介绍$SAM$做法：

将主串建广义后缀自动机，逐个运行主串，将途径点染色(前缀节点)；询问时，逐个运行模式串，锁定节点$x$，如果中断答案为$0$；要回答$x$子树节点中有多少种颜色；可以取$dfs$序，树状数组离线，记录数组$last[t]$表示当前$t$这个数出现的最晚下标，树状数组维护$cnt[last'[t]]--,cnt[last[t]]++$，查询区间和即可；也可以用$set$直接启发式合并；有人染色时，每次沿着后缀链暴力向上爬$parent$树，复杂度无法保证

20.http://www.lydsy.com/JudgeOnline/problem.php?id=2806

注：难题，$CTSC2012cheat$，给定$01$主串集合，每次询问一个串$S$，问是否能将$S$分成若干段，若一段在至少一个主串中出现且长度$\ge L$，则合法，使得合法总长度不低于$90\%$，求最小的$L$满足要求。

显然$L$具有单调性，二分$L$，可以线性$check$：令$f_i$表示长度为$i$前缀的最大可匹配长度，转移：
$$
f_i=max(f_j+i-j),i-j>=L且s[j+1..i]能够匹配 \\
f[i]=max(f[i],f[i-1])
$$
 注意到：$j$的最小值$j_0$是关于$i$单调的，直接在后缀自动机上沿着转移链继续走即可，若走不通，则需要沿着后缀链会退，直到可以走通；维护一个$f_j-j$递减的单调队列，每次先将不符合要求的出队，将当前的$j=i-L$入队，取队头更新$dp$值，以$f_{len}$是否达到$90\%$判定。

21.https://www.spoj.com/problems/LCS/en/

注：基础题，给定两个字符串$S,T$，求其最长公共子串长度；直接用其中一个构造$SAM$，运行另一个，沿途走到的每个长度取最大值，注意失配要回退；或者直接建二者的广义后缀自动机，统计出现次数，扫描看是否该节点在二者中均出现即可。

22.https://www.spoj.com/problems/LCS2/

注：基础题，是上一题的扩展，串个数不超过$10$；沿用广义$SAM$做法即可

23.https://www.lydsy.com/JudgeOnline/problem.php?id=2882

注：基础题，给定长度为$n$的字符串$s$，求其循环同构中字典序最小的串；复制一遍构造$S=ss$，找字典序最小的长度为$n$的子串；构造$SAM$，在$DAG$上求每个点的最长路，然后贪心的逐位确定(沿着$DAG$走)即可

24.https://www.lydsy.com/JudgeOnline/problem.php?id=3998

注：中档题，给定字符串$S$，求字典序第$k$小的子串(分别在本质不同子串算$1$次，和算多次的情况下)；构造出$SAM$，在$DAG$上做$dp$，分别求从每个点出发的链路个数，和串个数(注意空串不算子串)；然后贪心的逐位确定即可，类似于字典树上的思路

25.http://www.lydsy.com/JudgeOnline/problem.php?id=4566

注：基础题，给定两个串，求他们的各取一个子串组成的重复子串对的数量；求每种子串在两个串中的出现次数，乘法原理即可

26.http://www.lydsy.com/JudgeOnline/problem.php?id=4516

注：基础题，对每个前缀回答本质不同子串个数，字符集$1e9$；只要在新建节点的时候(前缀节点)，加上新加的贡献即可；由于字符集巨大，考虑使用$map$代替原来的转移列表$go[x][c]$。

27.https://www.lydsy.com/JudgeOnline/problem.php?id=4032

注：难题，给定两个字符串$A,B$，长度$\le 2000$；问：

(1) $A$的一个最短的子串，它不是$B$的子串

令$f[i][j]$表示从$A$中$i$下标和$B$中$j$下标开始向右可以最短的衰亡步数，$A$中多走一步$A[i]$，$B$中如果$B[j]=A[i]$，则大家同时前进一步，答案$+1$；否则，答案为$0$，立即衰亡。最终答案，固定$i$，枚举所有$j$，取最大值即可。

(2) $A$的一个最短的子串，它不是$B$的子序列

令$f[i][j]$表示从$A$中$i$下标和$B$中$j$下标开始向右可以最短的衰亡步数($B$中不需要连续了)，$A$中多走一步$A[i]$，$B$中如果$B[j]=A[i]$，则$A$前进一步，$B$可以跳转到后面任何一个第一次出现的字符，取$f$最大值，答案$+1$；否则，答案为$0$，立即衰亡。最终答案，固定$i$，枚举所有$j$，取最大值即可。

(3) $A$的一个最短的子序列，它不是$B$的子串

对$B$构造后缀自动机，令$f[i][x]$表示从$A$中$i$下标和$B$自动机上$x$这个点，开始匹配，最短走多少步可以消亡；$A$中可以走到后面任何字符的第一次出现下标，$B$中必须匹配掉$A[i]$，故必须转移到$go[x][A[i]]$，否则立即消亡；注意在可以转移到的状态中，取最小值$+1$。最终答案，枚举$i$，取$f[i][0]$最小值。

(4) $A$的一个最短的子序列，它不是$B$的子序列

考虑二者的序列自动机，令$f[i][j]$表示$A$中$i$下标和$B$中$j$下标开始，以子序列形式匹配的最短衰亡步数；若$A[i]\not=B[j]$，立即消亡，答案为$0$；否则，对$A$中每一种后继$i'$，取$B$中该字符的后继转移，取最小值$+1$；这里我们转移不平方枚举，只考虑$A$的后继，$B$中直接跳转到该后继的字符处，没有就消亡，有则转移；在$A$的不同后继中选取$f$最小的。

28.https://www.lydsy.com/JudgeOnline/problem.php?id=2555

注：难题，给定字符串$s$，每次操作，在后面追加串$t$，询问字符串$k$出现次数，强制在线；自动机照常构造，$parent$树考虑用$LCT$动态维护其结构，询问时，运行串，相当于询问子树和；可以转化为在线链加，单点查询值。是题目$18$的弱化版。

29.https://www.spoj.com/problems/NSUBSTR/

注：基础题，给定字符串$s$，对每个$i\in [1,|s|]$，回答长度恰好为$i$的子串中，最大的出现次数；考虑到自动机上的一个节点的长度范围是连续的区间，求出出现次数之后，相当于区间$max$，单点查询；而事实上由于存在区间(后缀)包含单调性，故每个节点只需要考虑最大长度即可，因为其后缀必然继承其最优性

30.https://www.spoj.com/problems/SUBLEX/

注：是第$24$题子问题

31.https://nanti.jisuanke.com/t/A2018

注：模板题，求给定字符串中本质不同的出现次数在$[A,B]$之间的个数

32.https://ac.nowcoder.com/acm/contest/366/J

或者http://codeforces.com/gym/102056/problem/J

注：难题，$2018EC-Final$  $J$题；后缀自动机+树$dp$+博弈论纳什均衡

给定字符串$S$，求$\max_{\{p_i\}} \left(\min_{j=1}^n\left(\sum_{k=1}^n p_k \mathrm{lcp}(s_k,s_j)\right)\right)$

- 纳什均衡：当你有若干种选择时，给出一种概率分布，指定你每种选择的概率；满足无论对方做何种决策(对方选择什么)，你的期望收益都是相同的

- 将$S$翻转，构造$SAM_S$，在$parent$树上做$dp$；首先将$S$的所有前缀对应的节点染色，这些节点构成双方的决策空间；所求概率分布$\{p_i\}$，就是分配在这些节点上；根据纳什均衡，同一棵子树的不同儿子子树权值应该相等

- 如果一棵子树以$u$为根且$u$为染色节点，那么答案即为$len(u)$；因为你只要选择$u$，无论对方选择什么你的收益都是$len(u)$且最大

- 如果$u$不是染色节点，就要合并它的各个子树，设其有$k$个不同的子树(记为$v_i$)，注意叶子节点必定是染色节点；双方不可选择$u$，即决策必然落在某棵子树$v_i$；欲使得对方取各个子树，你的期望收益相同；只需要考虑$v_1,v_i,i>1$的比较即可，考虑令$v_1$的概率为单位$1$，令$v_i$的概率为$x$；令$v_1$权值为$y_1$，$v_i$的权值为$y_i$；对方选择$v_1$时，期望收益为$y_1+x*len(u)$；对方选择$v_i$，期望收益为$x*y_i+len(u)$；令二者相等，解得：$x=\frac{y_1-len(u)}{y_i-len(u)}$，这就是$v_i$的概率；将所有概率加起来$sum$，由于$v_1$占据单位$1$，故$v_1$真正的概率为$p=\frac{1}{sum}$

- 计算$u$的权值：由于对方选择哪棵子树，答案一样，故可令其选择$v_1$；$y_u=p*y_1+(1-p)*len(u)$，讨论你选择$v_1$与否即可

- ```c++
  void dfs(int u){
      if(color[u]){
  		Y[u]=len(u);
  		return;
      }
      int v1; double sum=0;
      for(int i=0,t; i<Child[u].size(); i++) {
  		t=Child[u][i];
  		dfs(t);
  		if(!i) sum+=1,v1=t;
  		else sum+=(Y[v1]-len(u))/(Y[t]-len(u));
      }
      sum=1.0/sum;
      Y[u]=(1-sum)*len(u)+sum*Y[v1];
  }
  ```

- 本题有后缀数组做法，其分治思想可能更容易理解

33.http://www.lydsy.com/JudgeOnline/problem.php?id=2754

注：中档题，本质题意：给定$n$个主串和$m$个模式串，对每个主串，询问包含哪些模式串各多少次；对每个模式串，询问包含于哪些主串各多少次；典型的模式串对主串求分布，主串对模式串求分布，是启发式合并的经典应用。也可以离线$dfs$序+树状数组。

34.https://www.lydsy.com/JudgeOnline/problem.php?id=2894

注：基础题，$SAM$在$trie$上扩展，求不同子串数目和$k$小子串，参考题目$24$

35.https://www.lydsy.com/JudgeOnline/problem.php?id=3756

注：基础题，$SAM$在$trie$上扩展，求给定串$S$和$trie$竖直路径匹配数；在$parent$树上做树$dp$，做两次，第一次是统计出现次数(自下而上)，第二次是统计后缀链的次数和(自上而下)，运行主串$S$，注意可能要回退，叠加沿途贡献即可

36.https://www.lydsy.com/JudgeOnline/problem.php?id=3879

注：中档题，给定字符串$S$，多组询问，每组给定一些下标，询问所对应后缀的两两$lcp$之和；构造反串$SAM$，每次询问相当于染色部分点(前缀节点)，求其虚树，在虚树上做树$dp$(要容斥一下，计算有多少对染色点$lcp$恰为自身$x$)，算出每个节点的贡献次数，然后叠加答案

37.https://www.lydsy.com/JudgeOnline/problem.php?id=4892

注：基础题，给定字符串$A,B$；问$A$中有多少子串，在最多修改$3$次意义下，变为$B$；枚举左端点，每次取其$lcp$，做几次即得到左端点固定的答案

38.https://www.lydsy.com/JudgeOnline/problem.php?id=3413

注：难题，题意较复杂，先研究些简单的版本：

首先是一个模式串询问：

- 若给定串为$A$，询问模式串为$B$，回答对$A$的每个下标开始与$B$的开头匹配，不断比较直到$B$匹配成功，或者第一次失败，或者$A$串结束。给出比较的总次数，无论比较成功或者失败的。令$|A|=n,|B|=m$。
  - 先计算失败的，等于$n-$$B$在$A$中的出现次数，因为$B$的每次出现会使得该开头为起始的对失败次数的贡献为$0$；
  - 计算成功的，等于$\sum_{i=1}^{n}lcp(A[i..n],B[1..m])$，为了方便，将两个串反串，任记为$A,B$，建立$A$的$SAM$，实际上答案为$\sum_{i=1}^mcnt[B[i..m]]$，即$B$的每个后缀在$A$中的出现次数之和，因为一个$lcp$可以转化为多个不同后缀的$1$次出现
- 现在修改题意，$A$的开头，只计可以装下$B$的长度的部分，即$[1..n-m+1]$
  - 失败的次数，与上面类似，答案为$n-m+1-cnt[B]$
  - 成功的次数，沿用上面的做法，但是$B$的每个后缀不是叠加总的出现次数，而是要看该次出现的末下标，是否大等于$m$，因为要能装下$B$；考虑到$SAM$的作用即是识别给定串的子串，考虑子串的定义，若不计$\le m$的前缀及它们的后缀，就不会识别不符合要求的子串；故在统计次数时，只对长度至少为$m$的前缀打标记，然后依旧树$dp$；运行$B$，锁定$B$对应的节点$x$，注意这里要沿着后缀链回退；然后考虑$x$到根的总次数之和。
- 多模式串询问：考虑到不同模式串之间，长度是主要的不同量，故只有打标记的时候有区别：
  - 离线算法，按照模式串长度从大到小排序，每次切换，相当于多打了几个前缀对应的标记，注意这里不能每次暴力沿着后缀链跳上去叠加标记，所以考虑用树状数组，$dfs$序+单点加+子树即区间求和。
  - 在线算法，就没那么奇妙了，直接线段树合并维护每个节点的$right$集合，这里是每个前缀都打标记，因此查询时，每个节点相当于线段树上求区间和(权值后缀和)，其他不变
- 原题题意：现在仍旧修改$A$的匹配开头，相当于走到第一次可以匹配了就停止；注意如果没有匹配，那么一直会走到以$n$开头的前缀
  - 沿用上面的在线算法，求出每个模式串匹配的最末下标$pos$，如果没有就是最小权值$pos=1$，该模式串的查询只考虑$\ge pos$的前缀，线段树合并算法没有改变
  - 离线算法：计算每个模式串的上述有效前缀区间，按照$pos$，从大到小排序，核心算法不变
- 总结：欲求$\sum_{1\le i<j\le n}lcp(s_i,s_j)$，其中$s_i$为以$i$开头的后缀；可以转化为$\sum_{1\le i,j\le n}lcp(s_i,s_j)$，这就是反串每个前缀对应的点到根的点权的加权和的和，因为$\sum_{i=1}^nlcp(s_i,s_j)$就是$s_j$对应的反串前缀对应的点到根的树链加权和。

39.https://www.lydsy.com/JudgeOnline/problem.php?id=5084

注：难题，对初始空字符串操作(可离线)：末端加字符，末端删字符，即支持回退，回答每个时刻的本质不同的子串个数。本质是支持回退的后缀自动机，且是以$trie$树建立的；动态维护树链并点权和。

- 先考虑个简单的问题：给定一个字符串$S$，和一个下标集合$s$，求$S$中以$s$中下标结束的本质不同字符串个数。
  - 建立出$SAM$之后，注意不要对每个前缀染色，只对可以做结束位置的前缀打标记即可
  - 然后树$dp$统计出现次数即可，下面我们考虑换个角度思考
  - 这相当于在$parent$树上，选中了一些点，提取他们到根的树链的并，每个点的点权设置为所含字符串个数，即树链并的点权和
  - 对$parent$树取$dfs$序，将这些染色的点按照$dfs$序排序，逐个处理，每次沿着树链向上走到$lca(a[i-1],a[i])$就停止；这里暴力走是$O(n)$复杂度的，$n$正比于自动机大小；可以考虑优化，将每段$a[i] \to lca(a[i-1],a[i])$的树链使用树链剖分、差分等数据结构快速查询，即可得到只关于询问集合大小$|s|$复杂度的算法，就像虚树一样
- 回到原问题：相当于询问$trie$树上，根到每个点的树链代表的字符串的本质不同子串个数，而$trie$的这条树链对应的一些节点在$parent$树上染色，取他们到$parent$树的根的树链并点权和即可，考虑动态维护
  - 注意这里插入删除的染色点在$dfs$序上分布是无规律的，我们考虑一般情况
  - 考虑插入元素，若在原来的$a_x,a_y$中插入元素$a_p$，则贡献从$a_y \to lca(a_x,a_y)$变为两个$a_p \to lca(a_x,a_p)$和$a_y \to lca(a_p,a_y)$，删除前者，追加后面两个即可，同时将$a_p$插入到$set$，用$dfs$序为优先级
  - 考虑删除元素是类似的，即删除两个，追加一个，从$set$中删除即可
  - 因此可以离线建立$parent$树，在$trie$上$dfs$一下，回答所有询问

40.https://www.lydsy.com/JudgeOnline/problem.php?id=5417

注：难题，$NOI2018$我的名字，给定一个字符串$S$，多次询问，每次询问串$T$中不在$S[l..r]$中出现的本质不同的子串个数；这个题目比较复杂，我们先考虑一些弱化版简单问题：

- 先考虑个前置问题：当以$S$建好自动机后，如何求在$S[l..r]$中出现的本质不同子串，而不重构自动机；一个做法是，利用线段树合并等算法，维护好每个节点的$endPos$集合；然后扫描每个点，计算贡献，看这个点代表的子串集合，有多少个字符串是在$S[l..r]$中出现的，这其中蕴含着后缀包含单调性，即一旦该子串集合中的某个后缀出现，该后缀的后缀必然出现，因此其实只要找$endPos$中$pos \le r$的最大$pos$即可，我们可以简单判断该子串集合的在$S[l..r]$中的出现情况；由于一个点代表的子串集合长度逐一递减，可以逐个长度在线段树上查询也是可以的(看指定区间是否有$1$)
- 考虑弱化版的问题：若总是令$l=1,r=|S|$，即求在$T$中出现而不在$S$中的本质不同子串个数；这很容易令人想到直接构造广义后缀自动机，但是实际上由于在多次询问下，复杂度与$|S|$有关，故不可行；如果只有一次询问，但是有多个$T$串同时满足某些区间出现与否的限制，便可以对每个下标编个总体的下标，采用广义后缀自动机+线段树合并；最后扫描每个点，复杂度是关于串总长的。我们考虑分别建立$S$和$T$的自动机：
  - 对$SAM_T$中的每个点$x$，我们需要知道有多少个串是在$S$中没出现的；为此，我们求出一个长度$L[x]$，表示该节点$x$代表的字符串集合中，长度$>L[x]$的串是在$S$中没出现的，即最多末尾$L[x]$个字符可被$S$子串识别；故该节点$x$贡献为：$min(max(len(x)-L[x],0),len(x)-len(pre(x)))$。
  - 为计算$L(x)$，考虑求出每个节点的最右出现下标$R[x]$；然后在$SAM_S$中运行$T$，追踪一个变量$cnt$表示截止到当前最多匹配了末端多少个字符，保存之，即得到$mx[i]$表示$T$中以$i$结尾可在$S$中出现的最长长度；具体而言，就是每次沿着转移链走，每走一步$cnt++$表示多匹配了一位；否则，沿着后缀链回退，$cnt-=len(pre[x])$表示为了向前多匹配即为，前面不得不删除一些已经匹配的字符，但是一个个删除不影响命运，不如一次删一段(其实一个个删除复杂度不会变劣)
  - 因此，叠加每个点的贡献即得到答案：$\sum_{x \in SAM_T}min(max(len(x)-L[x],0),len(x)-len(pre(x)))$，而$L[x]=mx[R[x]]$
- 回到原题，不过是每次询问多了区间$[l,r]$，与前面做法没有本质差别：
  - 为求$mx[i]$，先对$SAM_S$做线段树合并求$endPos$集合，在$SAM_S$中运行$T$；每次沿着转移链向前尝试多匹配一个字符时，假设欲走到$y$节点，则在$y$的线段树中查询$[l+cnt,r]$区间和是否为正，是则前进否则沿着后缀链回退，这里可以一个个单位长度衰减$cnt$，直到查询区间和为正，或者长度回退到了$pre[x]$，继续操作
  - 事实上这里也无需一个单位衰减，可以减少一段，我们可以在线段树上查询$\le r$的最大$pos$使得该点线段树值为$1$，即可以快速算出应该衰减多少才能继续前进
  - 计算答案与弱化版并无不同

41.https://www.lydsy.com/JudgeOnline/problem.php?id=5337

注：基础题，给定$k$个字符串集合，从每个中选一个字符串按顺序顺次拼接，问有多少方法得到字符串$S$；考虑一个简单的$dp$，令$f[i][j]$表示考虑了前$j$个字符串集合，匹配到下标$i$的方案数；转移考虑枚举第$j+1$个集合中的串，使用字符串$hash$check是否可转移即可；也可以用后缀自动机，处理出每个串出现在哪些下标，不过有些麻烦

42.https://www.lydsy.com/JudgeOnline/problem.php?id=4502

注：中档题，给定$n$个字符串，问选择它们的两个前缀(可以相同)可以拼接成多少个不同的字符串；考虑一个实际的串方案，由于可能有多个拼接方案得到，故可要求第二个拼接串的后缀必不包含任何其他可选前缀串；则直接用这些字符串构造广义后缀自动机，注意第一个串的选择可以是任意前缀，第二个串只能是不含别的前缀的前缀；分别统计一下，乘法原理即可(第二个串做一次树$dp$)

43.https://www.lydsy.com/JudgeOnline/problem.php?id=4180

注：难题，给定字符串$T(|T| \le 10^5)$，只含$4$种字符，定义一个字符串$s$的权值$v(s)$表示将$s$最少可以分成几段，使得每段都是$T$的子串，在字符集意义下求长度为$n(n \le 10^{18})$的所有串$s$中权值的最大值；容易让人联想到矩阵快速幂，但是$|T|$很大，显然矩阵规模不会是关于串长或者自动机节点个数的；发现字符集很小，联想到构造$4*4$的矩阵。先分析一些性质：

- 首先考虑给定$s$时，$v(s)$如何算：可以贪心，每次不到万不得已绝不切刀，即直接当前字符串恰好不是子串的时候，才开始分段。证明：考虑一种最优方案与此方法切法不同，取其第一次不同的位置$x$，紧接着的一道为$y$，我们的方法切在$x',y'$，显然$x<x'$，从而$y\le y'$，否则$(x,y]$为$T$子串，而$y>y'$，这与我们的切割贪心方法矛盾。故显然$x$可以调整到$x'$，因为两边仍然为子串。证明完毕。
- 考虑答案$ans(n)$关于$n$单调，只需证明$ans(n)\le ans(n+1)$。证明：考虑长度为$n+1$的一种最优切割方案，若最后一个字母单独一段，则$ans(n) \le ans(n+1)-1$；否则，考虑将最后一个字母强行截断，故$ans(n)\le ans(n+1)$，因为已经得到了$ans(n+1)$的一种切割方案，最优方案不会多于此。
- 我们二分$k$表示段数，每次求用$k$段可以拼成的最小长度$n(k)$，与题目给的$n$比较；我们的相邻两段满足我们的贪心，即上一段字符串加上下一段的首字符不是$T$的子串，且最后一段总是一个字母。当我们得到$n(k) \le n,n(k+1) > n$时，$k$就是答案。因为这说明最后一段的实际长度总是可调的，使得恰好取到$n$。
- 考虑相邻两段的转移，令$f[x][y]$表示上一段以$x$字符开头，后面欲接字符$y$，而接完不是$T$子串的上一段的最短长度。$n(k)$就是以$f$为邻接矩阵的有向图(边带权)上，经过点数恰好为$k$的最短路径(点可重复走，重复算多个点)$+1$。而这显然是矩阵$f^{k-1}$中的最小值，矩阵乘法使用$(min,+)$结构，注意答案$+1$。
- 考虑使用后缀自动机求$f[x][y]$，构造$T$的$SAM$，对每个点$x$处理$dp[c][x]$表示从空节点起第一步必须走$c$字符走到$x$节点的最短路。这是$DAG$上的$dp$，转移枚举入边取$min$即可。最后扫描每个节点$x$，对其没有的出边字符$p$，用$dp[c][x]$更新$f[c][p]$。

44.https://www.lydsy.com/JudgeOnline/problem.php?id=5408

注：难题，在线广义后缀自动机+$LCT$，$n$个串，$4$种操作：某个字符串后加字符，询问$x$字符串在$y$次操作后在当前$z$字符串中出现次数，询问当前所有串本质不同子串数目，求给定串$T$在最多的一个串中的出现次数；首先在线维护$parent$树使用$LCT$，记录每次操作后每个串那时候的对应节点编号，每个节点开长度为$n$的数组$cnt$表示该节点在当前的$n$个串中的出现次数，直接维护本质不同子串数量；$2$操作，注意到询问是在当前$z$串中，故插入每个字符时，照常打标记即可，树链加，单点查询，由于已经保存了每个串任意时刻的节点，故直接提取$x$在$y$次操作后的所在节点，下放标记，直接得到答案；$4$操作，运行串$T$，得到对应节点，下放标记，直接提取$cnt$，取最值得到答案。

45.https://www.lydsy.com/JudgeOnline/problem.php?id=4327

注：模板题，给定母串$S$，每次询问模式串$T$，问$T$的最长前缀长度在$S$中出现；在$SAM_S$中运行$T$，直到失配即可；本题亦可用$trie$图做，亦较容易

46.http://www.lydsy.com/JudgeOnline/problem.php?id=4310

注：中档题，贪心+$SAM$，给定$k$和字符串$S$，求将串$S$分成至多$k$段，使得每段字典序最大的子串中字典序最大的串字典序最小，输出该串。$--k$转化为切的刀数，考虑从后缀自动机的起点开始走，每次从大到小沿着转移链走，尝试转移，假设尝试走到$y$点，若$k \ge cnt[y]$，则不走到$y$，且$k-=cnt[y]$；直到$k<cnt[y]$则走过去，表示无法割断这个子串；如果无路可走，则表示找到答案，当前走出的转移路径构成的字符串就是答案。

47.http://acm.hdu.edu.cn/showproblem.php?pid=6704

注：中档题，$SAM$+线段树合并+树上倍增；给定字符串$S$，多次询问$S[l_i,r_i]$在$S$中的第$k_i$次出现的初始下标；首先在自动机上确定子串$S[l,r]$，只需要从$S[1,r]$这个前缀对应的节点沿着$parent$树上倍增，锁定节点$x$；树上线段树合并求出$endPos$集合，在该点对应的线段树上查询$k$小值即可。

48.http://acm.hdu.edu.cn/showproblem.php?pid=5769

注：基础题，求字符串$S$中必包含给定字符$c$的本质不同子串个数；自动机上的一个节点对应三元组$(l_1,l_2,r)$，故等价于求$S$中下标$\le r$中第一次出现的$c$的下标，从左到右顺序扫描一遍即可预处理出；据此稍加讨论即得到该节点对答案的贡献。

49.http://acm.hdu.edu.cn/showproblem.php?pid=6194

注：模板题，求$S$中恰好出现$k$次的本质不同的子串个数

50.http://acm.hdu.edu.cn/showproblem.php?pid=6405

注：难题，给定$n \le 10^4$个字符串$S_i$，权值为$V_i$，构造一个串$T$，若$T$出现在$S_i$中，则累乘$V_i$，令乘积为随机变量，求随机生成长度$\le m$的串$T$对应的随机变量值的数学期望；注意多次询问$m_i$。

- 前置问题：(树链并操作)给定一棵树，选中部分节点$x_i$，将他们到根的树链的并整体修改(如增减)，只需要将$x_i$按照$dfs$序排序，逐个添加修改，每次$x_i$打正标记，且在$father[lca(x_i,x_{i-1})]$处打负标记，最后树$dp$叠加子树标记和即可
- 原问题：直接对所有串构建广义$SAM$，注意每种本质不同子串均有贡献，其他则均无贡献，用类似于上面的方法，求出每个节点的贡献；然后一个节点对长度$[l_0,l_1]$产生自己的贡献(区间加)；这里可以差分一下，最后求前缀和即可快速回答所有询问(分母为所有可能串个数之和，等比数列求和)。
- 另一种方法计算每个节点贡献：每一次转移，直接每次暴力向后缀链上回退，打标记产生自己这个串的贡献
  - 复杂度分析：若所有串总长为$n$，注意到一个串长为$m$的串单独这样暴力做，复杂度不超过$m^2$，同时也不会超过$n$；故对于$m \le \sqrt{n}$总复杂度$=\sum m_i^2 \le \sqrt{n} \sum m_i=n\sqrt{n}$；对于$m>\sqrt{n}$的所有串，每个复杂度不超过$O(n)$，个数不超过$O(\sqrt{n})$，总复杂度$\le n\sqrt{n}$。

51.http://codeforces.com/problemset/problem/700/E

注：难题，给定长度为$n$的字符串$S$，求其一个最长的子串序列$s_i$，满足$s_i$在$s_{i+1}$中至少出现两次。

不盲目的引入任何数据结构，我们先分析一下问题的性质：

- 若串$a$在串$b$中至少出现两次，则$a$的任何子串(包括后缀)，也在$b$中至少出现两次

- 最优方案一定分布于某一条后缀链上，即$s_i$必为$s_{i+1}$的后缀；证明：考虑调整法，假设某个最优方案不是这样的，取其第一次违背这个性质的第一对相邻子串为$s_i,s_{i+1}$，其中前者不是后者的后缀；我们大可以从$s_{i+1}$末尾删去一些字符，即收缩使其以$s_i$为后缀，显然$s_i$仍然至少在$s_{i+1}$中出现两次，且$s_{i+1}$至少在$s_{i+2}$中出现两次(由上一条性质)；故这样调整答案不变，且符合我们性质
- 有贪心性质，即一条后缀链上，从短到长，能取即取；证明：与上面类似，找到第一个不符合的，从左边删除字符调整
- 后缀自动机上的一个节点代表的诸多串存在竞争关系，即最多只能选一个；证明：由$SAM$上节点性质决定，若短的在长的中出现多次，即除了后缀关系，还存在出现下标，则放入原串中看$endPos$集合，此二者不再一致，矛盾
- 同一个节点可以默认取最长的串，如果可能的话；同样可以调整法证明：考虑一个最优方案，从长到短的调整，每个串调整到所在节点最长的串；如果不行，则我们取了某个节点最长串$s$，且前面一个尝试从$t_1$调整到$t_2$失败了($|t_1|=|t_2|-1$)，意味着$t_1$在$s$中恰好出现了两次，而$t_2$不行，超出了一个长度；考虑在原串中每一次$s$的出现，由于$t_1$完整包含在$s$中，而$t_2$与$t_1$形影不离(在同一个节点中)，故可推断$s$之前必存在一个字符且相等，这蕴含着$s$不是自己节点中的最长串，存在一个比自己长度多$1$的串，$endPos$集合与自己相同，矛盾
- 结合以上性质，我们只要在$parent$树链上贪心即可，每次只考虑当前节点的最长串选不选；自上而下贪心，能选即选；用线段树合并求出$endPos$集合，判定$A$选了之后，$B$是否可选，其中$A$为$B$后缀，可以用：线段树查询$[pos[B]-len(B)+len(A),pos[B]-1]>0$判定；令$f[x]$表示根到$x$节点可以选择的最多的串的个数，$top[x]$表示上一次选择了哪个点的最长串；如果决定选择$x$，则$f[x]=f[top[father[x]]]+1,top[x]=x$；否则$f[x]=f[top[father[x]]],top[x]=top[father[x]]$。若$father[x]=$根，则$x$是必选的，$f[x]=1$。答案为$f$ 。

52.https://loj.ac/problem/6031

注：难题，给定字符串$S$，令$f(S,W,l,r)$表示$W[l..r]$在$S$的出现次数；给定$m$个区间$(l_i,r_i)$；$q$次询问，每次询问$(W,a,b)$表示回答$\sum_{i=a}^bf(S,W,l_i,r_i)$；数据范围：$\sum |W|\le 10^5$。

- 考虑个简单的问题：现在只有一次询问，求$f$如何求。构造$SAM_S$，预处理出现次数$cnt$，运行$W$(带回退)，直到下标$r$，即锁定了自动机上的节点$x$，沿着后缀链以$r-l+1$长度为依据倍增，找到$W[l..r]$所在节点$y$，提取出现次数即可。回答询问复杂度$O(|W|+logn)$。
- 若沿着上述思路，回答原题一次询问，即逐个考虑每个区间$(l_i,r_i)$，则倍增须做$O(m)$次，复杂度达到$O(|W|+mlogn)$。于是总复杂度高达$O(\sum |W|+qmlogn)$，考虑这个复杂度，发现当$q$比较大时，无法承受；故考虑对$q$进行分类，若$q$较大采用另一种算法，且往往是某种暴力的版本。
- 有了分类的意识，我们寻找一些特殊的限制，在一些字符串题目中，长度之和为一个关键的制约量。令$F=\sum|W|=q|W|\le 10^5$，这蕴含着在$q>\sqrt{F}$时，$|W|\le \sqrt{F}$，即$|W|^2\le 10^5$。故我们尝试设计关于$|W|$的暴力。对串$W$，我们运行在每次转移后沿着后缀链暴力爬，复杂度为$O(|W|^2)$，注意到这已经覆盖了所有的询问区间$(l,r)$，且由自动机上的节点编号我们知道出现次数，故只需要知道询问区间$(l_a,r_a)$到$(l_b,r_b)$中即时间位于$[a,b]$中的区间恰为$(l,r)$的个数。而这可以使用$map<pair<int,int>,vector<int>>$，得到顺序存放时间的$vector<int>$，二分即可。时间复杂度$O(logm\sum |W|^2)\le O(logm \sqrt{F} \sum |W|)=O(F\sqrt{F}logm)$；注意即使$W$不等长，也是如此。
- 总结：先考虑一种算法，仔细分析复杂度，对一些强制约量之间分类讨论

53.https://loj.ac/problem/6173

注：中档题，本质不同子矩阵，$hash$+$SAM$，$n,m\le 100$；预处理每行区间$hash$值，枚举$(L,R)$表示两个列号，称为一个串的编号，枚举每行，提取$[L,R]$$hash$值，作为串字符，插入到广义后缀自动机中，故共插入了$O(m^2)$个长度为$n$的串，取本质不同子串个数即可。

54.https://loj.ac/problem/6041

注：难题，给定一个长度为$n$的串$S$，令$S_i$为其长度为$i$的前缀；每次询问$(l,r)$，表示$\forall i,j \in [l,r]$，$i<j$，$lcs(S_i,S_j)$的最大值；由于是最大值，对应着$parent$树上深度较大的点。

- 先考虑个简单的版本，如果就一个询问，那么就将这些前缀打上标记，然后自下而下做树$dp$，在至少有两个标记的节点中，取最长长度最大的即可。或者按照$dfs$序$sort$一下，检查相邻的两个点，因为根据贪心，$dfs$序相近的点对其$lca$节点深度较大。
- 多个询问时，无法直接采用上面的想法。从全局的角度看，一对$lcs$值是固定的，仅因为询问区间不同而答案不同。我们尝试预处理出$(p,q,v)$三元组表示$S_p$与$S_q$的$lcs$值为$v$，于是这相当于一些平面带权的点；一次询问，转化为平面区域矩阵点权最大值；这是经典的扫面线+离线树状数组的问题。
- 由于$(p,q,v)$数目很多，尝试在处理的时候是否可以贪心的去掉一些不可能作为答案的。考虑$parent$树上的$set$启发式合并(存放下标)，求出$endPos$集合，这集合本质上就是一系列前缀。我们先枚举$v$，本质的讲，相当于枚举自动机上的点$x$，所有的三元组来自于自己的待合并的儿子；假设我们启发式合并欲将$B$合并到$A$中，先查询构造三元组，对每个$t\in B$我们在$A$中找到其下标前驱后继，不妨设为$c_1,c_2$；则三元组$(c_1,t,len(x)),(t,c_2,len(x))$即是其贡献，其他的三元组由于$v$值相同，可被贪心的替代；查询结束后，将$B$并到$A$中。故我们得到的三元组数量是正比于启发式合并复杂度的，$O(nlogn)$。
- 总结：这类区间查询，很容易和平面矩形点对的一些问题相对应

55.https://open.kattis.com/problems/firstofhername

注：难题，$2019WorldFinal$

56.https://codeforces.com/gym/100962    $D$题

注：难题，$SAM$+线段树做法











##【8】回文树/回文自动机/Eertree



测模板用模板题：

http://acm.hdu.edu.cn/showproblem.php?pid=3948



笔记备注：

1）一篇文章：http://codeforces.com/blog/entry/13959

加速dp转移(有专门模板和论文、题目)：

https://blog.bill.moe/dp-with-palindrome-notes/

http://codeforces.com/blog/entry/19193

阅读论文：$《EERTREE: An\space Efficient\space Data\space Structure\space for\space Processing\space Palindromes\space in\space Strings》$

见仓库自带文献集

2）长度为$n$的字符集大小为$\sigma$的随机字符串，其本质不同回文子串期望个数为$O(\sqrt{n\sigma})$

3）$\theta-palindrome$定义为这样一种回文串$s=s_1s_2..s_{n-1}s_{n}$，其对称位置的字符在$\theta$意义下等价；$\theta$是将字符映射到字符的函数，即$\theta(s_1)=s_n,s_1=\theta(s_n)...$；$\theta^2$是字符集上的恒等变换。只要重新定义模板中的字符比较方式，即可构造$\theta-Errtree$。当然，有时候等价函数将字符集进行了分划，其思想是一样的。

4）几项技术：$halfLink$，$quickLink$，$directLink$，$seriesLink$；这些与$PAM$的回退和优化$dp$的关键思想密切联系

5）$rich$字符串搜索和计数

- $rich$字符串$S$是指含有尽可能多的本质不同回文子串，亦即$|S|=n$，$S$含有严格$n$个不同回文子串

- $rich$字符串的任何前缀任何是$rich$的，因为每个前缀的最长回文后缀在前面都是没有出现过的
- 使用支持回退功能的$PAM$进行暴力搜索

6）支持双端插入的$PAM$

- 思想性：利用$fail$树上回文后缀与前缀关系的对称性，$last$节点思想实质
- 功能性
  - 支持动态在线维护本质不同回文子串个数，所有回文子串个数等
  - 支持在线构造$fail$树，节点染色，节点求对应方案；$fail$树在插入字符顺序不同时是同构的，即只有编号不同的差异
- 局限性
  - 无法高效维护前缀后缀下标和自动机上节点的对应同步，故无法快速遍历某个前缀对应的$fail$链
  - 对每种本质不同回文子串，即每个节点，无法高效精确获知其最左和最右出现下标，但可以知道其某一次出现下标
- 安全性
  - 字符数组指针$L,R$的设计($L=1,R=0$)，容易越界
  - 初始临界字符$s[0]=-1$，此处应该扩展为$s[0]=s[1]=-1$，在指针$L,R$，移动过程中临界值$-1$务必记得向两边推送；即任意时刻字符串结构为$[L,R]$且两边紧贴一个$-1$
- 扩展性
  - 可以$O(n)$维护每个前缀的最长回文后缀对应节点编号，复杂度太高

7）可持久化$PAM$

8）优化$dp$与回文切割/$k-factorization$：在线算法$O(nlogn)$

- 询问字符串$S$是否可以$k-$回文分解，等价于询问最小的奇数段和偶数段回文分解

- $palindromic\space length$是最小的无条件回文分解的段数$PL(S)$，使用带$seriesLink$的$PAM$，可以轻松做到$O(nlogn)$，但这未必是最优的复杂度；注意一个$series$顶部节点的$dp$值存放的是关于一系列下标集合的$ans$值的综合，而不是直接关于节点的或者关于串的信息

- $|PL(Sc)-PL(S)| \le 1$，在字符串后追加一个字符，$palindromic\space length$最多变化$1$

- 一条$suffix$链路最多含有$seriesLink$  $O(logn)$条

- $series$链中，顶部节点$u$，$v=link[u]$，则$v$在$u$中严格出现两次，即前后缀

- 若$u$是$S[1..n]$的某个$leading$节点，则$link[u]$是$S[1..n-diff[u]]$的$leading$节点，$leading$表示是某个$series$顶部元素

- 转移时，注意$series$链上的$dp$值，从$dp[link[u]]$中取出，结合长度最小的元素对应的本次下标答案

- 简要模板：

  ```c++
  int getMin(v)
  	dp[v] = ans[n - (len[seriesLink[v]] + diff[v])] //last
  	if (diff[v] == diff[link[v]])// non-trivial series
  		dp[v] = min(dp[v], dp[link[v]])
  	return dp[v] + 1
       
  for (i=1; i<=n; ++i)
  	ans[i] = inf
  	for (v = maxSuf[i]; len[v] > 0; v = seriesLink[v])
  		ans[i] = min(ans[i], getMin(v))
  ```

- 基本图示

  <img src="\pic\字符串\字符串1.JPG" alt="字符串1"  />

- 关于时间复杂度：有人指出在平均意义下$O(n)$，最坏情况下$O(nlogn)$，最坏情况的构造为：取$Zimin \space Word$长度为$n$的前缀，导致$series$链长很短，但是数量很多

9）广义回文自动机$PAM$

10）基于$trie$的广义$PAM$










题目：

1.http://acm.hdu.edu.cn/showproblem.php?pid=4426

注：基础题，给定每个字母权值，一个回文串权值为前半段字母权值之和；给定字符串$S$，多次询问，询问权值第$k_i$大的回文子串的权值；构造出回文自动机，求出本质不同回文串出现次数和权值；排个序就可离线回答。

2.http://codeforces.com/gym/100548/attachments $G$题

注：基础题，给定两个字符串$S,T$；求公共回文串对的下标数量，即求$(a,b,c,d)$数量即$S[a..b]=T[c..d]$且是回文串；求$"S\#T"$的回文自动机，对每种本质不同回文串求个数，将两个串中的个数相乘即得贡献。

3.http://acm.timus.ru/problem.aspx?space=1&num=1960

注：模板题，给定串$S$求其每个前缀的本质不同回文串个数

4.http://www.tsinsen.com/A1280

或者http://www.lydsy.com/JudgeOnline/problem.php?id=2565

注：基础题，给定串$S$，求一个最长的双回文子串$t\in S$，使得$t$可以被分成两段，每段是回文串；等价于求$max_i\{f_i+g_{i+1}\}$，令$f_i$表示以$i$下标结束的最长回文后缀长度，$g_i$表示 $i$下标开头的最长回文前缀的长度

5.http://www.tsinsen.com/A1255

或者http://www.lydsy.com/JudgeOnline/problem.php?id=2160

注：模板题，求长度为奇数的回文串中按照长度从大到小排序前$k$大的长度之积；处理出每种长度的回文串个数$cnt[x]$

6.http://www.tsinsen.com/A1393

或者http://codeforces.com/problemset/problem/17/E

注：中档题，给定串$S$，任选两个下标不全相同的回文子串，使其下标区间相交，求方案数；补集转化，正难则反，先求所有回文串个数$cnt$，就是每个前缀所对应节点的深度$dep$之和；用$\binom{cnt}{2}-$下标不相交的方案数；对于一对下标不相交的方案，可以将贡献加到右边的串的起点处，这样贡献不会重复叠加；令$f_i,g_i$分别为以下标$i$结束和开头的回文串个数，$F_i$为$f_i$前缀和；则$ans=\sum_i{F_{i-1}*g_i}$

7.http://acm.hdu.edu.cn/showproblem.php?pid=5394

注：中档题，$trie$树上的$PAM$，支持可撤销/回退字符的$PAM$；给定一棵$trie$，点带字符，求本质不同回文串$s$的出现次数与长度乘积之和，注意字符串只算竖直向下方向的；与$trie$上的$SAM$类似，$PAM$更少了一些禁忌，因为其一个节点只代表一个回文串；每插入一个字符，需要指明在哪个父节点的基础上插入何种字符即可；然后求出出现次数，扫一遍所有节点叠加贡献即可。注意到问题本质上就是求所有回文串长度之和。也可以使用带回退功能的$PAM$，就是递归的时候插入字符，回溯的时候删除字符(弹栈)；这样每个时刻的$PAM$表达的是根到当前节点$x$的有向字符串路径，只需要叠加当前节点$x$的贡献即可，它是$trie$上以$x$为末端点的回文后缀长度之和，亦即$fail$树上$x$到根的串长之和；$dep[x]=dep[fail[x]]+len(x)$动态维护即可。

8.http://www.lydsy.com/JudgeOnline/problem.php?id=3676

注：模板题，对回文子串求出现次数*长度的最大值。

9.https://www.codechef.com/problems/PALPROB

注：中档题，给定字符串$S$，求其所有子串的回文指数之和；回文指数是衡量回文性的程度，非回文串的回文指数为$0$，单个字符回文指数为$1$，回文串的回文指数为其严格前一半回文指数$+1$。

- 从算贡献的角度来说，我们只需要求出每种本质不同的回文子串的回文指数即可；故在$fail$树上做$dp$。$dfs$之，在根到当前节点$x$的路径上，追查是否存在节点$y$，满足$len(x)/2=len(y)$，则$dp[x]$从$dp[y]$转移得到。
- 有一种称之为$half$指针的技术：与$fail$指针类似，联系其构造过程，如果不懂基本原理，建议复习一下。我们新建节点$y$，发现节点$x$沿着$c$方向转移到$y$；故我们根据$fail[x]$构造$fail[y]$，即从$t=fail[x]$不断沿着$fail$链回退，直到可以追加字符$c$，此时的节点转移一步得到$fail[y]=go[t][c]$；$half$指针是类似的，不过令$t=half[x]$，然后不断回退，直到可追加字符$c$，转移一步得到$t$；注意当$t$长度不符合要求时，还需要继续沿着$fail$链跳到第一次满足长度要求；这样得到$half[y]=t$；时间复杂度仍然为$O(n)$的。这个题目每个节点的$dp$值直接从其$half$指针处转移过来即可。
- 由此联想到，其他的一些由长度的比例上界控制的指针，也可以自己设计并维护，都可保证为$O(n)$的。

10.http://acm.hdu.edu.cn/showproblem.php?pid=6599

注：基础题，子母回文串分布，求出本质不同回文串的数量分布（求每种回文串的个数），然后对每种快速 $check$ 一下，叠加答案即可；可以用 $manacher$ ，后缀自动机，回文自动机，字符串 $hash$ 多种做法实现。

11.https://nanti.jisuanke.com/t/30998

注：基础题，给定一个数字串，求所有本质不同子串的数值之和模$1e9+7$；$PAM$+字符串$hash$

12.http://www.lydsy.com/JudgeOnline/problem.php?id=2084

注：中档题，给定长度为$n$的$01$串，求反对称的子串个数；反对称是说除了中心之外该子串正数第$i$个字符和倒数第$i$个字符相等。该题有非常多的做法，后缀自动机，二分，字符串$hash$，马拉车，回文树等。

这里介绍回文树做法，我们修改回文串的定义，要求对称的位置不等才算匹配；这样稍加修改之后，构造出的$PAM$中每个节点对应本质不同反对称子串；统计出现次数，扫描$len$为偶数的个数和即可。

13.http://www.lydsy.com/JudgeOnline/problem.php?id=2342

注：基础题，求最长双倍回文子串长度，即可写成$ww^Rww^R$形式；首先这是个回文串，需要$check$长度是否为$4$的倍数，且是否存在长度一半的回文后缀；而这可以在$fail$树上$dfs$之即可，每次记录根到当前点$x$有哪些长度，检查$len(x)/2$即可；递归时打标记，回溯时撤销。

14.http://acm.timus.ru/problem.aspx?space=1&num=2061

注：打表题，给定$n\le 61$，对$i \le n$，求长度为$i$的$01$串中严格含有$i$个本质不同回文串的个数。

15.http://www.lydsy.com/JudgeOnline/problem.php?id=3160

注：难题，$FFT$+马拉车/回文树；给定只含$a,b$的字符串$S$，首先用马拉车或者回文树求所含回文子串个数；接下来题意转化为：求非空下标子序列个数，满足：该下标子序列本身轴对称，且字符也轴对称。

- 考虑一个对称轴$k$，满足下标对$(x,y)$关于$k$对称，即$x+y=k$($2k$被简写为$k$)；对于此对称轴，我们计算贡献，本质上就是要计算下标对$(x,y),x<=y$的数量满足$S[x]=S[y]$且$x+y=k$，令为$cnt[k]$个，则有贡献$2^{cnt[k]}-1$；下面关键在于求$cnt[k]$
- 令$A_a[i]=(S[i]==a),A_b[i]=(S[i]==b)$；故$cnt[k]=\sum_{c \in \{a,b\}}\sum_{x+y=k\\1 \le x \le y \le n}A_c[x]*A_c[y]$；先不考虑$x\le y$，则上式就是一个普通的卷积公式，使用$fft/ntt$获得；然后调整一下偏序的限制即可。
- 最后叠加贡献即可，对称轴范围为$k \in [2,2n]$，共$2n-1$个取值；$ans=\sum_{k=2}^{2n}(2^{cnt[k]}-1)$

16.https://nanti.jisuanke.com/t/41389

注：基础题，给定字符串$S$，求所有回文子串的值之和，值定义为该子串中出现的不同字符的个数(只含小写英文字母)；对$PAM$上的每个点，计算出现次数和一个出现下标，即得到一个区间$[L,R]$；逐个字符判断是否出现即可，该节点贡献为出现次数乘出现不同字符数。

17.http://www.lydsy.com/JudgeOnline/problem.php?id=4044

注：中档题，给定字符串$S$，要求从空串得到$S$，每次操作可以在某一端追加一个字符，或者将现在串的反串放在某一端；令$f(x)$表示合成$x$这个节点对应串的答案；容易想到，先合成某个回文子串，然后逐步扩充得到$S$，这意味着：$ans=min_{x\in Psub(S)(f(x)+n-len(x))}$；如果$len(x)$为奇数，显然$f(x)=len(x)$，因为翻转操作只能得到偶数，意味着奇数只能逐步扩充；如果$len(x)$为偶数，令$x=TT$，考虑一定是先合成$T$，再翻转一次；令$T=T'c$，一种方法是先合成$T'$，再追加$c$得到$T$，即$f(x)=f(y)+1$，其中$y$表示串$T'$；另一种方法是先得到$T$的回文后缀，然后扩充到$T$，我们需要求$x$的不超过长度一半的最长回文后缀节点$z$，这里可以使用前面讲的$half$指针，$f(x)=f(z)+len(x)/2-len(z)$；注意到没有别的方法了，因为两种分别是从两端考虑的，其余可能均可调整为先考虑一端。$f(0)=1,f(1)=-1$，空的偶回文节点可以蕴含一次翻转操作，从小长度到大长度更新，只要沿着节点编号更新即可。

18.http://acm.timus.ru/problem.aspx?space=1&num=2057

注：难题，思维题，不需要使用$PAM$；给定字符串$S$，求最大最小非回文切割段数；先判断无解情况，必是三种情况之一：$aaaa...aaa$，$aaabaaa$，$abababa$；最小答案一定就是$1$或者$2$，判断$S$是否是回文串即可；最大使用$dp$，令$f[i]$表示前$i$个字符的答案，枚举上一段的末尾转移过来，复杂度是$O(n^2)$；$f[i]=max(f[j])+1,j<i$且$S[j+1..i]$是有解的，也就是说不能是无解的三种情况；考虑第一种，指出了$j$的一个可能上界；第二种，指出了$j$的一个不可以取的值；第三种，指出了$j$的一个可能上界(可能要分奇偶讨论)；通过分类讨论，维护$dp$前缀最大次大值就可$O(n)$转移。

19.http://acm.timus.ru/problem.aspx?space=1&num=2058

注：难题，最小回文切割问题，$PAM$优化$dp$转移；有模板

20.http://acm.timus.ru/problem.aspx?space=1&num=2059

注：基础题，统计有多少个回文串在$A$中出现次数大于/等于/小于在$B$中的出现次数；考虑广义回文自动机，将两个串$A,B$插入；统计两个串的分布，扫描每个点计算贡献。

21.http://acm.timus.ru/problem.aspx?space=1&num=2060

注：中档题，求三元组$(i,j,k)$数量，满足$s[i..j],s[j+1..k]$均为回文串；考虑对每个位置$i$求$f_i,g_i$表示以此为起始结束下标的回文串个数，之后枚举分界线$j,j+1$，简单的乘法原理即可。

22.http://codeforces.com/problemset/problem/906/E

注：难题，$PAM$优化$dp$转移；给定两个字符串$A,B$，选择$A$的若干个不交的子串，分别翻转，使得$A=B$，求需要被翻转的最少子串个数或者指出无解，构造方案。注意若字符串$s$的反串$s^T=t$，则将$s,t$穿插构造的新字符串是回文的，故原题意转化为将$S=A$穿插$B$，分成若干段长度为偶数的回文串(回文分解)，使得长度$\ge 3$的段的个数最少。直接使用偶回文串最小分解，最后添加转移$dp[i]=min(dp[i],dp[i-2]),if \space !odd(i)$。因为假设$dp[0..i-1]$均求出且正确，现在计算$dp[i]$可能错误考虑了长度为$2$的，多加的转移可以修正之。

23.http://acm.timus.ru/problem.aspx?space=1&num=2044

注：难题，回文切割判定问题，对$i \in [1,31]$回答给定串$S$是否可被分成$i$段，每段是回文串；$PAM$优化$dp$转移；

24.http://www.spoj.com/problems/IITKWPCE/

注：中档题，最小回文切割问题，由于串长较小可以平方算法，或者用$PAM$优化$dp$转移

25.http://acm.timus.ru/problem.aspx?space=1&num=1635

注：中档题，与上题一样，须构造方案

26.https://ac.nowcoder.com/acm/contest/886/C

注：难题，给定字符串$S$，求二元组$(a,b)$的个数，满足$a,b \in S$且$a,b$是$S$的不同回文子串，且$a \in b$即$a$在$b$中出现

- 考虑固定$b$，计算$a$，如果可以求任意区间本质不同回文子串个数，那么我们只要对自动机上的每个点求一个方案，得到区间之后，即得到了答案，这是很容易的；下面采用另外的思路：
- 考虑固定$b$，若$a$是$b$的一个回文子串，则我们将$b$不断收缩(每个时刻同时删除首尾字符)，则$a$必然是某个时刻$b'$的一个回文后缀；但是注意，$a$可能出现多次，意味着可能在多个时刻是$b'$的回文后缀
- 收缩$b$的过程，等价于追溯$b$在回文树(只看转移边)的祖先，而回文后缀即对应着节点的$fail$链上祖先；故上述所求，等价于在回文树上根到点$b$的路径上的所有点在$fail$树上的树链并的点数
- 考虑分别对两棵树$dfs$，某个时刻对树链并上的点染色，考虑维护，递归的时候，在点$x$沿着$fail$链跳转，一路染色，直到遇到已染色点，注意最多多染两个(包括自己)，证明与一个字符串后追加一个字符，最多增加一个本质不同回文子串(即新的最长回文后缀)思路一样；回溯的时候，撤销操作，即操作可存入栈中，回溯弹栈；不断维护染色节点个数即可
- 叠加每个节点$b$对应的染色节点个数，时间复杂度为$O(|S|)$；注意$PAM$中只有字符集转移边用$map$存储，才是$O(|S|log\sigma)$复杂度，但是我们常常在字符集不大的时候，直接开数组存储，是没有那个$log \sigma$的因子的
- 思考问题如果改成具体的下标，即$(l,r,L,R)$四元组个数，满足$S[l..r] \in S[L..R]$且二者均为$S$的不同回文子串，算法过程如何变化

27.https://codeforces.com/problemset/problem/932/G

注：难题，给定字符串$S$，求切割方案数使得其被切割成偶数$k$段$S=p_1p_2p_3..p_{k-1}p_k$，且$p_x=p_y,x+y=k+1$，此称之为偶段式回文切割；我们首先分析并转化问题：

- 注意到正中间一刀是必切的，亦即可以认为左半边和右半边长度相等；这蕴含着$|S|$若为奇数则无解
- 考虑将右半边字符倒序穿插在左半边字符中，即令$T=S_1S_nS_2S_{n-1}S_3S_{n-2}...S_{n/2}S_{n/2+1}$，$|S|=|T|$；我们可以证明对$S$的任何一种满足题意的切割方案与$T$的每段均为偶数长度的回文切割方案一一对应
  - 充分性：取题设方案，左右折叠穿插，即得到$T$的一种切割，注意每段均为偶数长度的回文串
  - 必要性：取$T$的一种切割方案，每段为偶数，每段下标为奇数的在左边，偶数的倒序对称到右边，显然镜像的构造了一种$S$的原来切割方案，注意到段数一定是偶数
- 字符串$T$的偶回文切割方案数可以使用$PAM$优化$dp$，偶数则只需要屏蔽掉奇数长度的贡献即可；注意不用修改模板，只需要在更新$dp[i]$值时判断$i$从而确定是否需要更新

28.http://acm.hdu.edu.cn/showproblem.php?pid=5421

注：模板题，双端插入$PAM$，维护本质不同回文子串个数和所有回文子串个数

29.http://www.lydsy.com/JudgeOnline/problem.php?id=5384

注：模板题，区间本质不同回文子串计数









##【9】后缀仙人掌

##【10】后缀平衡树

##【11】最小表示法

1.https://www.lydsy.com/JudgeOnline/problem.php?id=2882

注：基础题，字符串的循环同构字典序最小的串，最小表示法模板题

##【12】可持久化回文自动机/后缀自动机

##【13】Border Tree

- 弱周期引理和周期引理
  - 弱周期引理：$p,q$是$s$的周期，$p+q \le |s|$，$gcd(p,q)$也是$s$的周期
  - 强周期引理：上述条件可加强为：$p+q \le |s|+gcd(p,q)$
- 匹配位置定理
  - 字符串$u,v$满足$2|u| \ge |v|$，则$u$在$v$中的出现下标构成一个等差数列
  - 若此等差数列至少含$3$项，其公差$d$等于$per(u)$，即$u$的最小正周期
  - 在此时，$per(u) \le |u|/2$
- $Border$结构
  - 字符串$s$的所有长度$\ge|s|/2$的$Border$长度构成等差数列
  - 将$s[1..n]$的所有$Border$按照长度分类：$x \in [1,2),[2,4),[4,8),...,[2^{k-1},2^k),[2^k,n)$
    - 若$x \in [2^k,n),2^k \ge n/2$，成等差数列(已述)
    - 若$x \in [2^{i-1},2^i)$，也成等差数列
      - 对于$|u|=|v|$，令$PS(u,v)=\{k:pre(u,k)=suf(v,k)\}$
      - 令$LargePS(u,v)=\{k \in PS(u,v):k \ge |u|/2\}$
      - $LargePS(u,v)$构成等差数列
      - 这个分类中的$Border$就是$LargePS(pre(s,2^i),suf(s,2^i))$
  - $s[1..n]$中的所有$Border$可按长度分成$O(log|s|)$段，每段一个等差数列
- 子串周期查询
- 最小回文拆分及其扩展
- 子串最小后缀查询
  - 给定字符串$s[1..n]$，每次询问子串$s[l..r]$的最小后缀，令为$minsuf(l,r)$
  - 令$s[p..n]$是$s[i..n]$的最小者，$i \in [l,r]$，则$minsuf(l,r)=s[p..r]$的最短非空$border$
  - 令$m=2^k$，且$m<r-l+1 \le 2m$，$minsuf(l,r)=min(s[p..r],minsuf(r-m+1,r))$
  - 根据上式，可以倍增预处理$f(i,r)$表示$s[r-2^i+1..r]$的最小后缀的长度或者起始下标，$O(1)$转移
  - 预处理$O(nlogn)$，询问每次$O(1)$
- 子串最大后缀查询
  - 



1.http://codeforces.com/gym/100962    $D$题

注：模板题，子串$border$查询，子串最小带余周期查询





##【14】序列自动机

定义：给定一个序列$a$，下标$[1,n]$，它的序列自动机是一个有向图$DAG$，构造如下：

新建$0$号点$S$和$n+1$号点$T$，对每个下标$i$建一个点$i$，$\forall i \in [0,n]$，$i$向右连出$c$条有向边($c$为字符集大小)，连向字符集中的每个字符在下标$i$右侧第一次出现的下标，对于没有出现的字符，连向$T$

**目前已知的性质：**

1)可以识别序列$a$的所有子序列，注意除$S,T$之外每个点均为可接受点

2)可以求序列$a$本质不同的子序列个数，具体来说，$\forall i \in [1,n]$，可以计算$f[i]$表示以下标$i$结尾且下标$i$必取的本质不同子序列个数，$f[T]$即为整个序列$a$的本质不同子序列个数，对$f$求前缀和即得前缀中的本质不同子序列个数，$f$数组本身可以在$DAG$上做$dp$计算，注意此用法不要保留多重边

证明：序列自动机(无重边)上$S$到$T$的通路与序列$a$的所有本质不同子序列(包括空子序列)一一对应

事实上，任取两条不同的通路，若它们代表的字符连接构成的字符串相同，则取它们第一个不同的下标$p,q$，和最后一个相同的下标$t$，则说明$a[p]=a[q]$且$p \ne q$，这与$t$对于字符$a[p]$只有一条出边矛盾

3)序列自动机的最短路长度等于序列$a$的密度$+1$，参见组合$dp$中的$codeforces \space 1158F$词条

证明：沿用组合$dp$那道题目的说法，假设序列$a$，含有$k$个块，字符集大小为$c$

事实上，$S$到$T$的任一条通路，都至少要经过每个块至少一次，最后还需要一次跳出，故$len \ge k+1$

另一方面，显然可以构造出以下路径确实$len=k+1$，从而可以使得不等号取到等号：

从$S$开始，依次经过每个块的末端点，最后跳出到$T$



##【15】lyndon-word和lempel-ziv分解



$lyndon$分解模板题

https://loj.ac/problem/129

- 对于字符串$s$，若其任意后缀字典序不小于$s$，称$s$为$lyndon-word$；等价于$s$是其本身循环移位串中的字典序最小串
- 字符串$s$分解为若干个字典序非严格降的部分，每个部分是个$lyndon-word$，分解是唯一的



$LZ$分解

- 一种字符串的压缩表示算法，若某个子串在之前已经出现了，则可以用$(长度，下标)$的二元组来表示
- 对字符串$S$进行分解，若当前$S[i]$是个新的字符，则单独一段，用元祖$(0,S[i])$表示；若已经出现了，则寻找一个下标$j \in [0,i)$，使得$lcp(j,i)$最大，用元祖$(lcp_{max},j)$表示
- 例子：$abaabababaaaaabbabab$，被表示为$(0, a), (0, b), (1, 1), (3, 1), (4, 5), (4, 10), (1, 2), (5, 5) $，这里字符串下标是从$1$开始的
- 解压缩的过程是容易的，只要一个个元祖在线处理即可，要么新加一个未出现的字符，要么复制已出现的一段
- 详细算法参阅$《Simpler \space and \space Faster \space Lempel \space Ziv \space Factorization 》$文献，采用后缀数组实现







The Runs Theorem and Lyndon Tree







# 5.dp深入

##【1】几类经典dp：数位dp



1.http://codeforces.com/contest/55/problem/D

2.http://codeforces.com/contest/628/problem/D

3.http://codeforces.com/contest/747/problem/F

4.http://codeforces.com/contest/259/problem/D

5.http://www.lydsy.com/JudgeOnline/problem.php?id=3598

6.http://www.lydsy.com/JudgeOnline/problem.php?id=1833

7.http://www.lydsy.com/JudgeOnline/problem.php?id=1026

8.http://www.lydsy.com/JudgeOnline/problem.php?id=3131

9.http://www.lydsy.com/JudgeOnline/problem.php?id=4521

10.http://acm.hdu.edu.cn/showproblem.php?pid=5435

11.http://acm.hdu.edu.cn/showproblem.php?pid=4722

12.http://acm.hdu.edu.cn/showproblem.php?pid=3555

13.http://acm.hdu.edu.cn/showproblem.php?pid=3652

14.http://acm.hdu.edu.cn/showproblem.php?pid=4734

15.http://acm.hdu.edu.cn/showproblem.php?pid=5787

16.http://acm.hdu.edu.cn/showproblem.php?pid=5898

17.http://acm.hdu.edu.cn/showproblem.php?pid=3886

18.http://acm.hdu.edu.cn/showproblem.php?pid=5808

19.http://acm.hdu.edu.cn/showproblem.php?pid=3943

20.http://acm.hdu.edu.cn/showproblem.php?pid=6156

21.http://acm.hdu.edu.cn/showproblem.php?pid=4352

22.https://hihocoder.com/problemset/problem/1259

注：$2015icpc$北京，给定$n \le 10^{18}$，求字典序$\le n$的二进制$01$串中三进制值$\%k$的分布(每种余数各有多少个)



##【2】dp优化：四边形不等式



1.http://www.lydsy.com/JudgeOnline/problem.php?id=1010

2.http://acm.hdu.edu.cn/showproblem.php?pid=3480

3.http://acm.hdu.edu.cn/showproblem.php?pid=2829

4.http://acm.hdu.edu.cn/showproblem.php?pid=3506

5.http://acm.hdu.edu.cn/showproblem.php?pid=3516

6.http://codeforces.com/problemset/problem/321/E

7.http://poj.org/problem?id=1160

8.http://www.lydsy.com/JudgeOnline/problem.php?id=1563

9.http://www.lydsy.com/JudgeOnline/problem.php?id=2216

10.http://www.lydsy.com/JudgeOnline/problem.php?id=2739

11.http://www.lydsy.com/JudgeOnline/problem.php?id=3229

12.http://www.lydsy.com/JudgeOnline/problem.php?id=3675

13.http://www.lydsy.com/JudgeOnline/problem.php?id=4367

14.http://www.lydsy.com/JudgeOnline/problem.php?id=4426

## 【3】dp优化：单调队列与单调栈


【文章】http://blog.csdn.net/LZJ209/article/details/76150259


1.http://acm.hdu.edu.cn/showproblem.php?pid=3401

2.http://acm.hdu.edu.cn/showproblem.php?pid=3410

3.http://acm.hdu.edu.cn/showproblem.php?pid=1500

4.http://acm.hdu.edu.cn/showproblem.php?pid=1059

5.http://acm.hdu.edu.cn/showproblem.php?pid=4123

6.http://www.lydsy.com/JudgeOnline/problem.php?id=1855

7.https://www.lydsy.com/JudgeOnline/problem.php?id=3831

8.https://www.lydsy.com/JudgeOnline/problem.php?id=3048

9.http://www.lydsy.com/JudgeOnline/problem.php?id=1499

10.https://www.lydsy.com/JudgeOnline/problem.php?id=2096

11.https://www.lydsy.com/JudgeOnline/problem.php?id=3126

12.https://www.lydsy.com/JudgeOnline/problem.php?id=1127

13.https://nanti.jisuanke.com/t/30991

14.https://www.lydsy.com/JudgeOnline/problem.php?id=1342

15.https://www.lydsy.com/JudgeOnline/problem.php?id=2500

16.http://www.lydsy.com/JudgeOnline/problem.php?id=3316

17.http://www.lydsy.com/JudgeOnline/problem.php?id=1012

18.http://www.lydsy.com/JudgeOnline/problem.php?id=1023

19.https://www.lydsy.com/JudgeOnline/problem.php?id=1233

20.https://www.lydsy.com/JudgeOnline/problem.php?id=1122

21.http://codeforces.com/problemset/problem/939/F

22.http://codeforces.com/problemset/problem/940/E

23.http://codeforces.com/problemset/problem/960/F











## 【4】dp优化：斜率优化

【参考】http://blog.csdn.net/cdqzoiers/article/details/52497160

https://codeforces.com/blog/entry/8219



1.http://www.lydsy.com/JudgeOnline/problem.php?id=4518

2.http://www.lydsy.com/JudgeOnline/problem.php?id=4073

3.http://www.lydsy.com/JudgeOnline/problem.php?id=4578

4.http://www.lydsy.com/JudgeOnline/problem.php?id=2726

5.http://www.lydsy.com/JudgeOnline/problem.php?id=3963

6.http://www.lydsy.com/JudgeOnline/problem.php?id=1010

7.http://www.lydsy.com/JudgeOnline/problem.php?id=1911

8.http://www.lydsy.com/JudgeOnline/problem.php?id=3156

9.http://www.lydsy.com/JudgeOnline/problem.php?id=4517

10.http://www.lydsy.com/JudgeOnline/problem.php?id=1767

11.http://www.lydsy.com/JudgeOnline/problem.php?id=2442

12.http://codeforces.com/problemset/problem/643/C

13.http://codeforces.com/problemset/problem/631/E

14.http://codeforces.com/problemset/problem/673/E

15.http://acm.hdu.edu.cn/showproblem.php?pid=3480

16.http://acm.hdu.edu.cn/showproblem.php?pid=3480

17.http://acm.hdu.edu.cn/showproblem.php?pid=2829

18.http://acm.hdu.edu.cn/showproblem.php?pid=3507

19.http://acm.hdu.edu.cn/showproblem.php?pid=3545

20.http://acm.hdu.edu.cn/showproblem.php?pid=2993

21.http://www.lydsy.com/JudgeOnline/problem.php?id=1492

22.http://www.lydsy.com/JudgeOnline/problem.php?id=3672

23.http://acm.hdu.edu.cn/showproblem.php?pid=3725

24.https://www.lydsy.com/JudgeOnline/problem.php?id=5380



## 【5】dp优化：利用各种数据结构优化转移

1.http://codeforces.com/contest/834/problem/D

2.http://www.lydsy.com/JudgeOnline/problem.php?id=1835

3.https://www.lydsy.com/JudgeOnline/problem.php?id=2933

4.http://www.lydsy.com/JudgeOnline/problem.php?id=4422

5.http://www.lydsy.com/JudgeOnline/problem.php?id=3380

6.http://www.lydsy.com/JudgeOnline/problem.php?id=4417

7.http://codeforces.com/problemset/problem/720/D

8.http://www.lydsy.com/JudgeOnline/problem.php?id=3688

9.http://www.lydsy.com/JudgeOnline/problem.php?id=4361

10.http://www.lydsy.com/JudgeOnline/problem.php?id=3790

11.http://codeforces.com/problemset/problem/573/B

12.http://codeforces.com/contest/474/problem/E

13.http://codeforces.com/contest/675/problem/E

14.http://codeforces.com/contest/777/problem/E

15.http://codeforces.com/contest/573/problem/D

16.http://codeforces.com/contest/115/problem/E

17.http://codeforces.com/contest/629/problem/D

18.http://codeforces.com/contest/487/problem/B

19.http://codeforces.com/problemset/problem/809/D

20.http://codeforces.com/problemset/problem/939/F

21.http://codeforces.com/problemset/problem/958/C3

22.https://ac.nowcoder.com/acm/contest/881/I

注：类似网格图上$dp$，利用单调性，用线段树优化转移，比较复杂





## 【6】几类经典dp：状态压缩动态规划/状压dp与插头dp

看论文，和一些资料：http://www.cnblogs.com/kuangbin/archive/2012/10/02/2710343.html

1.http://www.lydsy.com/JudgeOnline/problem.php?id=1072

​	问有多少数字排列整除d，对余数装压

2.http://www.lydsy.com/JudgeOnline/problem.php?id=1087

​	问N*N棋盘放k个国王有几种方案，需要先预处理两层之间的转移，不然复杂度不够

X 3.http://www.lydsy.com/JudgeOnline/problem.php?id=119

4.http://www.lydsy.com/JudgeOnline/problem.php?id=1879

​	状压dp计数，状压dp要注意预处理转移，减少复杂度 

5.http://www.lydsy.com/JudgeOnline/problem.php?id=2064

​	两堆数，每次可以合并两个，问最少几次可以两堆一样, 转移分步的思想要注意，可以减少复杂度 

6.http://www.lydsy.com/JudgeOnline/problem.php?id=3717

​	n个物品放入m个包里，最少要几个包，状态为用了哪些物品，考虑状态之间的有序性，逐个插入物品

7.http://www.lydsy.com/JudgeOnline/problem.php?id=3812

​	n点m边强连通子图计数，首先要会n点m边DAG计数，然后把枚举出度为零的点集容斥改为枚举缩点后出度为零的点集容斥

8.http://www.lydsy.com/JudgeOnline/problem.php?id=4057

​	简单的状态表示和转移

9.http://www.lydsy.com/JudgeOnline/problem.php?id=4145

​	状态为已经有哪些物品，分步转移优化

10.http://www.lydsy.com/JudgeOnline/problem.php?id=4455

​	给n个点的图和树，给树不重复标号，树上边要在图中出现。用容斥来保证标号不重复，有重复标号等价于有标号没用到

11.http://www.lydsy.com/JudgeOnline/problem.php?id=4565

​	一个01串可选k个合并为一个，得到对应2^k种权值中一个，求最大价值，区间dp，主要把合并过程看成一棵树，枚举后缀为0或1以及前缀的状态合并 

12.http://www.lydsy.com/JudgeOnline/problem.php?id=4600

13.http://www.lydsy.com/JudgeOnline/problem.php?id=4601

14.http://acm.hdu.edu.cn/showproblem.php?pid=4049

​	层之间的有序性要考虑清楚，最好写成分层的形式

15.http://acm.hdu.edu.cn/showproblem.php?pid=3920

​	每次给固定选一个再枚举一个转移，复杂度低一些

16.http://acm.hdu.edu.cn/showproblem.php?pid=1074

​	简单题

17.http://acm.hdu.edu.cn/showproblem.php?pid=5067

​	TSP问题

18.http://acm.hdu.edu.cn/showproblem.php?pid=4997

​	求边双联通子图个数, 需要容斥计算联通子图，不联通子图，单联通子图个数

19.http://acm.hdu.edu.cn/showproblem.php?pid=4336

20.http://acm.hdu.edu.cn/showproblem.php?pid=1074

21.http://acm.hdu.edu.cn/showproblem.php?pid=5094

​	bfs过程中对每个点开个状态来表示

22.http://acm.hdu.edu.cn/showproblem.php?pid=2820

​	求相邻差值小于等于k(k<=4)的排列数量，一种枚举排列的方法，考虑有序插入数字，那么已有的数字可以表示成一些段，转移主要有合并，连接，新增一段，还要注意考虑边界状态。

23.http://acm.hdu.edu.cn/showproblem.php?pid=3471

24.http://acm.hdu.edu.cn/showproblem.php?pid=1565

25.http://acm.hdu.edu.cn/showproblem.php?pid=3605

26.http://acm.hdu.edu.cn/showproblem.php?pid=5045

27.http://acm.hdu.edu.cn/showproblem.php?pid=3311

28.http://acm.hdu.edu.cn/showproblem.php?pid=5724

29.http://acm.hdu.edu.cn/showproblem.php?pid=4295

30.http://acm.hdu.edu.cn/showproblem.php?pid=3006

31.http://acm.hdu.edu.cn/showproblem.php?pid=5418

32.http://acm.hdu.edu.cn/showproblem.php?pid=4352

33.http://acm.hdu.edu.cn/showproblem.php?pid=4628

34.http://acm.hdu.edu.cn/showproblem.php?pid=1885

35.http://acm.hdu.edu.cn/showproblem.php?pid=4284

36.http://acm.hdu.edu.cn/showproblem.php?pid=3001

37.https://www.lydsy.com/JudgeOnline/problem.php?id=5369

38.http://poj.org/problem?id=2411

39.http://poj.org/problem?id=1739

40.http://acm.hdu.edu.cn/showproblem.php?pid=1693

41.http://acm.hdu.edu.cn/showproblem.php?pid=4949

42.http://acm.hdu.edu.cn/showproblem.php?pid=4804

43.http://acm.hdu.edu.cn/showproblem.php?pid=5731

44.http://acm.hdu.edu.cn/showproblem.php?pid=4064

45.http://acm.hdu.edu.cn/showproblem.php?pid=4285

46.http://acm.fzu.edu.cn/problem.php?pid=1977

47.http://acm.timus.ru/problem.aspx?space=1&num=1519

48.http://acm.hdu.edu.cn/showproblem.php?pid=3377

49.http://poj.org/problem?id=3133

50.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3446

51.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3256

52.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3213

53.http://codeforces.com/problemset/problem/906/C

54.http://codeforces.com/problemset/problem/1097/H

[注]经典的三段论区间合并式状压dp + bitset状态表示 + 倍增/递归处理计数

55.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=010433 C

​	关键在于用floyd处理团之间距离，注意每个点的初始花费最后再加，然后就转化成有2^k类点，两类点的距离是包含的团之间的距离的最小值，这样枚举复杂度还不够，改为从小到大枚举最短路，再枚举第一个点，和它距离是这条最短路的点数量用子集和来维护，然后标记第一个枚的点和这些点已经算过了，下次不再算，因为已经有较短的路了。

56.https://www.51nod.com/Challenge/Problem.html#problemId=1626

注：难题，$4$维骨牌覆盖方案计数，比较复杂的状压$dp$

57.https://www.51nod.com/Challenge/Problem.html#problemId=1142

注：难题，$10^9*5$哈密尔顿回路计数问题，状压$dp$，插头$dp$

58.https://www.51nod.com/Challenge/Problem.html#problemId=1033

注：基础题，普通多米诺骨牌覆盖方案问题，$10^9*5$，状压$dp$，矩阵快速幂

59.http://acm.hdu.edu.cn/showproblem.php?pid=5510

注：中档题，$2015icpc$沈阳，轮廓线$dp$，按格转移，$bell$数表示联通情况做状态表示

60.http://acm.hdu.edu.cn/showproblem.php?pid=4796

注：难题，$2013icpc$长沙$F$题，插头$dp$，寻找一条代价最小的通路(要求以第一行某个格子开头，最后一行某个格子结尾)，满足将两种颜色格子分在两边(不连通)且不穿过一些障碍格子，注意讨论各种或简单或复杂的情况

61.http://acm.hdu.edu.cn/showproblem.php?pid=4113

注：难题，$2011icpc$成都$C$题，给定$n*m(n,m \le 8)$棋盘，寻找一个回路(简单多边形)，使得包围所有$O$，且不得包围任何一个$X$，求最短周长。

### 插头 dp

#### 参考链接

《基于连通性状态压缩的动态规划问题》——陈丹琦

<https://www.cnblogs.com/y2823774827y/p/10140757.html>

#### 刷题

https://vjudge.net/contest/87043#overview

##### 简单回路问题

B: 给定 12 * 12 的棋盘，格子四联通，有两类格子， 0 不能走 1 必走。画一条回路，求方案数。

A: 在 B 题的基础上，允许有多条回路。

**C:** 给定 12 * 12 的棋盘，格子四联通，有三类格子， 0 不能走 1 必走 2 可走可不走。画一条回路，求方案数。

D: 给定 10 * 10 的棋盘，格子四联通，墙壁有代价。画一条回路，求最小代价。

E: 给定 8 * 9 的棋盘，格子四联通，格子有收益。求左上到右下这条通路的最大收益。

F: 给定 8 * 8 的棋盘，格子四联通，有两类格子， 0 不能走 1 必走。画一条左下到右下的通路，求方案数。

##### 简单路径问题

**J:** 给定 7 * 7 的棋盘，格子四联通，格子有收益或不能走。求通路的最大收益。

**G:** 给定 9 * 9 的棋盘，格子四联通，有两类格子， 1 不能走 0 可以走。要求从 S1 走到 T1 ，从 S2 走到 T2 ，且路径不相交，求最短路径。
解：独立插头变为两类。每个插头用三位比特表示。

**I:** 给定 7 * 1e9 的棋盘，格子四联通，每个格子必走。求左上走到左下的方案数。

K: 给定 12 * 12 的棋盘，格子四联通，有两类格子， 0 不能走 1 必走。画 k 条回路，求方案数。

**H:** 六边形。



## 【7】几类经典dp：背包问题

1.http://codeforces.com/problemset/problem/868/E

2.http://codeforces.com/problemset/problem/920/D

3.http://codeforces.com/problemset/problem/946/D

4.https://www.lydsy.com/JudgeOnline/problem.php?id=1042

​	问多重背包构成n的方案数，如果种类很少可以容斥

5.https://www.lydsy.com/JudgeOnline/problem.php?id=4247

​	消耗有正有负的背包，需要把增加容量的物品放在前面

6.https://www.lydsy.com/JudgeOnline/problem.php?id=2287

​	背包求逆

7.https://www.lydsy.com/JudgeOnline/problem.php?id=5215

​	背包结果乘个组合数，有个细节就是0个球分配到0个箱子要是1，不能用那个公式

8.https://www.lydsy.com/JudgeOnline/problem.php?id=4753

​	0-1分数规划加上树上依赖型背包，就是暴力枚举子树合并即可，这个复杂度是O(n ^ 2)的，如果是size和K取min，那么复杂度是O(n * K)

9.https://www.lydsy.com/JudgeOnline/problem.php?id=1065

​	比较好的树上背包问题，首先要解那个二元方程算出贡献式，之后要枚举环大小变成树上问题，然后要多记一维记录u到根的距离，注意两种转移式要严格注意下标，只有距离大于1才有切割的转移，不能合在一起写，不然会错乱。

10.https://www.lydsy.com/JudgeOnline/problem.php?id=5390

​	本质上还是一种分步优化，每次只加一颗糖或一盒糖，不用再枚举糖数量了。

11.https://www.lydsy.com/JudgeOnline/problem.php?id=2914

12.http://codeforces.com/problemset/problem/868/E

​	很特殊的背包，如果容量为1 - i，设前缀容量为V，可以在枚举的时候只枚举到[V - (i - 1) ^ 2, V], 设x表示减的数，表示最优方案不会在前面丢掉x以上且后边取了x以上。

## 【8】几类经典dp：树形dp

1.http://codeforces.com/contest/766/problem/E

2.http://codeforces.com/problemset/problem/868/E

3.http://codeforces.com/problemset/problem/935/E

4.http://codeforces.com/problemset/problem/960/E

5.http://codeforces.com/problemset/problem/963/B

6.http://codeforces.com/problemset/problem/1065/F

7.http://codeforces.com/problemset/problem/1092/F

注：树上换根，计算全局贡献

8.http://codeforces.com/problemset/problem/1097/G

注：经典且稍复杂的树上合并式背包，需容斥

9.http://codeforces.com/problemset/problem/1153/D

注：树形dp，这种max/min绕来绕去的题目往往一个点的状态和某个离散化后的集合排名有关，结合简单的贪心思想，此排名可转移

10.http://codeforces.com/problemset/problem/1059/E

注 ：这题用贪心比较容易做，每次从叶子把向上最长能覆盖的都盖了，并查集维护被覆盖的点就行了，看了一下题解dp的做法，主要是一个点向下的链可以用从它开始欧拉序的前缀表示，然后比较麻烦，还需要线段树维护限制和答案，每次暴力删除已经不符合的点，因为这次不符合之后也不会再符合

11.http://codeforces.com/problemset/problem/429/C

注 ：给你树上每个点的size，问树是否存在，正解应该是把叶子和非叶子分开状压，一棵树其实应该有多种子树选择方案，我直接贪心加背包选了一种，因为n比较小，可能反例不太有，这样做就可以过

12.http://codeforces.com/problemset/problem/629/E

注 ：问树上两点加一条边成环平均长度，就是树上换根计数

13.http://codeforces.com/problemset/problem/86/C

注 ：问能被一些字符串覆盖的母串有多少种，发现ac自动机一直理解错了，到了一个点要把它fail链上的点都算上贡献

14.http://codeforces.com/problemset/problem/1146/F

注 ：感觉不错的树dp题，问你有多少种叶子划分使其相同集合叶子联通且没有交，要记录三个量，i的子树答案，i是已经被用的数量，i是被虚占用的数量，然后转移要推清楚，我一开始转移搞错了，花了很多时间。

15.http://codeforces.com/problemset/problem/708/C

注 ：问每个点在能换一条边的情况下能否是重心，用树上换根技巧维护每一个点为根时子树中最大的小于n/2的子树size。

16.http://codeforces.com/problemset/problem/490/F

注 ：问你树上所有路径中的最长上升子序列多长，维护向上向下两条链实现

17.http://codeforces.com/problemset/problem/965/E

注 ：建完字典树后就变成树上有一些1，每个1可以往上移，但是每个位子至多一个1，要深度和最小，每次选最深的一个1，找到它向上第一个不为1的位置放过去，可以用并查集实现

18.http://codeforces.com/problemset/problem/804/D

注 ：询问森林中两棵树连一条边期望直径，主要是复杂度上是有分块思想，一次询问的复杂度是较小树的size，那么大于sqrt(n)的点对最多只用n个，所以复杂度是O(nsqrt(n)log(n))

19.http://codeforces.com/problemset/problem/1109/D

注 ：边权范围1-m，问有多少棵无根树a到b的距离是m，有一个prufer序列的结论，详细学了一下prufer序列，记在了它相关的结论中

20.http://codeforces.com/problemset/problem/1032/F

注 ：问一棵树有多少种方法删一个点集使剩下的图最大匹配使唯一的，定义三种状态，i和儿子没边且没匹配，i和儿子有边且没匹配，i和儿子有边且匹配了，然后推一下转移式，然后发现一般转移如果是选儿子的子集，可以用乘法分配律合起来乘

21.http://codeforces.com/problemset/problem/1132/G

注 ：给一个数组，每一位往后面第一个比他大的连边，问所有长度为k区间中最长链是多少，在dfs序上用线段树处理一下就行

22.http://codeforces.com/problemset/problem/123/E

注 ：推出指定根后每个点期望怎么算后套上树上换根即可

性质：在无根树中从一个给定起点S到某个非S节点T的dfs期望步数(包括回溯)为n-size(T)，size为子树大小，看成以S为根的有根树

本质：典型的条件随机变量的数学期望，也就是全期望公式相关，详情参见数学词条

23.http://codeforces.com/problemset/problem/643/E

注 ：发现只有对一个点深度不超过一定值的点才对答案有影响，所以加点更新和算期望可以只算一部分，复杂度就对了。

24.http://acm.hdu.edu.cn/showproblem.php?pid=6060

注 ： 发现根往下每一个子树都是独立的，所以一条边的最大贡献次数是下面size大小和集合数量k取min，这样dfs一遍即可

25.http://codeforces.com/gym/102220/problem/A

注：贪心+二分图Hall定理+暴力维护树dp

$二分图网络流模型左边点满流充要条件:Hall定理$

任取左侧点子集$X$，与之相连的右侧点子集$Y$，则$X$集合所对容量之和$\le$$Y$集合所对容量之和

26.https://codeforces.com/contest/1252/problem/B

注：中档题，给定一棵$n$个点的树，将树划分为若干条链，之间不交，且点的并集为$V$；要求任两条链不能直接连接，即每条链都是极长的；求方案数。令$f[i][0]/f[i][1]/f[i][2]$表示$i$这棵子树的划分方案，且根不能连出去、可以连出去(也可以不连)、一定要连出去。做树$dp$适当转移即可，注意存在没有逆元的情况，讨论余数为$0$的情况。









## 【9】几类经典dp：概率dp

参考：动态规划与计数问题(北京⼤学,洪华敦)  wannafly_2019_winter_div1_计数

1.http://acm.hdu.edu.cn/showproblem.php?pid=4809

注：偏树形dp，和概率关系比较小，树上每个点可分给三个人，每个人消耗他有的奇数联通块数减偶数联通块数的代价，记录i的联通块奇偶性和已有的差值，与儿子转移一下

2.http://codeforces.com/gym/101655  (C题)

注：暴力记忆化转移 

3.https://www.lydsy.com/JudgeOnline/problem.php?id=5340

注：概率的形式可以用多项式表示，以及多项式除两项多项式可以O(n)做到

4.https://www.lydsy.com/JudgeOnline/problem.php?id=2688

注：树上删边的sg函数结论，然后以sg值为状态转移概率，用到二叉树计数

5.https://www.lydsy.com/JudgeOnline/problem.php?id=3450

注：维护连续1平方的期望，知道了期望可以通过维护差值来转移

6.https://www.lydsy.com/JudgeOnline/problem.php?id=4844

注：列出dp方程，优化一下计数方式即可

7.https://www.lydsy.com/JudgeOnline/problem.php?id=4318

注：维护连续1立方的期望，和之前差不多，多维护一项平方的期望

8.https://www.lydsy.com/JudgeOnline/problem.php?id=1246

注：收集n个物品，每次随机买，每买一次价格贵1，问期望多少钱买齐，状态要建立成有i个物品且还没买过东西，这样可以和前面无关，然后化简转移方程

9.https://www.lydsy.com/JudgeOnline/problem.php?id=4820

10.https://www.lydsy.com/JudgeOnline/problem.php?id=5004

注：概率空间有限，其实就是组合计数，dp转移一下，但是题面写有精度判断，但bzoj是直接比较，被坑了不少时间

11.https://www.lydsy.com/JudgeOnline/problem.php?id=3029

注：简单的概率dp，设计dp状态转移一下，一些小技巧，增加偏移量和滚动数组

12.https://www.lydsy.com/JudgeOnline/problem.php?id=2554

注：有一堆有颜色的小球，每次选两个出来，把后面变前面颜色，问期望多少次变一样，先转化成只考虑两种颜色，然后要求条件概率下的期望，其相邻两项转移系数是不同的，以及一个套路，求与左右相邻两项有关的递推式的方法

13.https://www.lydsy.com/JudgeOnline/problem.php?id=3270

或者：http://codeforces.com/problemset/problem/113/D

注：状态图上随机游走，有一些终结态，求停在每个状态的概率，算是通用套路，设经过期望次数，去建立方程，高斯消元，注意二元pair表示状态(重编号)

14.https://www.lydsy.com/JudgeOnline/problem.php?id=2201

注：一个环上每个点随机颜色，问连续颜色长度乘积的期望，枚举第一个长度断环，dp求一下第二个和最后一个颜色和第一个不同的期望

15.https://www.lydsy.com/JudgeOnline/problem.php?id=4008

注：只考虑第一张卡牌，发现期望只和它发布发动有关，和在哪一轮发动无关，所以以此建立状态记忆化转移

16.https://www.lydsy.com/JudgeOnline/problem.php?id=3566

注：树上概率dp加上换根技巧，以及换根的时候要注意运算是否可逆

17.https://www.lydsy.com/JudgeOnline/problem.php?id=2337

注：异或拆位后建图建立方程组高斯消元

18.https://www.lydsy.com/JudgeOnline/problem.php?id=3143

注：计算随机游走的过程中每条边经过的期望次数

19.https://www.lydsy.com/JudgeOnline/problem.php?id=3191

注：简单题，表示一下状态转移，就是环上的下标转移要计算清楚

20.https://www.lydsy.com/JudgeOnline/problem.php?id=5292

注：求出转移方程，发现第i项之和i+1和与它小的项有关系，这样接近与上三角，可以用高斯消元在O(n^2)解决

21.https://www.lydsy.com/JudgeOnline/problem.php?id=5461

或者：https://loj.ac/problem/2537

注：线段树合并(带区间修改标记)+概率dp

树上概率dp经典题，叶子节点带点权，非叶子节点带概率，表示在两个儿子之间选择大的概率，求根的概率分布列；带区间修改的线段树合并，并没有特别之处，注意查询和合并函数中向下递归之前，先push_down

22.https://www.lydsy.com/JudgeOnline/problem.php?id=4720

注：基础传统题，注意多重边，floyed+概率dp

23.https://www.lydsy.com/JudgeOnline/problem.php?id=4944

或者：https://loj.ac/problem/2304  http://uoj.ac/problem/316 NOI2017真题

注：网格区域概率dp+线性递推模板，题解参见：https://blog.csdn.net/ez_yww/article/details/78679459

这个题目算法和复杂度主要在上述两独立部分，这里主要讲dp思路：

设$g_{i,j}$表示长度为$j$，高度为$i$的海域全部是安全的，剩下的部分未知，最大子矩形面积$≤k$的概率之和

设$h_{i,j}$表示长度为$j$，高度为$i+1$的海域中，前$i$行全部是安全的，剩下的未知且$(i+1,j)$是危险的，最大子矩形面积$≤k$的概率之和

设$f_i$为前$i$列最大子矩形面积$≤k$且$(1,i)$为危险格子的概率之和

核心方程：
$$
\begin{aligned} g_{k, 1} &=h_{k,1}=q^{k}(1-q) \\ g_{i, 0} &= h_{i, 0} =1, i \in [1,k) \end{aligned}
$$

$$
\begin{aligned} g_{i, j} &=\sum_{k=0}^{j} h_{i, k} g_{i+1, j-k} \\ h_{i, j} &=\sum_{k=0}^{j-1} h_{i, k} g_{i+1, j-k-1} q^{i}(1-q) \end{aligned} \\
where: j \le\lfloor k/i \rfloor
$$

$$
f_0=1 \\
f_{i}=\sum_{j=0}^{min(k,i-1)} f_{i-j-1} g_{1, j}(1-q)
$$

其暴力时间复杂度为：$\sum_{i=1}^{k}\left\lfloor\frac{k}{i}\right\rfloor^{2}=O\left(k^{2}\right)=O\left(\frac{\pi^2}{6}k^2\right)$

可以使用生成函数优化：
$$
\begin{aligned} A_{i}(x) &=\sum_{j \geq 0} g_{i, j} x^{j} \\ B_{i}(x) &=\sum_{j \geq 0} h_{i, j} x^{j} \\ c_{i} &=q^{i}(1-q) \end{aligned} \\

\begin{aligned} A_{i}(x) &=B_{i}(x) A_{i+1}(x) \\ B_{i}(x) &=c_{i} x A_{i+1}(x) B_{i}(x)+1 \\ B_{i}(x) &=\frac{1}{1-c_{i} x A_{i+1}(x)} \end{aligned}
$$
时间复杂度：$\sum_{i=1}^{k}\left\lfloor\frac{k}{i}\right\rfloor \log \left\lfloor\frac{k}{i}\right\rfloor= O\left(k \log ^{2} k\right)$

使用$O(k^2)$的时间复杂度计算$f[1..k]$，最终答案：
$$
ans=\sum_{i=0}^{k}f_{n-i}g_{1,i}=f_{n+1}/(1-q)
$$
计算$f$的过程本质上是一种只知首项$f_0$的线性递推

关于线性递推部分，参见数学笔记



24.https://www.lydsy.com/JudgeOnline/problem.php?id=1415

注：NOI2005真题，概率dp+贪心+最短路，基础题

25.https://www.lydsy.com/JudgeOnline/problem.php?id=2676

注：wc2013李超题，经典的马尔可夫链模型，二分答案+概率dp+矩阵快速幂

注意求总得分的期望，由于期望的线性性，可以拆分为每个状态点的贡献，因此状态设计为$dp[i][j][k]$表示$i$条生命$j$为当前这一轮如果胜利应该获得的得分(或者如果胜利末尾连续的胜利长度)，当前为第$k$轮的期望

将状态$(i,j)$设计为点(重新编号)，状态转移$(i,j)\rightarrow(min(i+1,q),min(j+1,r))$，概率为$p$，且$(i,j)\rightarrow(i-1,1)，i>1$，概率$1-p$

追加超级源点$tot$，每个点向超级源点连边，边权为这个点如果获胜，则本步的期望对答案的贡献，即$(i,j):j*p$

起始点为状态$(q,1)$，考虑从起始点出发，长度为$0<=k<n$的长度的一条链，链上的边权乘积就是这种情况的概率，只要再乘上此状态的期望，就是条件期望了；前面每个点已经连向$tot$，耗费长度为$1$，故一种情况(假设以概率$p$获得胜利)总长度为$1\le k+1\le n$，因此模型转化为求起点$S$到终点$tot$的长度在$[1,n]$以内的任意有向链边权乘积之和($tot$尚无自环)，只要在$tot$处，追加边权为$1$的自环，即可转化为求$S$到$tot$长度固定为$n$的链路，考虑邻接矩阵的$n$次幂即可

总结：本题最主要的思想是算两次，对每个状态只考虑在此处获胜的条件期望(当然还需要耗费一步)，叠加即得总的期望得分

26.http://codeforces.com/problemset/problem/464/D

注：概率dp+状态空间剪枝优化，详见国家集训队论文《dp的一些优化技巧》

设$f(i,j)$为当前己经有等级为$j$的装备了，再打$i$只怪获得金币的期望
$$
\begin{aligned} 

f(0, j) &=0 \\ 

f(i, j) &=\frac{1}{k} \sum_{x=1}^{j+1} \frac{1}{j+1}(f(i-1, \max (j, x))+\min (j, x))+\frac{k-1}{k} f(i-1, j) \\ &=\frac{1}{k}\left(\frac{j}{j+1} \cdot\left(f(i-1, j)+\frac{j+1}{2}\right)+\frac{1}{j+1} \cdot(f(i-1, j+1)+j)\right)+\frac{k-1}{k} \cdot f(i-1, j)  \\

ans&=f(n,1)

\end{aligned} \\
$$
状态空间剪枝：有价值的状态中$f(i,j)$，$j \le \sqrt{i}$，转移$O(1)$，时空复杂度均为$O(n \sqrt{n})$

27.https://www.lydsy.com/JudgeOnline/problem.php?id=2707

注：相当基础的马尔可夫链模型，有向图上随机游走，求每个点到指定终点的期望步数，$n$比较大，但是数据保证每个强连通分量点数不超过$100$，所以显然就是$tarjan$缩点，之后拓扑排序，每个$scc$去高斯消元即可

28.https://www.lydsy.com/JudgeOnline/problem.php?id=1076

注：概率dp+状压dp，很基础

29.http://codeforces.com/problemset/problem/696/B

注：经典题，有根树随机游走，求每个点dfs序的数学期望

与$codeforces \space 123E$类似的，固定一个点$x$求期望，考虑树上每个点$i$对答案的贡献；

在$dfs$序的问题中，回溯是不计代价的，那么树上有三类点，$i$到根闭路径上的点，有$1$的概率贡献$1$，$i$的开子树上的点，概率为$0$，其他的点，有$1/2$的概率贡献$1$，叠加即可

在回溯计算代价的问题中，从根开始随机$dfs$，搜到固定点$x$就停止，求步数的数学期望；树上有三类点，$i$到根闭路径上的点，有$1$的概率贡献$1$，$i$的开子树上的点，概率为$0$，其他的点，有$1/2$的概率贡献$2$，叠加即得$E(x)=n-sz(x)$

30.https://www.lydsy.com/JudgeOnline/problem.php?id=1444

注：建AC自动机，变量定义为经过每个状态的期望次数，建立方程组高斯消元



31.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=010435 C题

注：概率$dp$，题意：给定一个只含"$H$"和"$R$"的字符串$s$，$H$向左走，$R$向右走，速度相同，当两个不同字母冲突时，$H$有$h$的概率消失，$R$有$r$的概率消失；求在充分长的时间后，有严格$A$个$R$和$B$个$H$存活的概率

- 基本性质
  - 一个$H$，一个$R$，$R$在$H$的左边，这两个字母不可能同时存活
  - 原序列$s$任意一个非空子区间，单独游戏，至少有一个生还
  - 假设最终存在严格$A$个$R$和$B$个$H$存在，设他们的下标分别为$r_1,r_2,\cdots,r_A$和$h_1,h_2,\cdots,h_B$，且分别单调增，则有$h_B<r_1$
  - $h_B+1=r_1$，反证法：如若不然，则$h_B$和$r_1$中间至少存在一个人，构成非空子区间，则至少一人生还，不失一般性，不妨令其为字母$H$，而$h_B$这个下标生还了，该字母$H$显然必定生还，即有$B+1$个$H$生还了，而这显然与假设矛盾
  - 从概率的角度讲，很多同时发生的事件，是可以给定一个顺序，有序发生的，比如下标顺序
  - 从原来序列$s$到最终的$A$个$R$和$B$个$H$的状态，一个个人接连着死去，但无论多么复杂的情况，总是有严格$cnt_h-B$个$H$和$cnt_r-A$个$R$分别以$h$和$r$的概率死去，也就是说对于任何一种合法的情况方案，其发生的概率显然总是相等的，均为$h^{cnt_h-B}$和$r^{cnt_r-A}$，因此我们只需要求合法的方案数$ret$就好了
  - $h_B$不同显然对应不同方案，可以按照$h_B$的取值分类
  - 对于一类，考虑以$h_B$结尾的前缀，和以$r_1$开头的后缀，显然这两部分是独立无关的，因此概率或方案数可以直接相乘
- 算法
  - 过滤掉开头的$H$和结尾的$R$(不做也行)，调整$A$和$B$，计算新的$cnt_h,cnt_r$，特判特殊情况
  - 枚举下标$(i,i+1),i \in [0,n]$，令$f_i$表示$i$这个下标是$H$且必生还，以$i$结尾的前缀严格有$B$个$H$生还，其他字母死光的方案数；令$g_i$表示$i$这个下标是$R$且必生还，以$i$开头的后缀严格有$A$个$R$生还，其他字母死光的方案数；二者对称，只讨论$f$
  - 为求$f$令$dp[i][j]$表示只考虑前$k$个元素($k$为第$i$个$H$下标)，一共严格生还了$B$个$H$且第$i$个$H$必须生还，其他元素全部死光的方案数，该$dp$有参数$B$
  - 转移：考虑前$k$个元素中最后一对(最右边)冲突的字母对，讨论$H$和$R$谁生还
    - $H$生还，$(i,j)\to(i,j-1)$
    - $R$生还，$(i,j)\to(i-1,j)$
    - 故：$dp[i][j]=dp[i-1][j]+dp[i][j-1],i\in[B,cnt_h],j\in[1,a[i]]$，$a[i]$表示第$i$个$H$前面的$R$数量
  - 边界：$\forall i <k\&\&j: dp[i][j]=0$，$dp[k][0]=1$，其余均为$0$
  - 令$id[i]$表示第$i$个$H$的下标，则$f[id[i]]=dp[i][a[i]],i\in [0,cnt_h]$
  - 计算答案：$ans=h^{cnt_h-B}*r^{cnt_r-A}*\sum_{i=0}^nf[i]g[i+1]$
  - 特别当心：注意计算答案时，快速幂指数可能有负要特判
- 正确性：由于边界的控制和转移的范围，转移是正确的
  - 转移的特点：
    - 最右规约，即下标$\in[id[i-1],id[i]]$的$R$没有死光，下标$\in[id[i-2],id[i-1]]$的$R$是不会死的，因为我们每次转移仅考虑最后一对冲突字母对
    - 在某个状态，如果我们转移到了一个非法的状态，这是不要紧的，因为非法状态的方案总是$0$，$dp$值加上$0$，相当于没有这种非法转移
    - 状态$dp[i][j]$当$j>a[i]$是非法状态，注意到最右规约和最左规约是不同的，转移过程中总是保持合法的转移走到的是合法的状态，一个$H$可以被打败，其右侧必无$R$
  - 对于状态$dp[i][j]$，考虑当前第$i$个$H$被打败，显然$(id[i-1],id[i])$之间至少有一个$R$，即$a[i-1]<j$，这是个非法转移，转移到的状态为$dp[i-1][j]$，显然是个非法状态，所以我们的转移是正确的
- 总结：
  - 这样的概率问题是比较复杂的，一般都是要仔细分析一下其中蕴含的性质，然后寻找突破口；在概率意义上，一个问题常常需要分类使用加法原理，我们需要寻找正确的分类依据；对于一类子问题，可能还会涉及一些独立子问题的拆分，使用乘法原理，我们需要想清楚为什么是独立的；然后才能设计合理的状态
  - 考虑转移时，我们需要给复杂的事件序列定个顺序，一个个的考虑；验证转移的正确性，要保证合法的转移，没有重复和遗漏的走到其对应合法的状态；非法的转移，要么就没有转移，要么就走到非法的状态($0$状态)
  - 考虑边界和范围来限制$dp$，精确的定义状态表示和状态的合法性


32.http://acm.hdu.edu.cn/showproblem.php?pid=6595

注：考虑一个长度为 $n$ 的随机排列（无相同元素），它所含逆序对数量的数学期望为 $\frac{\binom{n}{2}}{2}$ 。因为每对下标对期望的贡献为 $1/2$ ，且期望具有可加性。

令 $f(i)$ 表示传入一个长度为 $i$ 的随机排列所获得的函数返回值的数学期望。

容易得到： $f(i)=\frac{1}{2^i}\sum_{j=0}^i\binom{i}{j}f(j)$ 。

改写为： $f(i)=\frac{1}{2^i-1}\sum_{j=0}^{i-1}\binom{i}{j}f(j)$ 。

这样可以 $O(N ^ 2)$ 预处理出 $f(i),i\in[1,N]$ 。

$ans(n)=\frac{1}{n}\sum_{i=1}^{n}f(i)$ 。

$O(1)$  回答每组数据。

时间复杂度$O(N^2+Q)$ 。

本题也可以直接通过计算下标$pair$对的贡献，计算答案，$n(n-1)/3$。

33.https://hihocoder.com/problemset/problem/1253

注：难题，$2015icpc$北京$E$题，$T \le 10^5$组询问，每组给$n \le 10^5$，表示有$n$种邮票，开始你没有任何邮票，每次有$1/n$的概率获得其中一种，当第一次收集完所有种类之后停止，第$i$次支付代价$H_k(i)$，求期望支付代价($k \le 10$)。其中$H$满足：$H_0(i)=1,i \ge 1$且$H_k(i)=\sum_{j=1}^iH_{k-1}(j)$。








## 【10】dp优化：分治

1.http://codeforces.com/contest/834/problem/D

2.http://codeforces.com/problemset/problem/868/F



## 【11】其他一些经典例题

1.http://codeforces.com/contest/888/problem/F

2.http://codeforces.com/problemset/problem/930/C

3.http://codeforces.com/problemset/problem/958/C2

注：小模数小段数的关于区间和模和的序列最优切割

4.http://codeforces.com/problemset/problem/1155/D

注：经典的峰形线性dp，允许选择最多一个区间乘给定x的最大连续字段和变种



## 【12】基础dp综合题

1.http://codeforces.com/problemset/problem/864/E

2.http://codeforces.com/problemset/problem/1174/E

注：贪心+dp，考察$gcd$的性质

若$gcd(x,y) <y$则$gcd(x,y) \le y/2$，因此$gcd$会严格下降$log$次

贪心：首元素必为$2^x*3^y,y \in[0,1]$，且每次严格下降$2,3$中的一个

状态表示：$dp[i][x][y]$表示前$i$个元素已经填满且此时$gcd=2^x*3^y$的方案数

3.http://codeforces.com/problemset/problem/1168/C

注：与二进制位$\&$运算有关的$dp$

令$f[i][j]$表示下标$i$能走到的第一个$\ge i$的数值含有$bit_j$的下标

令$g[i][j]$表示下标$>i$的含有$bit_j$的第一个(最小)下标

$f[i][j]=i,a[i]含有bit_j$

$f[i][j]=min(f[g[i][c]][j]),a[i]不含有bit_j,含有bit_c$

回答询问：$x \rightarrow y$

$\exists \space c,st.  f[x][c] \le y,a[y]含有bit_c$

4.http://codeforces.com/problemset/problem/1172/B

注：简单的环状计数dp

用到简单的组合数学结论：将$n$个有标号的元素放入$m$个有标号的集合(左和右，允许为空)中，其方案数为：

$\sum_{k=1}^m\begin{Bmatrix}n \\k\end{Bmatrix}\dbinom{m}{k}k!$，则把$k$个放入$2$个集合为：$(k+1)!$

可以这样理解把这两个集合的分割线看成第$k+1$号元素，加进去一起全排列，方案显然一一对应

令$f[x]$表示把$x$放在弧上特定位置，且把$x$子树上的其他元素铺在这个弧上的不交方案数

显然$f[x]=(|Child(x)|+1)!\prod_{y \in Child(x)}f[y],x!=1$，当$x=1$时，前面阶乘里面不$+1$

实际上，由于邻接表$vi \space V[N]$连的双向边，直接取$sz(V[x])$即可，非根元素本来就多算了一个父亲

$f[1]$表示把$1$放在某个特定位置的方案数，枚举$1$放的具体位置k，$ans=f[1] * n$

5.http://acm.hdu.edu.cn/showproblem.php?pid=6587

注：比较复杂的区间$dp$，给两个长度为$n$的序列$a,b$，不光含$[1,n]$还含$0$表示元素不确定；

问有多少种不同的带标号有根二叉树，满足先序匹配$a$，且中序匹配$b$；

联想到普通的递归构造二叉树的基础题目，与其基本出发点一致，不过改造为计数题：

令$dp[x][y][l][r]$表示$a[x..y]$与$b[l..r]$联合确定的子树种数，这样就超了，但是既然有两个区间长度相等的限制，

就可以很自然的压缩一维，$dp[x][l][r]$表示以$a[x]$为根，中序为$b[l..r]$的子树种数，注意这里$0$看成可以和任意数匹配的元素，最后将$dp[1][1][n]*k!$表示在最终形成的一棵二叉树中，将$0$元素全排填上没出现的元素

转移主体分几种情况讨论，$a[x]$是否为$0$，不为$0$在$b$中是否出现等

一个关键点：记忆化搜索时，要筛掉些无效的状态，在$a[x]$非$0$且未在$b$中出现的情况里，要在$b[l..r]$中枚举一个元素与根$a[x]$匹配，显然只能为$0$元素，注意这个元素下标为$i$，则有个限制，即$i$之前的在$a$中出现元素的下标$k$，要为$i$设一个下界，$k$在左子树，则在$a$中对应下标$k'$到$x$距离即为左子树长度下界，可转化为在$b$中$i$的下界

6.https://ac.nowcoder.com/acm/contest/885/J

7.https://atcoder.jp/contests/agc003/tasks/agc003_e

注：分析+单调栈+二分+$DAG$上$dp$

题意：给定$n \le 10^5$，初始有个长度为$n$的数组$a_i=i$；$q$次操作，每次参数为$L$，表示将数组$a$调整到长度为$L$，若元素多余，只保留前$L$个，否则不断的周期性的从头取元素来填充；问所有操作做完之后，$1 \le i \le n$每个数在最终数组中的出现次数

- 考虑相邻两个操作$L_i \ge L_{i+1}$，显然后者会将前者替代，因此，用单调栈求出一个严格增的有意义的操作序列
- 考虑第$i$次操作的过程，相当于将$s_{i-1}$复制了$L_i/L_{i-1}$次，剩余$L_i\%L_{i-1}$长度迭代给$s_{i-2}$，直到最后剩余一个长度$l < L_0 $，于是新加$[1,l]$
- 因为$x \% p \le x/2$，其中$p<x$，因此$x$最多取模$log$次；在做$L_i$这个操作时，初始令$x=L_i$，每次二分找到第一个小于当前$x$且$j$最大的$L_j$，连边$(i,j)$边权为$x/L_j$，一个点最多连接$log$条边，所有边数目为$qlogq$，最终$x$剩余$x_0$留作点$i$的点权$v_i$
- 换句话说，任何时刻序列等价于前面不超过$log$种时刻的复制拼接，再加上一个剩余的$[1,v_i]$
- 考虑每个点权的贡献，其被算的次数，等价于根$q$到此点的路径边权乘积之和，简单的图上$dp$即可
- 合并每种点权数值的贡献，我们知道了前缀$[1,i]$使用了$cnt[i]$次，对$cnt$求后缀和，即可得到每种数的分布

8.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=1477  $F$题

注：不错的题目，$dp$+折半；给定$n \le 2 \times 10^5$个$d \le 16$的$d$维$01$向量(即二进制串)，求该序列的不严格$\le$的偏序子序列个数；偏序$\le$定义为前者是后者子集。本题有分块的做法，这里讨论用$dp$+折半的做法。

考虑到暴力$dp$的复杂度关键在于枚举子集，而子集有$2^{16}$种，若可降为$2^8$种就可以了；令$f[i]$表示从左到右考虑到$i$下标且$i$必取的合法方案数，且要求$a_i$含有$\le 8$个$1$；令$g[i]$表示从右到左考虑到$i$且$i$必取的合法方案数，且$a_i$含有$\ge 9$个$1$；这里转移直接暴力枚举子集即可，复杂度$O(n*2^8)$。考虑合并状态计算答案：将一个合法的方案，切割为左右两部分，左边部分只含不超过$8$个$1$，右边同理，其中有一个部分为空的方案数，是很容易求的，即$\sum f[i]+\sum g[i]$；两个部分均非空，枚举右边部分的第一个所取元素下标$j$，从左到右枚举，维护$f[]$的当前前缀和$S[]$，$ans+=\sum_{s \in a_j}S[s]*g[j]$，暴力枚举子集$s$即可；然后更新$S[a_j]+=f[j]$。总复杂度$O(n*2^8)$。

9.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=1477  $G$题

注：基础题，给定$n \le 500$个物品，每个有价值$w_i \le 500$，构造一棵哈夫曼树(最大深度$\le500$)，使得第$i$层每个节点的儿子数目不超过$r_i$，将物品放入叶子节点上，令$l_i$表示第$i$个物品的深度(根节点深度为$0$)，求$\sum_{i}w_i*l_i$最小值；令$dp[i][k][x]$表示考虑了前$i$层，放入了前$k$大的物品，且第$i$层还有$x$个位置可以放；转移讨论，本层多放入一个物品，和本层不再放物品进入下一层；$x$可以和$500$取$min$，故时间复杂度$O(n^3)$。







## 【13】dp优化：间歇性矩阵快速幂加速转移

1.http://codeforces.com/problemset/problem/954/F

2.http://acm.hdu.edu.cn/showproblem.php?pid=6395



## 【14】dp优化：wqs二分

可以直接认为，当 dp 值只有整数的时候，可以直接用整数进行二分。

学习资料：

https://m.doc88.com/p-949564862405.html

https://blog.csdn.net/CHHNZ/article/details/78827430

http://codeforces.com/blog/entry/49691

https://blog.csdn.net/chhnz/article/details/78846104

https://www.cnblogs.com/CreeperLKF/p/9045491.html



总结：

这一类题目，要求带限制选择严格k个物品，使得目标函数最优化

特点是：目标函数关于物品选择的个数k单调，设为g(k)，g(k)关于k单峰（形状是凸壳）

朴素的dp复杂度太高，如果去掉物品个数那一维的话，往往可以优化到O(n)或者较优的复杂度

二分一个C，表示每选择一个物品的Cost，则目标函数变为f(k)=g(k)-k*C

注意到：f'(k)=g'(k)-C单调，因此可以考虑二分C，dp求出全局无物品个数限制意义下的dp最优值和物品个数(D,X)

用X与题目给的k比较，调整二分的方向；最后获得X=k，ans=D+C*k

当然，对于C，是加入答案，还是从中扣除，根据题目具体情况而定



细节说明：

往往我们优化过的dp，每次求的X是能够取到最优dp值的最大物品个数，

也就是说如果当前物品必取，大于等于不取当前沿用之前最值，就更新，然后与k比较(>=k为一边方向)

这样做的根据是：我们总是找使得x>=k成立的最大或最小的C(C如果是小数，不必十分精确)

每次只要符合这个要求，那么我们记录二元pair(dp最优值，物品个数)

设想一下，比我们找的C次一点的C'，会使得h(C')=x' < k成立，那么[h(C')+1,h(C)]这一段C相同，因而dp最优值相同

而题目的k必然在其中的，因此不影响答案求法的正确性




题目：

1.http://codeforces.com/problemset/problem/958/E2

2.http://codeforces.com/problemset/problem/739/E

3.https://www.lydsy.com/JudgeOnline/problem.php?id=2654

4.http://poj.org/problem?id=1160

5.https://www.lydsy.com/JudgeOnline/problem.php?id=5252

6.https://www.lydsy.com/JudgeOnline/problem.php?id=5311

7.http://codeforces.com/gym/101981/attachments B题

8.http://uoj.ac/problem/240





## 【15】计数dp：映射原理+简单容斥

1.http://codeforces.com/problemset/problem/1093/F

2.http://codeforces.com/group/aUVPeyEnI2/contest/243687 C

注：烷烃同分异构体(500个点以内)，无根树计数dp





##【16】与自动机有关的dp：隐藏自动机

1.http://codeforces.com/problemset/problem/1142/D

注：自动机思想+dp计数，统计一类子串数量

题目会先定义一个多重集合或者串空间，往往元素数量巨大或者无穷多，而*<u>自动机的本质功能就是分类表示与识别，用有限的状态表示无限的元素</u>*，我们需要分析空间元素生成的规则，从而提取特征，设计状态：

本题中，$1-9$在集合里面，一个元素$x \in S，rank(x)=c \pmod{11}$，则$x$可以扩展出$10x+i,i \in [0,min(c,10))$，也就是说最后可以加一个严格小于自己排名的数字

**这个空间有以下基本性质：**

- 单调性，若一个数字串$s \in S$，则$s$的任何一个前缀均$ \in S$；若$s \notin S$，则$s+t \notin S,\forall t$
- 若$s \in S$，$p[i]$为$s$的任一个非空前缀，则$rank(p[i])\%11>s[i+1]，\forall \space i \in [1,n-1]$

第一个性质告诉我们，只要对每个下标$i \in [1,n]$，求以此为起点的可延续的最长合法长度$len(i)$即可

第二个性质告诉我们，前缀串的$rank\%11$与后面可加的数字有关，这表明$rank\%11$是状态设计的依据，而后面可以加的数字是某个状态可选的转移依据

我们追加$0$元素到集合$S$中，$rank(0)=0$，所有元素按照$rank \% 11$分类，以此为据设立自动上的$11$个状态节点，再加一个空节点$Null$，是在自动机上运行串的起点状态；每个状态的可选转移按上述，我们需要求出状态$x$在$c$方向，转移到的状态$y$

画一个图，$0-10$元素，为第一行(共$11$个元素)，然后第二行为第一行元素的按序扩展序列，$0$扩展$0$个，$1$扩展$1$个，$\dots$，$10$扩展$10$个，第二行共$55$个元素，且是升序的紧接第一行元素的，注意此处$10$多出现了一次，但是我们不再图中删除，在公式中$-1$即可

将第一行$11$个元素看成一组，跳过第二行的$10$，以后每$11$个元素看成一组，可以发现，每组第$0$个元素$rank$是$11$的倍数，因此一组和上面第一行的规律相似，我们只需要前两行数据，因为我们要计算转移$(x,c)=y$，这里的$x \in [0,10]$，是第一行的元素，那么$[0,x-1]$这些元素扩展完毕了，共$x(x-1)/2$个，而这个转移是$x$的第$c$个转移($[0,c]$转移完毕)，共$c+1$个，加之得到$y$第二行的排名，减去开头的多余的一个$10$，加上第一行的$10$个元素，则总排名为$y=x(x-1)/2+c+10 \pmod{11}$，这个函数记作$nxt(x,c)$

**下面的$dp$是很自然的：**

令$dp[i][j]$表示在自动机上的状态$j$，从串的下标$i$开始向右匹配的最长匹配长度

显然，如果$j  \le s[i]-'0'$，则一步都走不出去，$dp$值为$0$，我们忽略这种转移

而$i \in [1,n]$，$j>s[i]-'0'$，则$j$这个状态存在转移方向$s[i]-'0'$，即至少可以走一步，走了一步之后$j$走到了新状态$nxt(j,s[i]-'0')$，故：$dp[i][j]=dp[i+1][nxt(j,s[i]-'0')]+1$

计算答案时，每个下标从$Null$状态开始在自动机上走：

$ans=\sum_{i=1}^ndp[i][Null]=\sum_{i=1}^n(dp[i+1][s[i]-'0']+1)$

**总结**

对某个状态空间构造自动机，其关键就在于空间元素扩展过程中有什么***变化的且有穷的属性***，可以考虑作为状态设计依据





## 【17】与子序列有关的dp

1.http://codeforces.com/problemset/problem/1096/D



## 【18】动态dp

### 参考资料

https://www.cnblogs.com/YoungNeal/p/10360291.html

http://immortalco.blog.uoj.ac/blog/2625

https://www.luogu.org/blog/gkxx-is-here/what-the-hell-is-ddp （洛谷日报 #130）

https://www.luogu.org/problemnew/solution/P4719

### 动态dp

1、用树剖实现复杂度是 $O(nlog_2^2n*矩乘复杂度)$

2、LCT实现复杂度是 $O(nlog_2n)$，常数比较大

只需要用到其中的access操作。

3、全局平衡二叉树实现复杂度是 $O(nlog_2n)$，常数非常优秀，可以替代一类静态树上的路径问题。

### 题目

https://ac.nowcoder.com/acm/contest/882/E

https://www.luogu.org/problemnew/show/P4719

- 写出dp转移
- 修改结点价值，维护dp值
  - 序列问题可以用数据结构维护矩阵乘法
  - 树上问题需要先树剖，维护和重儿子之间的关系，修改一个点的时候，它所在重链顶端节点的父亲的矩阵会改变，需要一直跳上去更新。只维护重链顶端的节点的真实dp值，其他节点的dp值均需要在线查询。

https://www.lydsy.com/JudgeOnline/problem.php?id=4712

https://www.lydsy.com/JudgeOnline/problem.php?id=5210

http://uoj.ac/problem/441

https://www.luogu.org/problemnew/show/P4751

https://www.lydsy.com/JudgeOnline/problem.php?id=5287

https://www.lydsy.com/JudgeOnline/problem.php?id=4732

https://www.lydsy.com/JudgeOnline/problem.php?id=4911


##【19】括号序dp/扫描线式线性插头dp

1.http://codeforces.com/problemset/problem/626/F

注：经典的线性插头dp或者说括号序dp

**总结**

此种$dp$常设状态表示$f[i][j][\dots]$表示考虑前$i$个元素，有$j$个带匹配插头，且满足一些其他限制的答案

状态转移常有以下几类，分类讨论即可：

- 新建一个带匹配插头$\rightarrow f[i+1][j+1],*1$

- 匹配一个之前的带匹配插头$\rightarrow f[i+1][j-1],*j$

- 此元素作为中间元素考虑/不选$\rightarrow f[i+1][j],*1/*j/\dots$

- 此元素单独构成一个自闭的自插头(新建且立刻与自己匹配)$\rightarrow f[i+1][j],*1$

- 先与之前的某个插头匹配，然后再新建一个插头$\rightarrow f[i+1][j],*j$

当然，转移还受其他约束限制影响，一般答案为$f[n][0][\dots]$

2.http://codeforces.com/problemset/problem/466/D

注：与上题相似







## 【20】dp组合与嵌套

1.http://codeforces.com/problemset/problem/1158/F

注：难题，当权值比较小的时候，用状压dp；权值比较大，用下标转移的普通dp

**结论：判定一个序列(字符集为$[1,c]$)包含长度为$p$的任何一个同字符集的序列以之为子序列，方法如下：**

称上述最大的$p$为序列的密度，显然有单调性，即对$\forall i \le p$依然满足条件

每次寻找最小的下标$j$，使得序列前缀$pre[j]$满足：包含$\forall i \in [1,c]$至少一次，且包含字符$a[j]$严格一次，该前缀称为一个块，删之重复操作，能够构造的最大块个数即是密度$p$

证明：原序列为$a$，删除一个块前缀为序列$a'$，只要证明$a$密度为$p$，等价于$a'$密度为$p-1$

必要性显然，充分性：$a$包含任何一个长度为$p$的字符集为$c$的子序列，那么必然包含长度为$p$，且以字符$a[j]$开头的任何子序列，其中$j$为第一个块终点且我们取(如果不取，可以调整到取)，而第一个块中不包含其他位置的$a[j]$字符，那么取这个$a[j]$，在去掉第一个块前缀之后$a'$即包含任何长度为$p-1$的字符集为$c$的子序列，命题得证

注意此结论与序列自动机的性质有关，参见字符串相关词条，含证明

**题解：**令$dp[i][j]$表示在$[1,j]$中取了的子序列里，构成$i$个块，第$i$个块以下标$j$结尾且$j$必取的方案数或者子序列个数，下面有两种不同的辅助$dp$获得上述$dp$值：

*$状压dp$*

令$u[i][j][mask]$表示考虑$[1,i]$中选了的子序列里包含$j$个块，且第$j+1$个块可能残缺，其包含字符的情况为二进制$mask$
$$
mask>0,a[i] \in mask: \space u[i][j][mask]=2u[i-1][j][mask]+u[i-1][j][mask-2^{a[i]-1}] \\
mask>0,a[i] \notin mask: \space u[i][j][mask]=u[i-1][j][mask] \\
mask=0: \space u[i][j][0]=u[i-1][j][0]+dp[j][i] \\
dp[j][i]=u[i-1][j-1][2^c-1-2^{a[i]-1}] \\
dp[0][0]=u[0][0][0]=1 \\
时间复杂度O(nK2^c),K=n/c
$$
普通$dp$

令$num[i][j]$表示$[i,j]$中下标$j$必取，且取出一个子序列构成恰好一个块的方案数；令$cnt_x[i][j]$表示$[i,j]$中字符$x$出现的次数，下面意思是说除了字符$a[j]$，其他字符至少取一个，而字符$a[j]$取且仅取下标$j$
$$
num[i][j]=\prod_{x=1,x\ne a[j]}^c (2^{cnt_x[i][j]}-1) \\
dp[i][j]=\sum_{t=0}^{i-1}dp[i-1][t]*num[t+1][j] \\
dp[0][0]=1 \\
时间复杂度O(n^2K)
$$
计算答案
$$
f[t]=\sum_{i=1}^n dp[t][i]*2^{n-i},t \in [1,K] \\
ans[t]=f[t]-f[t+1], t \in [0,n] \\
总体时间复杂度O(nKmin(n,2^c)) \ge O(n^3/logn),c以logn为界
$$
**总结：**

这是一种序列的切割$dp$，但是一个块中方案数又可以和权值范围有关系，那么就可以用这种经典的组合$dp$

有时候，$dp$一步很难表示出答案或者转移，需要很多的辅助量，可能需要$dp$嵌套，当有多个量纠缠在一起时，我们要充分挖掘之间的联系，用它们相互表示

## 【21】凸包dp

http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=010231

一类凸包上的 dp 的方法。

类似的题目还有 bzoj 3778

按照级角序枚线段，依次松弛 dp 数组。每次相当于加入一个三角形（需要判断三角形会不会退化）。



##【22】邻项最值dp

1.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=1492 A题

注：难题，相邻三项最值有关的$dp$；给定长度为$n$的数组$w[1..n]$，定义长度为$n$的数组$a$，$a_i \in [1,n]$，其权值为$f(a)=\prod_{i=3}^nw[max\{a_{i-2},a_{i-1},a_i\}]$，求$\sum_af(a)$。

- 令$f[i][j][1]$表示考虑了前$i$个下标，且$1..i$下标都已经确定(填满数字)，且$max(a[i-1],a[i])=a[i]=j$，即$a[i-1] \le a[i]$的所求答案(即$\sum$)；令$f[i][j][0]$表示考虑了前$i$个下标，且$a[i-1]=j>a[i]$，且$1..i-1$这些下标已经确定(填好数字)，但是$i$下标尚未确定(可以认为暂时取充分小量，比如$0$，后面具体方案可以替换为$1..j-1$)的所有答案；考虑初始值边界，$f[2][i][0],f[2][i][1]$显然应该先用方案数代替所有答案，这是因为在第一次转移时，后面追加一个确定元素，将$max$乘上之后，就是前三项的答案
- 令$h[j]$表示当前$1..i$已经考虑且确定之后，$max(a[i-1],a[i])=j$的答案贡献，其前缀和$H[j]$即是$\le j$的答案
- 令$g[j]$表示当前$1..i$已经考虑，$1..i-1$已经确定，但是$i$尚未确定，暂时是充分小量，且$j+1=a[i-1]>a[i]$，考虑追加一个元素$a[i+1]=j$之后的$1..i+1$的答案；其后缀和$G[j]$则事实上表示$a[i+1]=j,a[i-1]>j,a[i]$暂时是充分小量的答案；因为同样条件下$a[i+1]$向下调整其实是不会影响答案的，因为这三项最大值确定是$a[i-1]$
- 计算$f[i+1][j][0]$，分两类：若$a[i-1] \le j$，由于$a[i]=j$，故$a[i-1] \le a[i]$，可看成由$f[i][j][1]$转移，转移系数为$w[j]$，因为$max(a[i-1],a[i],a[i+1])=a[i]=j$是确定的；若$a[i-1]>j$，有一定技巧性，方案数和答案都等价于，直接交换$a[i],a[i+1]$的结果，则$a[i+1]=j,a[i-1]>j,a[i]$是充分小量，注意到这即是$G[j]$
- 计算$f[i+1][j][1]$，分两类：若$a[i-1]\le j$，因为有$a[i] \le a[i+1]=j$，故这种情况显然是说$max(a[i-1],a[i]) \le j$，注意到应该从$H[j]$处转移过来，转移系数为$w[j]$，因为追加的元素$a[i+1]$为最大值；若$a[i-1]>j$，因为有$a[i+1]=j$，若将$a[i]$看成是从充分小量填充得到，则可从$G[j]$转移得到，$a[i] \le a[i+1]=j$，故$a[i] \in [1,j]$，转移系数显然为$j$

初始值：$f[2][i][0]=1,f[2][i][1]=i$

主要转移：
$$
h[j]=f[i][j][0]*(j-1)+f[i][j][1] \\
g[j-1]=f[i][j][0]*w[j] \\
H[j]=\sum_{k=1}^jh[k] \\
G[j]=\sum_{k=j}^ng[k] \\
f[i+1][j][0]=f[i][j][1]*w[j]+G[j] \\
f[i+1][j][1]=H[j]*w[j]+G[j]*j
$$

答案：$H[n]$，表示考虑完了$1..n$且全都确定填满，$a[n-1],a[n]$的最大值不超过$n$的所求答案，即原答案

总结：注意这题的状态设计有些与众不同之处在于，不是说考虑了$1..i$这些下标，就果断的将其全部填满确定；考虑到转移的方便，应该状态中引入充分小量，即未确定量，这种量只有一个大概范围，但是尚没有精确值，而且不会作相邻三项的最值，后面转移时，根据需要填充无穷小量即可；这个题目不太容易表达清楚，最好结合数量关系图示进行理解

##【23】 dp套dp

主要类型是问你有多少方案能够满足一个条件，而对于一种方案，需要用dp去判断符不符合，那么一般考虑这个dp的转移涉及到的那些项，把它们的值合起来当作一种状态来dp

1.http://acm.hdu.edu.cn/showproblem.php?pid=5079

有多种做法，第一种根据求最大连续白色正方形的dp式逐格转移，那么只要记录前n+1个dp值和已有的最大值即可。第二中是先通过容斥转化为求最大值小于k的方案数，然后逐行转移，状态记录n+1-k个数，表示这些列向后k列这个区间往上白色数量最小值。










# 6.博弈论，贪心和构造

##【1】博弈论基础

1.http://acm.hdu.edu.cn/showproblem.php?pid=2149

2.http://acm.hdu.edu.cn/showproblem.php?pid=3980

3.http://acm.hdu.edu.cn/showproblem.php?pid=3595

4.http://acm.hdu.edu.cn/showproblem.php?pid=1846

5.http://acm.hdu.edu.cn/showproblem.php?pid=5754

6.http://acm.hdu.edu.cn/showproblem.php?pid=3032

7.http://acm.hdu.edu.cn/showproblem.php?pid=5011

8.http://acm.hdu.edu.cn/showproblem.php?pid=1730

9.http://acm.hdu.edu.cn/showproblem.php?pid=1525

10.http://acm.hdu.edu.cn/showproblem.php?pid=2516

11.http://acm.hdu.edu.cn/showproblem.php?pid=1517

12.http://acm.hdu.edu.cn/showproblem.php?pid=4387

13.http://acm.hdu.edu.cn/showproblem.php?pid=1907

14.http://codeforces.com/problemset/problem/832/A

15.http://codeforces.com/problemset/problem/812/E

16.http://codeforces.com/problemset/problem/794/E

17.http://codeforces.com/problemset/problem/786/A

18.http://codeforces.com/problemset/problem/768/E

19.http://codeforces.com/problemset/problem/731/E

20.http://www.lydsy.com/JudgeOnline/problem.php?id=1443

21.http://codeforces.com/problemset/problem/917/B

22.http://codeforces.com/problemset/problem/859/C

23.https://nanti.jisuanke.com/t/31442

24.http://codeforces.com/problemset/problem/36/D

25.http://codeforces.com/gym/101981/attachments A题

26.https://codeforces.com/problemset/problem/1099/F

注：博弈+简单贪心+树dp+线段树

27.https://codeforces.com/problemset/problem/317/D

注：取x同时删除x^k(k>=1)，幂次不交链游戏和

28.https://codeforces.com/problemset/problem/1100/D

注：鸽巢原理+棋盘逼近问题(控制一个对象，将其他对象逼近角落)

29.https://codeforces.com/problemset/problem/38/F

注：既有必胜又有得分的题目，游戏状态状态可以表示成类似的三元组(op,x,y),

op==1表示此状态下先手必胜，-1必败，0平局或者无法确定；x当前先手得分，y当前后手得分；

那么每个游戏状态在转移的时候，相当于在所有后续游戏状态调整后的评价中，求最小值；

最小值bool逻辑按照(1<,3>,2<),123为三个分量，<表示越小越好；

当前游戏状态评价应该为此最小值，第一维取相反数，二三维交换；

30.https://codeforces.com/problemset/problem/154/D

注：分类讨论，对称思想，nim游戏扩展($Bash$博弈扩展)；每次取石子个数$\in[a,b]$，注意平局

31.https://codeforces.com/problemset/problem/273/E

注：sg函数取值为[0,2]，sg函数分布为块状，块个数很少，未得到证明

博弈必胜计数题，一个个生成块，博弈+二分+简单dp

32.https://codeforces.com/problemset/problem/138/D

注：实现小技巧，当n行m列菱形网格(黑白染色，同色格子)旋转时，可认为坐标变换为(i,j)->(i+j,j-i+n)，类比于切比雪夫坐标变换

33.https://codeforces.com/problemset/problem/1110/G

注：等价转换，分类讨论，探索充要条件，构造性

34.https://codeforces.com/problemset/problem/98/E

注：带欺骗的博弈概率dp，考虑玩家的心理决策表(行为先手是否欺骗，列为后手是否相信)，存储先手获胜概率，每个元素按照对应的概率分布列分类讨论；一个游戏状态先手最优策略为是否欺骗的线性组合，设选择欺骗的概率为p，求最值

35.http://acm.hdu.edu.cn/showproblem.php?pid=3537

注：一种硬币游戏，翻动不超过三枚硬币

36.https://codeforces.com/problemset/problem/142/D

注：经典的nimk游戏，注意平局细节

37.https://codeforces.com/problemset/problem/1076/G

注：博弈论+线段树+函数变换复合/嵌套(结合律)+简单dp

首先分析某个位置i的NP态特性，对a[i]分奇偶，且仅与后面连续m个NP状态有关，看成是关于长度为m的二进制串的状态变换；此处可优化为：注意到二进制空间中，每个状态可以分成很多类，每类仅与最靠近的P态位置有关；令h[i]表示传入二进制状态s最靠近的P态位置为i时，变换后此位置变为多少；以h代替串s本身，h[0..m]，其中h[m]表示串s在0..m-1位置无0，h易可合并；查询时，求出区间合并后的总变换，传入s=全1串，表示禁止转移，相当于取出h[m]；


38.https://www.lydsy.com/JudgeOnline/problem.php?id=5326

39.http://codeforces.com/gym/102220/problem/F

注：有向图博弈扩展+spfa

经典的有向图(有自环，无重边)博弈扩展，$NP$状态定理推广，$s_{i,j}$表示$j$这个人在$i$这个点时游戏状态，$0$为待定或者平局，$1$表示必胜，$-1$表示必败，注意以上定义都是针对$j$这个人所在阵营；从出度为$0$的点$u$且人为任意$p$的游戏状态$(u,p)$出发，利用$spfa$递推；对每个队列中待扩展状态$(u,i)$，先计算上一个人$j$，弄清楚$j$支持哪一方，即$j$的目的，以及$j$是否支持$i$所在方(一个$int$量$c \in \{1,-1\}$)，则用判断式$c==s_{u,i}$可以表示$j$这个人是否可以在某个游戏状态通过选择一步转移到状态$(u,i)$达到自己的目的(即支持$i$所在方，且状态$(u,i)$中$i$所在方必胜；反对$i$所在方，且状态$(u,i)$中$i$所在方必败)，如果此状态没访问过，那么$s_{v,j}=j$是否支持己方，入队；$c==-s_{u,i}$，则应该使得每个前驱状态出度减$1$，无可奈何的状态(出度减为$0$)则只有违背$j$的意愿$s_{v,j}=j$是否支持己方的相反数，入队；这两种情况入队，其他情况表示出现平局，不对其他状态产生有效影响，注意到每种状态最多入队两次(因为上述每种情况最多入队一次)，时间复杂度为$O(n+m)$

40.https://www.luogu.org/problemnew/show/P4643



41.http://poj.org/problem?id=2931

注：经典的不平等博弈，$surreal \space number$的应用，参见国家集训队论文2019例题

$bush$游戏的基础版本的特殊情形，不需要实际求出游戏数，只要分析出结论即可

42.http://acm.hdu.edu.cn/showproblem.php?pid=6597

注：经典的不平等博弈

采用 $surreal \space nubmer$ 计算游戏局面，最后计算游戏和的状态。

注意到游戏局面，没有超出 $surreal \space nubmer$ 的表示范围；

如果计算出来的数 $>0$ ，左边的人获胜； $<0$ 右边的人获胜； $=0$ 表示后手获胜；注意没有先手获胜的情况；更没有其他情况。

43.http://acm.hdu.edu.cn/showproblem.php?pid=3404

注：高维(二维)硬币游戏

44.http://poj.org/problem?id=3533

注：高维(三维)硬币游戏

45.https://codeforces.com/gym/102012/problem/K

注：$2018$徐州区域赛，纳什均衡点(纯策略和混合策略)

46.http://www.51nod.com/Challenge/Problem.html#problemId=1963

注：基础题，树上阶梯博弈，根层数为$0$，求奇数层所有点权的异或和

47.http://acm.hdu.edu.cn/showproblem.php?pid=4111

注：中档题，$2011icpc$成都$A$题，多组数据，给定$n \le 50$堆石子，每次玩家可以任选非空的一堆，取走一个石子；或者，选择非空两堆合并为一堆；不能操作输，判断先手是否必胜。注意到一堆石子个数$x$，若$x \ge 4$且为偶数可以规约为$4$，$x \ge 3$且为奇数可以规约为$3$，因此每堆石子数量$\in [1,4]$，令$dp[cnt_1][cnt_2][cnt_3][cnt_4]$表示每种数量各有多少堆的先手胜负情况，可以利用$NP$状态定理转移，且此$dp$独立于多组询问，时间复杂度$O(50^4*\omega(4))$。







##【2】贪心


指定题目：

1.http://codeforces.com/problemset/problem/835/B

2.http://codeforces.com/problemset/problem/830/A

3.http://codeforces.com/problemset/problem/827/B

4.http://codeforces.com/problemset/problem/773/C

5.http://codeforces.com/problemset/problem/796/F

6.http://codeforces.com/problemset/problem/769/B

7.http://codeforces.com/problemset/problem/758/E

8.http://codeforces.com/problemset/problem/754/D

9.http://codeforces.com/problemset/problem/748/E

10.http://codeforces.com/problemset/problem/735/C

11.http://codeforces.com/problemset/problem/732/E

12.http://codeforces.com/problemset/problem/721/D

13.http://codeforces.com/problemset/problem/908/F

14.http://codeforces.com/problemset/problem/917/A

15.http://codeforces.com/problemset/problem/922/D

16.http://codeforces.com/problemset/problem/946/E

注意：比较函数要满足传递性,反对称性，反自反性

17.http://codeforces.com/problemset/problem/865/D

注：替换式优先队列贪心

18.http://codeforces.com/problemset/problem/962/E

注：经典题目：一维点的连通性/一维最小点归属问题

19.http://acm.hdu.edu.cn/showproblem.php?pid=6299

注：与括号序列及其最简二元组表示有关的贪心

20.http://codeforces.com/problemset/problem/1031/F

注：经典问题，一维2n个点，最小距离和匹配贪心

21.https://vjudge.net/contest/274500#problem/D

22.http://codeforces.com/problemset/problem/1082/E

注：最大连续字段和变种贪心

23.https://cn.vjudge.net/contest/274676#problem/G

注：二进制按位递归式贪心，a[]进行sort之后，构成天然01字典树

24.http://codeforces.com/problemset/problem/1092/E

注：经典问题：森林连边构造树，最小化直径；

与直径有关的贪心，利用直径性质可以证明：

树上中心，在直径中点；森林构造成菊花树林，本题是树上中心模板题

25.http://codeforces.com/contest/1090/problem/L

26.http://codeforces.com/problemset/problem/1088/E

注：最大连续子段和树上推广，同时计数(最大数量)

27.http://codeforces.com/problemset/problem/1088/F

注：题目有个地方没有强调，每个非最小值点有且仅有一个点权比其小的邻接点

证明：分三步证明

1)先把贡献拆成边的贡献式，也就是说，问题本质相当于求完全图某种最小生成树权值

2)证明非最小值点负责连一条出边，且这个连边操作，点与点之间是无序的

3)证明每个点u必然与自己祖先的某个点v相连，而不会是非祖先点，这是因为可以很容易调整为取v=lca(u,v)，公式具有单调性

技巧：当树上倍增被卡空间时(空间nlogn)，可以不开倍增数组，dfs时维护关于深度(根深度为0)的人工栈，里面维护根到当前所访问点的路径(当前路径，存储点编号)

28.http://codeforces.com/problemset/problem/1082/E

29.http://codeforces.com/problemset/problem/1091/F

30.http://codeforces.com/problemset/problem/1095/F

注：最小生成树变种贪心，只需要考虑除读入边之外的一些关键边，简单的调整法就可以证明

31.http://codeforces.com/problemset/problem/1097/C

注：与括号序列及其最简二元组表示有关的贪心

32.http://codeforces.com/problemset/problem/1097/E

注：与LIS树有关的贪心，关于LIS树是说：

**$LIS$树**

给定一个排列，$1-n$中任何一个数对应于树上一个节点，根为$0$元素，根到节点$i$的有序路径表示以$i$这个值为结尾的字典序最小的最长$LIS$方案，其构造方法如下：

维护一个单调迭代数组(是这样一个数据结构，不妨设单调递增，支持末端插入元素的动态数组，单点替换，修改操作不影响数组单调性)，$s[1..cnt]$，其中某个时刻$T$时，插入元素$x$，二分查找$s$中第一个大于$x$的数的下标$i$，$s[i]$由$y$替换为$x(y>x)$表示以值$x$结尾的$LIS$长度为$i$，且存在一个字典序最小的方案，方案中$x$的前驱元素应该是此时的$s[i-1]$，利用前驱关系构建出来的显然是一棵有序树(儿子们相对有序)，元素$y$被$x$替代，表明$x$和$y$在同一层，且$x$在$y$的右侧；这个数组在某个时刻的数学意义是这棵树的右侧投影节点编号序列，这棵树的深度是整个排列的$LIS$长度，同层元素递减；

这个结构可以很方便的证明排列的最小递增子序列的切割定理，一个排列最少可以分成$k$个单调递减的子序列，其中$k$为最长上升序列的长度；这是因为，只要把树上每层的元素拿出来，就是一个方案，这表明$k$至多是$LIS$长度，而树上深度最大的叶子节点，显然要至少深度个递减序列覆盖，所以$k$至少是$LIS$长度，故$k=len(LIS)$得证；

这个题目是说：如果对于长度为$n$的任意排列，只需要最多$k$个单调切割子序列就足够了，那么给定一个长度为$n$的排列，构造不多于$k$的切割方案，在此意义下最耗费资源的排列显然为1   3 2   6 5 4   10 9 8 7 ... 需要寻找最小的$k$使得$k*(k+1)/2 \ge n$，这就是答案。

这个特殊排列的最少单调切割序列个数确实是$k$，这是因为：我们假设$n=k*(k+1)/2$，不够可以补全，我们观察最后一个递减连续序列，长度必然为$k$，如果方案中有这个递减序列存在，那么可以用数学归纳法证明更小规模的问题(递降直到没有)；如果不存在，那么容易看到最后一个递减连续序列至少需要$k$个单调序列覆盖，也就是答案$\ge k$，而整个排列确实$k$个单调序列就足够了，因为可以取这个$k$个递减序列1,3 2，6 5 4,10 9 8 7...；所以上述不等式：答案$ \ge k$可以取到等号；

一个比较优的但未必是最优的单调切割方案(可以递增可以递减)，可以是：当一个排列的$LIS$长度$>k$，则去掉树上的一条最长根-叶子链，然后转化为子问题递归解决(相当于$n$至少减少$k$，$k$至少减少$1$，因为$n' \le (k-1)*k/2$)；否则，直接利用每层切割方案，构造严格深度个($\le k$个)递减序列。注意到这样构造出来的方案，具有不多于$k$个切割子序列。

由于其结构有一定性质，可以在数据结构中结合$LIS$经典问题；$LIS$树的构造有模板($LIS_T$)。



**$LIS$树扩展**

对每个节点$u$，假设深度为$d$，在$d-1$层中二分第一个严格小于$u$的节点$v$，连接红有向边$u \rightarrow v$

这表示节点$u$每次可以选择一个父节点$t \in [v,p[u]]$，向上走过去，直到走到根，$reverse$可以对应任何以$u$结尾的$LIS$方案，当然每次选择对应最左边的$v$，可以构造字典序最大的方案

此方法可以轻松解决$LIS$相关计数等问题，在建树之后只需要$O(n)$预处理，即可获知$f[i]$以$i$结尾的$LIS$方案数，就可以不用一些数据结构去优化计数$dp$的转移了

也可以在此基础上用线段树优化建图，但目前尚未发现相关经典的应用





33.http://codeforces.com/problemset/problem/1119/E

注：多带一型贪心，指的是每次取k个相等的数x，再多带一个<=x的数，这种贪心就是记录剩余几个单独的没被匹配的，每次扫描到一种数之后，优先匹配这些剩余的，然后自我匹配，再更新数量，维护剩余数

34.https://www.lydsy.com/JudgeOnline/problem.php?id=5289

35.http://codeforces.com/problemset/problem/125/D

注：鸽巢原理+贪心构造，把没有相同元素的序列拆分为两个等差数列

36.http://codeforces.com/group/aUVPeyEnI2/contest/243687 F

37.http://codeforces.com/problemset/problem/650/D

注：LIS基本性质分析+分类讨论，半动态单调修改LIS：如果修改某个下标的值，修改独立，那么求新的LIS长度

本题涉及：判断下标$i$，是否可能存在于一个$LIS$方案中，记为$ok[i]$；判断下标$i$，是否被所有$LIS$方案包含，记为$yes[i]$

令$f[i]$表示以下标$i$结尾的$LIS$长度，$g[i]$表示以下标$i$开头的$LIS$长度，则$ok[i] = (f[i]+g[i]-1==L)$，其中$L$为整个序列的$LIS$长度

令$yes_l[i]$表示是否不存在下标$j<i$，满足$ok[j]\&\&a[j] \ge a[i]$，$yes_r[i]$表示是否不存在下标$j>i$，满足$ok[j]\&\&a[j] \le a[i]$，则$yes[i]=yes_l[i]\&yes_r[i]$，采用类似于前缀和/扫描线的算法维护最大值或者最小值即可$O(n)$预处理

本题分析：单点修改($a[i]\rightarrow b[i]$)之后，将所有子序列分类：是否包含下标$i$

若包含$i$，则最大长度为：$f'[i]+g'[i]-1$，注意这里数组是取代之后的

若不包含$i$，则相当于在原数组$a[]$中去掉下标$i$，讨论下标$i$是否是所有原$LIS$必经的：若$yes[i]$，则去掉$i$，答案会是$L-1$；否则，答案不变$L$；因此，此类答案为$L-yes[i]$

**$LIS$其他性质**

对任意$i \in [1,n]$，均满足：任取一个$LIS$方案$e$，$a[i]$在$e$中的排名相同



38.http://acm.hdu.edu.cn/showproblem.php?pid=6592

注：构造字典序最大以及最小的，最长合唱队形，读入序列不是排列

$f[i][0]$ 表示 $a[i]$ 一定取，序列 $a[1..i]$ 的最长上升子序列长度。
$f[i][1]$ 表示 $a[i]$ 一定取，序列 $a[1..i]$ 的最长单峰子序列长度。

$g[i][0]$ 表示 $a[i]$ 一定取，序列 $a[i..n]$ 的最场下降子序列长度。
$g[i][1]$ 表示 $a[i]$ 一定取，序列 $a[i..n]$ 的最长单峰子序列长度。

转移式子挺容易想的，留给读者思考。

枚举单峰子序列最高点下标，可以很方便的求出最长单峰子序列长度。

接下来逐位确定字典序最大的子序列。经过仔细观察可以发现，将候选集合按照下标排序之后，它们的值是单调的。利用该性质即可得出字典序最大最小的最长单峰子序列。



39.http://acm.hdu.edu.cn/showproblem.php?pid=6586

注：求字典序最小的合法方案，逐位贪心确定，寻找合法性判断的充要条件

39.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001421 I

这题状态数应该是没法优化的，思考的时候有两个切入点，一个是优化转移，另一个就是正解：

考虑 $(x_1, y_1)$ 走到 $(x_2, y_2)$ ，如果先横着走再竖着走（这里的坐标系是从上到下 0 ~ n ，从左到右 0 ~ m ），花费是 $a_{x_1} \times (y_2 - y_1) + b_{y_2} \times (x_2 - x_1)$；如果先竖着走再横着走，花费是 $a_{x_2} \times (y_2 - y_1) + b_{y_1} \times (x_2 - x_1)$。

$a_{x_1} \times (y_2 - y_1) + b_{y_2} \times (x_2 - x_1) \le a_{x_2} \times (y_2 - y_1) + b_{y_1} \times (x_2 - x_1)$

$(a_{x_1} - a_{x_2}) \times (y_2 - y_1) \le (b_{y_1} - b_{y_2}) \times (x_2 - x_1)$

$\frac{(a_{x_1} - a_{x_2})}{(x_2 - x_1)} \le \frac{(b_{y_1} - b_{y_2})}{(y_2 - y_1)}$

也就是说，用 $(i, a_i)$ $(j, b_j)$ 形成两个下凸壳，从凸壳的最左边的点开始走，谁的斜率小就走谁，答案加上走的距离乘花费。

走凸壳的原因是因为：如果当前能走斜率小的，没必要走斜率大的。

40.http://acm.hdu.edu.cn/showproblem.php?pid=6633

每个数值可能在的下标是一段区间。将这些区间求出来。贪心的确定即可。

41.http://acm.hdu.edu.cn/showproblem.php?pid=5527

注：中档题，给定面值分别为$1,5,10,20,50,100,200,500,1000,2000$的每种的数量，求凑出$p$所使用的最多个数。先全部都取，转化为最少个数的版本；如果去掉$50,500$两种面值，则构成整除全序集；那么只要每次能选择大的就选择大的做变进制贪心即可；枚举$50,500$分别取奇数次或偶数次，奇数次可以先取走一个，剩下的个数整除$2$，加到$100,1000$个数之中，则转化为全序集问题。








##【3】构造

1.http://codeforces.com/problemset/problem/643/B

2.http://codeforces.com/problemset/problem/708/B

3.http://codeforces.com/problemset/problem/721/D

4.http://codeforces.com/problemset/problem/730/B

5.http://codeforces.com/problemset/problem/740/B

6.http://codeforces.com/problemset/problem/746/G

7.http://codeforces.com/problemset/problem/715/D

8.http://codeforces.com/problemset/problem/804/E

9.http://codeforces.com/problemset/problem/835/E

10.http://codeforces.com/problemset/problem/665/D

11.http://codeforces.com/problemset/problem/638/A

12.http://codeforces.com/problemset/problem/644/A

13.http://codeforces.com/problemset/problem/593/C

14.http://codeforces.com/problemset/problem/549/B

15.http://codeforces.com/problemset/problem/584/E

16.http://codeforces.com/problemset/problem/906/B

17.http://codeforces.com/problemset/problem/936/C

18.http://codeforces.com/problemset/problem/959/C

19.http://codeforces.com/problemset/problem/990/D

原图与补图联通块数目限制的邻接矩阵构造

20.http://codeforces.com/problemset/problem/990/F

流量守恒无向图的边权构造

21.http://codeforces.com/problemset/problem/959/D

两两互质的带条件数组的构造

22.http://codeforces.com/problemset/problem/960/C

条件子序列计数相关构造

23.http://codeforces.com/problemset/problem/1016/D

注：化归，独立考虑bit，极大子矩形的应用（尽可能简单自由）


24.http://acm.hdu.edu.cn/showproblem.php?pid=6300

25.https://vjudge.net/contest/274500#problem/D

26.https://vjudge.net/contest/274500#problem/F

27.http://codeforces.com/gym/101981/attachments K题

28.https://ac.nowcoder.com/acm/contest/296/B

注：与括号序列与栈有关的构造题

29.http://codeforces.com/problemset/problem/1090/E

注：跳马构造问题，棋盘马圈

30.http://codeforces.com/contest/1090/problem/D

31.http://codeforces.com/contest/1090/problem/C

注：带一定分析和代码量的，操作构造题；需要证明存在性和正确性

32.http://codeforces.com/problemset/problem/1088/D

注：常规异或构造交互题，按位构造

33.http://codeforces.com/problemset/problem/1088/C

34.https://codeforces.com/problemset/problem/1098/C

注：先构造，后调整，构造一棵树，所有节点深度和严格为s，然后使得宽度(节点最大儿子数目)最小

35.https://codeforces.com/problemset/problem/1133/F2

注：定点定度生成树构造，先构造指定点取最小度的生成树(维护父亲数组)，遍历与该点直接相连的点，根据需要修改父亲来调整，显然任意调整的中间状态任意时刻仍然为生成树

36.http://codeforces.com/group/aUVPeyEnI2/contest/243686 K题

注：正则图构造+正则二分图构造

37.http://codeforces.com/group/aUVPeyEnI2/contest/243687 J题

38.https://ac.nowcoder.com/acm/contest/883/C

注：给定长度为$2n-1$的只含$[1,n]$的序列表示一棵以$1$为根的有根树的欧拉序，中间包含一些$-1$，替换之得到任意合法的欧拉序，保证有解；比较麻烦的构造题，欧拉序有以下性质：

- 自顶向下性质，任两个相同的数之间是绝对封闭的，也就是若$x$出现在之中，则$x$不会出现在外面，对应于树上就是几棵以同一个点为根的子树
- 自下而上性质，任何一棵子树的欧拉序都可以缩成一个元素(首元素)，使得欧拉序保持合法，对应于树上就是删除子树，保留根

将问题转化为简单版本，即没有两个相同元素出现(除$-1$)：

写个递归函数$solve(l,r)$表示$a[l]=a[r]$为根，且填充内部节点；从左往右，每发现一个新元素，就寻找其在右侧的下一次出现，然后调用递归函数填充，接着缩去这一段区间，只保留这个元素的第一次出现，然后找下一个新元素。这样，这段$[l,r]$区间就只保留了除$-1$以外的不同元素。中间最好用链表维护元素的删除，不重复扫描已被删除的元素。

解决简单版本的问题，统计出现了多少个数，应该出现的数个数，不足的种数按顺序靠左填充。这样，剩下的$-1$都是已经出现的数，按顺序扫描，$i$下标满足$i,i+1$填好，但是$i-1$是$-1$，就将前面的赋值给后面的，删除之，继续扫描。然后，按顺序扫描，$i$下标满足$i,i+1$填好，但是$i+1$是$-1$，就将后面的赋值给前面的，删除之。注意两种决策不能反过来，考虑$x \space -1 \quad y \space z \quad -1$，当前$i$指向$y$，发现要优先考虑左边的$-1$先填，因为填完了右边的还有希望，但是先填右边的，可能左边的就满足不了了。

39.https://ac.nowcoder.com/acm/contest/883/I

注：主要是要发现可以通过只用相关的三个中位数来构造原始序列，于是可以通过dp记录状态来转移。

40.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=1477 $D$题

注：很有趣的题目，给定$n \in [4,500],k \in [3,n-1]$，和一个点数为$n$的边不带权**连通**无向图，求一个哈密顿圈，使得相邻两点最短路不大于$k$，或者判定无解；事实上，$k \ge 3$一定有解，可以取任意生成树加以构造；沿用树上合并的树$dp$的思想，对子树$x$令其方案为$F(x)$表示从$x$出发，最后回到$x$的某个儿子的一个合法方案，是个$vector$；令$R(V)$表示$vector$的翻转。一个节点$x$的方案为单独一个元素$\{x\}$；每次将子树$x$的方案并入父亲$p$的方案，$F(p)+=R(F(x))$，当然父亲$p$初值为$F(p)=\{p\}$。注意中间方案衔接刚好用到了跳转$3$步，所以需要$k \ge 3$，具体构造画图会更加清楚。

41.http://www.51nod.com/Challenge/Problem.html#problemId=1385

注：中档题，与子序列密度有关的构造：给定$n \in [1,10^{10000}]$，构造一个最短的数字串使得其包含$[1,n]$中的每个数(串)作为子序列，给出最短长度。若$len(n)=m$，则显然应该包含长度为$m-1$的任意串作为子序列，有个结论，$10(m-1)$的构造$1234567890...$这样的循环构造是最短的，这与序列自动机的最短路有关。考虑开头$n[0]$，当长度取$m$，且最高位取$[1,n[0]-1]$时，由于可能后面所有位都取到最高位这个字符，故必须要增加一个长度给最高位使用，即$ans+=n[0]-1$；若最高位取$n[0]$时，也是这样，即存在都等于$n[0]$的情况，则$ans++$，否则不变。

42.http://www.51nod.com/Challenge/Problem.html#problemId=1613

注：中档题，$n$个正面向上的硬币，每次严格翻$k$个，问最少次数使得所有硬币反面向上；结论为：

- 若$n$为奇数，若$k$为偶数无解，若$k$为奇数答案为$\ge n/k$的最小奇数
- 若$n$为偶数：
  - 若$k$为偶数，且$n/2<k<n-1$，答案为$3$
  - 若$k$为奇数，且$n/2<k \le n-1$，答案为$\ge n/(n-k)$最小偶数
  - 若$k$为偶数，且$k \le n/2$，答案为$\ge n/k$最小整数
  - 若$k$为奇数，且$k \le  n/2$，答案为$\ge n/k$最小偶数

43.http://acm.hdu.edu.cn/showproblem.php?pid=5515

注：中档题，与机器人游走有关的构造型操作题，等价类合并

44.https://codeforces.com/contest/1252/problem/A

注：基础题，给定长度为$n$的排列，构造一个排列使得对应每位差的绝对值之和不少于$n$；直接循环移位一位，或者令$b[i]=n+1-a[i]$，可以证明后者的构造是答案最大的。

45.https://codeforces.com/contest/1252/problem/E

注：中档题，给定长度为$n$的序列，要求重标号，满足新的数组相邻两项相对关系不变($>,=,<$)；且相邻两项差的绝对值在$k$以内，所有数值在$[L,R]$中；无解输出$-1$。考虑贪心构造，先弄出每个元素的可行区间，设$c_n=[L,R]$；从后向前递推即可，令$c_{i}=[L_i,R_i]$，若$a_i<a_{i+1}$，$L_i=max(L_{i+1}-k,L)$，$R_i=R_{i+1}-1$；若$a_i>a_{i+1}$，$L_i=L_{i+1}+1$，$R_i=min(R_{i+1}+k,R)$；若相等则不变。现在在此区间内选择一个元素，一定满足后面所有的限制，但是会带来新的限制，即前面一些元素的选定导致可行区间缩小；先选择第一个元素，选取区间最小值$x$，然后限定第二个元素的范围，比如若$a_i<a_{i+1}$，则区间交上$[x+1,x+k]$，其他情况类似；当某个元素的下界严格大于上界，则无解。

46.https://hihocoder.com/problemset/problem/1257

注：$2015icpc$北京$I$，递推递归构造法

47.http://acm.hdu.edu.cn/showproblem.php?pid=4814

注：中档题，给定$\phi$表示方程$x^2=x+1$的大的那个根，给定$n$将其表示为$\phi$进制数；由于与斐波那契数列相似，所以直接将$nF_k$表示成斐波那契表示即可，最后左右翻转方案。

48.http://codeforces.com/problemset/problem/1227/G

注：中档题，给定$n$个数$a[i] \in [1,n]$，要求构造至多$n+1$个不同的$01$串，使得第$i$位上的$1$的个数恰好为$a[i]$。考虑按照$a[i]$从大到小的顺序逐列填充，第$k$大的列从第$k$行向下填充$1$，如果不够则循环(从顶部向下)填充；使用数学归纳法，可以证明在第$i$次填充之后，前$i$行的$01$串一定是两两不同的。

49.http://codeforces.com/problemset/problem/802/H

注：中档题，给定$k \le 10^6$，要求构造两个字符串$s,t$满足只包含大小写字母，长度均不超过$200$，且$t$作为子序列在$s$中严格出现$k$次。可以先粗略估计一下级别，需要是三次方级别；考虑将$k$拆分为若干个允许重复的$C(p_i,3)$之和，打表发现最多只会使用不超过$20$项。考虑令$t=aaab$，$s=100$个$a$，在$s$中每插入一个$b$，增加一项$C(p_i,3)$，故$|s|\le 120$。

50.http://codeforces.com/problemset/problem/819/E

注：中档题，给定$3 \le n \le 300$个点的完全无向图，要求使用若干个长度为$3$或$4$的简单圈覆盖所有边且每条边恰好覆盖两次，无解输出$-1$。考虑递归构造(归纳构造)，$n=3$时，直接三元圈重复两次即可，$n=4$时，以每个点为中心与相邻两个点构成三元圈，共$4$个三元圈；每次考虑增加两个点$x,y$，先随便找个点$k \le n$，用两个三元圈$(x,y,k)$匹配掉$<x,y>$这条边，$1..n$剩余点排成圆周，利用$(x,i,y,j)$每次匹配相邻项，转一圈即可，此时每个点刚好使用两次。

51.http://codeforces.com/problemset/problem/652/F

注：难题，给定$n,m,t$，表示$n$只蚂蚁在长度为$m$的圆周上，给定每只蚂蚁初始坐标(两两不同)和方向(顺逆时针)，求$t$步之后每只蚂蚁的坐标(碰撞立刻反向)。首先两点观察，若蚂蚁无区别，显然碰撞可以当成穿过，因此可以计算出终点坐标即可，并且排序；由于不断碰撞，显然蚂蚁编号相对顺序(相对圆周)是没有改变的，因此只需要求编号为$1,2$的蚂蚁坐标，或者直接求圆周循环移位的步数。考虑每只蚂蚁不断的来回走，若一只蚂蚁原来在$0$刻度线左侧，现在在右侧，显然对圆周移位贡献$1$，由此知每只蚂蚁的贡献$ \in \{-1,0,1\}$，叠加即是移位步数；但是我们不便于计算每只的贡献，考虑代数和，若一只蚂蚁从左侧向右穿过$0$刻度线，对答案贡献$+1$，从右侧向左穿过$0$刻度线，贡献$-1$；考虑计算这种贡献的代数和，由于两只蚂蚁碰撞可以认为只是交换了编号，他们将继续代替对方做贡献，因此可以转化为蚂蚁不碰撞版本计算代数和，这是很容易的，因为我们可以独立考虑每只蚂蚁。

52.http://codeforces.com/problemset/problem/1019/C

注：中档题，给定$n \le 10^6$个点$m$条边的有向图，求一个点集$S$，使得$\forall x,y \in S$，$x,y$之间没有直接相连的边；且$\forall x \notin S$，必$\exist y \in S$，$dist[y][x] \le 2$。考虑如下构造：任选一个点$x$，删除$x$以及$x$一步可达的点；递归构造剩余的图的解$S'$，若$S'$存在一步可直接到$x$的点，则$x$不选，令解$S=S'$，否则令$S=S' \cup \{x\}$。证明考虑使用数学归纳法：若是第一种情况，令$u \in S'$且$u$一步可达$x$，由于没有选择$x$，故第一个条件满足，且$u$两步以内走到$x$以及$x$一步可达的点；若是第二种情况，可以选择$x$，则$x$直接走到此轮没选的点。注意此题在竞赛图上有特殊结论，若$u$是竞赛图$T$上的一个出度最大的点，则直接选择$S=\{u\}$即可，因为$\max_{v \in V}dist[u][v] \le 2$，即$u$两步以内可以到达所有点。

53.http://codeforces.com/problemset/problem/26/E

注：中档题，给定$n,w,a[]$，表示有$n$个处理器，有一个全局变量$y$，第$i$个处理器有个本地临时变量$y_i$，且需要执行$a[i]$组指令，每组指令分两条，第一条是$y_i=y$，第二条为$y=y_i+1$，分别表示拷贝指令和赋值指令；要求构造一个由处理器编号构成的长度为$2\sum a[i]$的指令序列，表示按此顺序依次执行指令后，全局变量$y=w$；判断无解情况，有解构造任何方案。先考虑简单的问题：若给定指令序列，如何求$w$的值，反向扫描，最后一个赋值操作若处理器编号为$k$，则查找前面一次出现的$k$，两个$k$之间连一条弧线；跳到弧线前，继续扫描，$w$等于弧线个数。所以只要布置弧线即可，先判掉一些特殊情况以及无解情况；取一对$1$和一对$2$，剩余的需要的元素放在后面，不需要的元素放在前两个弧线里面，详细见代码。

54.https://codeforces.com/problemset/problem/509/D

注：基础题，同余构造，给定$n \times m$的矩阵$w[i][j]$，构造整数$k$和两个数组$a[],b[]$使得$w[i][j]=(a[i]+b[j])\% k$，或者指出无解。考虑对一行进行差分，得到一个行向量；一共有$n$个行向量，它们每一维需要关于$k$同余；则只需要枚举每一维的每一对相邻元素，将其差放入集合，求$gcd$，若为$0$则令$k=1e18$，否则令$k=gcd$，这是因为$k$要尽量大，$w$每个元素要严格小于$k$。之后$a,b$是容易构造的，因为我们知道了$a[i]-a[i-1],b[j]-b[j-1]...$只需要随意指定$a[1],b[1]$满足$a[1]+b[1]=w[1][1]$。

55.https://codeforces.com/problemset/problem/329/C

注：基础题，给定$m \le n \le 10^5$，$n$个点，$m$条边的无向图，满足所有点的度$\le 2$且无重边自环；要构造一个点数和边数相同的新图，满足同样的性质，且原图中的边在新图中不能出现，或者指出无解。随机化构造，直接随机一个排列，连接相邻的点，连出$m$条边，$100$次随机以内找不到解则判无解。

56.https://codeforces.com/problemset/problem/1028/E

注：中档题，给定$n$个数$a[i]$排成圆周，构造一个圆周数组$b[i]$满足相邻两个$b[i]\% b[i+1]=a[i]$，$0 \le a[i] \le 20 \times 10^4,1 \le b[i] \le 10^{18},n \in [1,2 \times 10^5]$。若所有元素相等，且为$0$，构造全$1$；若所有元素相等，且不为$0$，无解；令最大值为$x$，寻找一个下标$i \in [1,n]$，满足$a[i]=x$且$a[i-1]<a[i]$，整个序列$a$循环移位到以$a[i]$结尾，此后$a[n]=a[i]$；令$b[n]=a[n]$，$b[i]$为$a[i]$后缀和，若$a[i]=0$适当调整：$b[i]=b[i+1]+a[i],b[i]*=M$，$M$是一个充分大的量。

57.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001538     $B$题

注：中档题，给定长度为$n$的$1..n$的排列$a$，构造仅有$1..n$构成的边长最小的方阵，使得$a$在每行每列均作为连续子段出现。最小边长为$2n-1$(尚无证明)，构造考虑$A[i][j]=a_{(i+j)\%n}$，下标均从$0$开始。

58.https://codeforces.com/gym/102431/    $I$题

注：$CCPC\_Final2019$，中档题，给定$n$表示$n$种颜色，从中选择两种可以重复的颜色组合，有$c=n(n+1)/2$种，现在每种有一个由两个$1 \times 1 \times 1$的立方体(二者颜色为其组合)构成的$1 \times 1\times 2$的木块；要求将这$c$个木块放入三维空间，满足整个立体图形联通，且对于每一种颜色(只看这种颜色)，其小立方体也是联通的；空间通过面接触联通。考虑一层一层递归构造，将当前层复制给下一层，然后适当调整下一层，将该层出现次数最多的颜色，换成下一种颜色(有一个木块二者同色，换一个)，然后添加一个新的木块(p,p)，$p$为下一种颜色；输出方案。












##【4】博弈深入：



广义地理游戏

Generalized geography

PSPACE-complete problems



学习链接：维基百科

https://en.wikipedia.org/wiki/Generalized_geography?tdsourcetag=s_pctim_aiomsg

https://en.wikipedia.org/wiki/Category:PSPACE-complete_problems

https://en.wikipedia.org/wiki/List_of_PSPACE-complete_problems













# 7.数学

【1】初等数论基础：具体数学第4章

【2】组合数学：具体数学第6章

【3】扩展欧几里得/费马小定理/欧拉定理/逆元/筛法/卢卡斯定理

一次同余方程$ax=b\pmod{p}$，有解条件：$gcd(a,p)|b$

设$a,b,p$约去$gcd(a,p)$为$a',b',p'$，则：$a'x=b'\pmod{p'},a'\perp p'$

故得到特解：$x_0=a'^{-1}b'\pmod{p'}$，显然通解$x\pmod{p}$有$gcd(a,p)$种

【4】计算几何：各种基础知识



指定题目：

1.http://codeforces.com/problemset/problem/758/F

2.http://codeforces.com/problemset/problem/756/F

3.http://codeforces.com/problemset/problem/717/A

4.http://codeforces.com/problemset/problem/707/C

5.http://codeforces.com/problemset/problem/710/D

6.http://www.lydsy.com/JudgeOnline/problem.php?id=4002

7.http://www.lydsy.com/JudgeOnline/problem.php?id=1856


【4】积性函数与线性筛法

【5】容斥原理

【6】二项式反演/莫比乌斯函数反演变换

【7】中国剩余定理与扩展/裴蜀定理/威尔逊定理/鸽巢原理/其他一些简单定理（书）

【8】群论基础与$Polya$计数法定理，$bunside$引理

- 群作用

  - 定义

    - **![[公式]](https://www.zhihu.com/equation?tex=G) 为一个群， ![[公式]](https://www.zhihu.com/equation?tex=X) 为一个集合，那么 ![[公式]](https://www.zhihu.com/equation?tex=G) 在 ![[公式]](https://www.zhihu.com/equation?tex=X) 上的作用定义为一个映射：**

      **![[公式]](https://www.zhihu.com/equation?tex=G%5Ctimes+X%5Crightarrow+X) ，其将一个有序对 ![[公式]](https://www.zhihu.com/equation?tex=%28g%2Cx%29) 映射到 ![[公式]](https://www.zhihu.com/equation?tex=g%5Bx%5D) ，其中 ![[公式]](https://www.zhihu.com/equation?tex=g%5Cin+G%2Cx%5Cin+X%2Cg%5Bx%5D%5Cin+X)**

  - 性质

    - **![[公式]](https://www.zhihu.com/equation?tex=e%5Bx%5D%3Dx)**
    - **![[公式]](https://www.zhihu.com/equation?tex=%5Cforall+g_1%2Cg_2%5Cin+G%2Cg_1%5Bg_2%5Bx%5D%5D%3D%28g_1g_2%29%5Bx%5D)**

  - Cayley定理推论

    - 任意一个群在集合上的作用的实质都是与其同构的一个变换群在集合上的作用

  - 群作用下可相互转化的等价关系：

    - **![[公式]](https://www.zhihu.com/equation?tex=%5Cforall+x%2Cy%5Cin+X%2Cx%5Csim+y) 当且仅当 ![[公式]](https://www.zhihu.com/equation?tex=%5Cexists+g%5Cin+G%2C%5C+s.t.%5C+g%5Bx%5D%3Dy)**

  - 轨道

    - 定义
      - **![[公式]](https://www.zhihu.com/equation?tex=O_x) 为元素 ![[公式]](https://www.zhihu.com/equation?tex=x) 所在的由关系 ![[公式]](https://www.zhihu.com/equation?tex=%5Csim) 导出的等价类，被称为 ![[公式]](https://www.zhihu.com/equation?tex=x+) 所在的轨道**
    - 性质
      - **![[公式]](https://www.zhihu.com/equation?tex=%5Cforall+x%2Cy%5Cin+X%2Cx%5Csim+y) 当且仅当 ![[公式]](https://www.zhihu.com/equation?tex=O_x%3DO_y)**
      - **任意两个轨道要么相同要么不交**
      - **所有不同轨道给出了集合 ![[公式]](https://www.zhihu.com/equation?tex=X) 的一个划分，即在 ![[公式]](https://www.zhihu.com/equation?tex=X) 每条不同轨道上选取一个元素组成集合 ![[公式]](https://www.zhihu.com/equation?tex=I) 的话，有 ![[公式]](https://www.zhihu.com/equation?tex=X%3D%5Cbigcup_%7Bx%5Cin+I%7DO_x)**
      - ![[公式]](https://www.zhihu.com/equation?tex=%5Csum_%7Bx%5Cin+X%7D+%5Cfrac%7B1%7D%7B%7CO_x%7C%7D%3Dn) 为不同轨道个数

  - 稳定化子

    - 定义
      - **对于 ![[公式]](https://www.zhihu.com/equation?tex=x%5Cin+X) ，![[公式]](https://www.zhihu.com/equation?tex=G_x%3D%5Cleft+%5C%7B+g%5Cin+G%7Cg%5Bx%5D%3Dx+%5Cright+%5C%7D) 被称为群作用下元素 ![[公式]](https://www.zhihu.com/equation?tex=x) 的稳定化子**
      - **稳定化子必定是作用群 ![[公式]](https://www.zhihu.com/equation?tex=G) 的子群**

  - Lagrange公式

    - ![[公式]](https://www.zhihu.com/equation?tex=x) **所在轨道元素个数等于 ![[公式]](https://www.zhihu.com/equation?tex=x) 的稳定化子的不同陪集数**
    - $|O_x|=|G/G_x|=\frac{|G|}{|G_x|}$

- $bunside$引理

  - 群作用应用：将**![[公式]](https://www.zhihu.com/equation?tex=X) 看作是所有染色方案组成的集合， ![[公式]](https://www.zhihu.com/equation?tex=G) 看作是给定对称意义下的所有变换构成的群**，**轨道 ![[公式]](https://www.zhihu.com/equation?tex=O_x) 包含的元素都是在对称意义下与 ![[公式]](https://www.zhihu.com/equation?tex=x) 相同的染色方案**，**![[公式]](https://www.zhihu.com/equation?tex=G_x) 中元素都是保持染色方案 ![[公式]](https://www.zhihu.com/equation?tex=x) 不变的变换**，所需要求的在对称意义下本质不同的非同构的染色方案数即**不同轨道的数量$n$**
  - 不动点集合：**![[公式]](https://www.zhihu.com/equation?tex=%5Cpsi%28g%29%3D%5Cleft+%5C%7B+x%5Cin+X%7C+g%5Bx%5D%3Dx%5Cright+%5C%7D) 为在 ![[公式]](https://www.zhihu.com/equation?tex=g) 作用下不变的元素的集合**
  - 算两次思想：考虑不动元祖$(g,x)$表示被作用元素$x$为变换$g$下的一个不动点，对其进行计数
    - ![[公式]](https://www.zhihu.com/equation?tex=%5Csum_%7Bg%5Cin+G%7D%7C%5Cpsi%28g%29%7C%3D%5Csum_%7Bx%5Cin+X%7D%7CG_x%7C)。
    - ![[公式]](https://www.zhihu.com/equation?tex=%5Csum_%7Bg%5Cin+G%7D%7C%5Cpsi%28g%29%7C%3D%5Csum_%7Bx%5Cin+X%7D%5Cfrac%7B%7CG%7C%7D%7B%7CO_x%7C%7D%3D%7CG%7C%5Csum_%7Bx%5Cin+X%7D+%5Cfrac%7B1%7D%7B%7CO_x%7C%7D)$=|G|n$
    - $n=$![[公式]](https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B%7CG%7C%7D%5Csum_%7Bg%5Cin+G%7D%7C%5Cpsi%28g%29%7C)
    - **群中元素的不动点个数的平均值就是不同轨道的个数**
  - 简单的例题
    - ![[公式]](https://www.zhihu.com/equation?tex=6) 种颜色对立方体的六个面染色，每个面颜色必须不同，立方体可以在空间任意转动，求不同染色方案数。

- $Polya$计数法

  - 基础
    -  **![[公式]](https://www.zhihu.com/equation?tex=A) 为被染色块构成的集合， ![[公式]](https://www.zhihu.com/equation?tex=C) 为所有颜色构成的集合**， ![[公式]](https://www.zhihu.com/equation?tex=%7CA%7C%3Dn%2C%7CC%7C%3Dm) ，那么任意一个**映射 ![[公式]](https://www.zhihu.com/equation?tex=f%3AA%5Crightarrow+C)** 都代表了一个染色方案，被称为一个**染色函数**。 ![[公式]](https://www.zhihu.com/equation?tex=C%5EA) 即表示所有的染色函数 ![[公式]](https://www.zhihu.com/equation?tex=f) 构成的集合。 ![[公式]](https://www.zhihu.com/equation?tex=G) 为 ![[公式]](https://www.zhihu.com/equation?tex=A) **上的一个置换群**，包含了染色块之间“对称关系”的含义。**![[公式]](https://www.zhihu.com/equation?tex=X) 是所有染色函数组成的集合而不再是不同染色方案的集合**。
    - 定义![[公式]](https://www.zhihu.com/equation?tex=G) 作用在 ![[公式]](https://www.zhihu.com/equation?tex=C%5EA) 上的**群作用**： ![[公式]](https://www.zhihu.com/equation?tex=g%5Bf%5D%3Dfg%5E%7B-1%7D)
    - **对称意义下的不同染色方案数仍旧等于这个群作用中的不同轨道的个数**
  - 核心
    - 考虑$g$为一个置换，考虑其包含的一个轮换，其中涉及到的元素，必须被染成相同的颜色
    - 因此在置换$g$作用下保持不变的方案有：$m^{k(g)}$，$k(g)$为其轮换个数
    - **不同轨道个数为** ![[公式]](https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Csum_%7Bg%5Cin+G%7Dm%5E%7Bk%28g%29%7D%7D%7B%7CG%7C%7D)
    - 关键在于如何求置换群中轮换个数的分布，完整置换群的轮换分布可以与生成函数结合
  - 定理
    - **已知 ![[公式]](https://www.zhihu.com/equation?tex=%7CA%7C%3Dn%2C%7CC%7C%3Dm%2CG) 为 ![[公式]](https://www.zhihu.com/equation?tex=A) 上的置换群，则所有不同轨道个数为** ![[公式]](https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Csum_%7Bg%5Cin+G%7Dm%5E%7Bk%28g%29%7D%7D%7B%7CG%7C%7D) 。

- 带权$bunside$引理

  - 权函数
    - 由于同一个轨道中的染色方案是等价的，因此应该有相同的权，令$\omega(x)$表示染色方案$x$的权，轨道的权等于其包含元素的权
    - 我们不再求不同轨道数，转而求不同轨道权之和![[公式]](https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5EN%5Comega%28O_i%29)，当权取$1$时被化归
  - 核心
    - ![[公式]](https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5EN%5Comega%28O_i%29%3D%5Csum_%7Bx%5Cin+X%7D%5Cfrac%7B%5Comega%28x%29%7D%7B%7CO_x%7C%7D)。
    - ![[公式]](https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5EN%5Comega%28O_i%29%3D%5Cfrac%7B1%7D%7B%7CG%7C%7D%5Csum_%7Bg%5Cin+G%7D%5Csum_%7Bx%5Cin+%5Cpsi%28g%29%7D%5Comega%28x%29)。
    - **所有轨道的权之和等同于群中每个元素对应的不动点的权的平均数**

- 带权$Polya$定理

  - 权函数

    - 考虑**![[公式]](https://www.zhihu.com/equation?tex=f%5Cin+C%5EA) 为染色函数，其中 ![[公式]](https://www.zhihu.com/equation?tex=A) 为被染色块集合， ![[公式]](https://www.zhihu.com/equation?tex=C) 为颜色的集合， ![[公式]](https://www.zhihu.com/equation?tex=%7CA%7C%3Dn%2C%7CC%7C%3Dm) ，权函数 ![[公式]](https://www.zhihu.com/equation?tex=%5Comega) 定义在集合 ![[公式]](https://www.zhihu.com/equation?tex=C) 上， ![[公式]](https://www.zhihu.com/equation?tex=G) 仍为 ![[公式]](https://www.zhihu.com/equation?tex=A) 上的一个置换群**
    - **![[公式]](https://www.zhihu.com/equation?tex=%5Comega%28f%29%3D%5Cprod_%7Ba%5Cin+A%7D%5Comega%28f%28a%29%29) 为染色函数 ![[公式]](https://www.zhihu.com/equation?tex=f) 的权**，**染色函数的权等同于其将所有染色块映射到的颜色所具有的权的积**

  - 定理

    - ![[公式]](https://www.zhihu.com/equation?tex=%5Comega%28f%29%3D%5Cprod_%7Ba%5Cin+A%7D%5Comega%28f%28a%29%29%3D%5Comega%28c_1%29%5E%7B%7CA_1%7C%7D...%5Comega%28c_%7Bk%28g%29%7D%29%5E%7B%7CA_%7Bk%28g%29%7D%7C%7D)。其中$k(g)$表示$g$的轮换个数，$A_{i}$表示第$i$个轮换的符号集合，即涉及到的被作用元素集合；$c_i$表示第$i$个轮换被染的颜色。

    - ![[公式]](https://www.zhihu.com/equation?tex=%5Csum_%7Bf%5Cin+%5Cpsi%28g%29%7D%5Comega%28f%29%3D%5Csum_%7Bc_1%2C...%2Cc_%7Bk%28g%29%7D%5Cin+C%7D%5Comega%28c_1%29%5E%7B%7CA_1%7C%7D...%5Comega%28c_%7Bk%28g%29%7D%29%5E%7B%7CA_%7Bk%28g%29%7D%7C%7D)。

      ![[公式]](https://www.zhihu.com/equation?tex=%3D%5Cprod_%7Bi%3D1%7D%5Ek%28%5Csum_%7Bc%5Cin+C%7D%5Comega%28c%29%5E%7Bi%7D%29%5E%7Bc_i%28g%29%7D)。其中$c_i(g)$表示$g$中长度为$i$的轮换个数。$k=|A|$，即最大轮换长度。

    - 由带权的Burnside定理， ![[公式]](https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5EN%5Comega%28O_i%29%3D%5Cfrac%7B1%7D%7B%7CG%7C%7D%5Csum_%7Bg%5Cin+G%7D%5Csum_%7Bf%5Cin+%5Cpsi%28g%29%7D%5Comega%28f%29%3D%5Cfrac%7B1%7D%7B%7CG%7C%7D%5Csum_%7Bg%5Cin+G%7D%5Cprod_%7Bi%3D1%7D%5Ek%28%5Csum_%7Bc%5Cin+C%7D%5Comega%28c%29%5E%7Bi%7D%29%5E%7Bc_i%28g%29%7D)

      若记 ![[公式]](https://www.zhihu.com/equation?tex=%5Comega_i%3D%5Csum_%7Bc%5Cin+C%7D%5B%5Comega%28c%29%5D%5Ei)，表示一个长度为$i$的轮换的染色权之和，若权为$1$，即退化为方案数。

      则得到： ![[公式]](https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5EN%5Comega%28O_i%29%3D%5Cfrac%7B1%7D%7B%7CG%7C%7D%5Csum_%7Bg%5Cin+G%7D%28%5Comega_1%5E%7Bc_1%28g%29%7D...%5Comega_n%5E%7Bc_n%28g%29%7D%29)

  - 生成函数表示与优化

    - 令$\omega(c)$表示颜色$c$对应的占位符$x_c$，而不是简单的数值权，带入$Polya$定理可以很容易得到非同构的一些方案数，其包含的细节更加丰富，很容易和生成函数结合起来：例如表示每种颜色各使用多少个的非同构方案数等。
    - 令$\omega_i=\sum_{c\in C}x_c^i$表示轮换占位符，$\prod_{i=1}^nx_i^{c_i}$表示种类占位符，排列的$Cycle \space Indicator/Index$即是关于种类占位符的，只需要带入$x_i=\omega_i$即得到关于颜色占位符$\prod_{c \in C}x_c^{cnt_c}$的生成函数，此项前面的系数即表示非同构的颜色$c$恰好使用了$cnt_c$次的方案数(当然要除以$|G|$)

  - 简单例题

    - 求$n$个点的**边非同构**无向图(点不带标号)，求出恰好包含$i$条边的答案$ret_i$

      - 染色对象集合为$A=E$即完全图边集，颜色集合$C=\{x,y\}$表示两种颜色，取或者不去($y$可令为$1$)，置换群为全变换群$G=S_{|A|}$，按照上面的思路即可得到$n$个点$i$条边的答案

      - $n=3$的情况：![[公式]](https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5EN%5Comega%28O_i%29%3D%5Cfrac%7B%28b%2Bw%29%5E3%2B3%28b%2Bw%29%28b%5E2%2Bw%5E2%29%2B2%28b%5E3%2Bw%5E3%29%7D%7B6%7D%3Db%5E3%2Bw%5E3%2Bb%5E2w%2Bbw%5E2)

        表示共有$4$种，每种情况各$1$种

      - 注意由于占位符个数太多，会产生维数爆炸的情况，不便于求大的数据规模，因此当$i \le k$时，我们没有必要考虑$\omega_i,i>k$，直接令其为$1$即可；比如说题目只要求$i \le 4$

      - 就此问题，每种必然答案为$1$，总方案答案为$|E|+1$

    - 求$n$个点的**边非同构**无向图(点不带标号)，$ans_n$

      - 由于不要求具体的颜色数量限制，因此令权值为$1$即可，即令轮换占位符中的$x_c=1$
      - 令$M=\binom{n}{2}$，由定理知，不同的轨道数$N=\frac{1}{|G|}\sum_{g \in G}2^{k(g)}=\frac{1}{M!}\sum_{i=1}^M2^iS(M,i)=M+1$，其中$S$表示第一类斯特林数
      - 最后一步用到了斯特林数的行生成函数，这是一个上升阶乘幂



【9】离散对数与原根

[在线求原根](http://www.bluetulip.org/2014/programs/primitive.html?inputbox=6&resultbox=3+has+1+primitive+roots%2C+and+they+are+and+2.) [维基百科：原根](https://en.wikipedia.org/wiki/Primitive_root_modulo_n)

- 关于原根存在的充要条件：

  - 原根存在，则$m=1,2,4,p^a,2p^a$，其中$p$为奇质数且$a \ge 1$
  - $m \ge 3$原根存在，$x^2=1\pmod{p}$存在两解(模$p$意义下)
  - $m \ge 3$，$[1,m]$中与$m$互质的数的乘积模$m$为$-1$有原根，为$1$则无原根

  $$
  \prod_{k=1 \atop \mathrm{ged}(k, m)=1}^{m} k 
  \equiv\left\{\begin{aligned}-1 &(\bmod m) \space ,m\in [1,2,4,p^e,2p^e],p为奇质数 \\ 1 &(\bmod m),否则 \end{aligned}\right.
  $$

  上述结论在模$m^2$意义下未必成立，若成立则$m$为$Wilson \space  numbers$

  上述结论可推广到***任意有限交换群***，群中所有元素的乘积等于单位元或者一个阶为$2$的元素[维基百科](https://en.wikipedia.org/wiki/Wilson%27s_theorem#Gauss.27s_generalization)

  关于[威尔逊商数](https://en.wikipedia.org/wiki/Wilson_quotient)，其同余递推式与伯努利数有关
  $$
  \begin{array}{l}{W(p) \equiv B_{2(p-1)}-B_{p-1}\pmod{p}} \\ {p-1+p t W(p) \equiv p B_{t(p-1)} \pmod{p^2}}\end{array}
  $$

- 求原根算法$O(glog^2p)$

- $BSGS$及其扩展求离散对数$a^x=b\pmod{p}$即$x=log_ab\pmod{\phi(b)}$,$p$未必与$a$互质

  其算法实质是分块思想，扩展时两边同时消因子，复杂度$O(\sqrt{p})$

- 解高次同余方程$x^a=b\pmod{p}$，$p$为质数
  $$
  log_g^x=log_{g^a}x^a=log_{g^a}b\pmod{\phi(p)} \\
  alog_g^x=log_g^b\pmod{\phi(p)}
  $$
  转化为第二种情形，即$(g^a)^x=b\pmod{p}$

  如果要求所有$[0,p)$中的解，最好转化后用$exgcd$解普通同余方程或者求逆元，得到一个最小特解$log_g^x=a'^{-1}(log_g^b)'=y_0\pmod{\phi(p)'}$，则通解显然为：$y_0+k\phi(p)',k\in[some \space range]$

  通解在$\pmod{\phi(p)}$意义下有$gcd(a,\phi(p))$种，这与原高次同余方程的解$\pmod{p}$显然一一对应

- 解高次同余方程$x^a=b\pmod{p}$，$p\in Z^+$

  - 特判$p=1$，特判$a=0$
  - 将$p$分解质因子，要求$2$的指数不超过$2$，否则将因为没有原根，而报无解
  - 对每个$p^k$单独考虑，化为模数为质数的幂次的情况，最后中国剩余定理$crt$合并
  - 将$b$规范化($b \in [0,p^k)$)，然后分解为$b=b'p^{cnt}$，其中$p^{cnt}||b$
    - $cnt \ge k$，即$p^k|b$，此时$b$必为$0$，特判之
    - $cnt>0$，即$gcd(b,p^k)>1$，方程化为：$x^a/p^{cnt}=\frac{b}{p^{cnt}}\pmod{p^{k-cnt}}$
      - 特判$a \not|cnt$，此种情况认为无解
      - 化为：$(\frac{x}{p^{cnt/a}})^a=\frac{b}{p^{cnt}}\pmod{p^{k-cnt}}$，转化为互质情形
    - $cnt=0$，即互质情形，与上一个知识点类似，即当$p$为质数时
  - 常常构造最小非负整数解($crt$直接合并)，求解$\in[0,p)$个数，求所有解等
  - 求解个数，可以根据$crt$证明解的一一对应，即简单的利用乘法原理即可
  - 模板支持：$a \ge 0,1\le p<10^{12}$，分解后每类均有原根

- 原根的性质：

  - 数量：$\phi(\phi(p))$
  - 可相互表示：若$g$为原根，则$g^k$亦为原根，其中$k\perp\phi(p)$
  - 若$g$是质数$p$的一个原根，则$p^k$原根为：
    - $g+p$，当$g^{p-1}=1\pmod{p^2}$
    - $g$，否则
  - 若$g$是$p^k$的一个原根，则$2p^k$原根为：
    - $g$和$g+p^k$其中任意一个奇数
  - 若质数$p!=3$，则其所有原根之积$ret=1\pmod{p}$
  - $\forall$质数$p$，其所有原根之和$ret=\mu(p-1)\pmod{p}$
- 注意点：

  - 不确定是否不同余$0$，就要讨论及特判
  - 注意在数学上$0^0=1$，故同余方程$a^x=b\pmod{p}$，当$a=b=0$时，注意最小非负整数解$x_0=[p==1]\oplus1$



【10】二次剩余与$n$次剩余

- 二次剩余定义

  - 正整数$m$，整数$a$，若$(m,a)=1$且存在$x$使得$x^2=a(\%m)$，则$a$是$m$的二次剩余，否则$a$是$m$的二次非剩余。例如：$4$是$7$的二次剩余。

- 勒让德符号

  - $p$为奇质数，整数$a$与$p$互质(不互质为$0$)，则：
    $$
    \left(\frac{a}{p}\right) = \begin{cases}\;\;\,0&\text{ if }p \text { divides } a\\+1&\text{ if } a \operatorname{R} p \text{ and }p \text { does not divide } a\\-1&\text{ if }a \operatorname{N} p \text{ and }p \text{ does not divide } a\end{cases}
    $$
    其中$aRp$表示$a$是$p$的二次剩余，$N$表示非剩余

  - 基本性质

    - 完全积性：$\left(\frac{ab}{p}\right) = \left(\frac{a}{p}\right)\left(\frac{b}{p}\right)$
    - $-1$元素：$\left(\frac{-1}{p}\right)  = (-1)^{\frac{p-1}{2}} =
        \begin{cases}
           1 & \mbox{ if }p \equiv 1\pmod{4} \\
          -1 & \mbox{ if }p \equiv 3\pmod{4}.  
        \end{cases}$
    - $2$元素：$\left(\frac{2}{p}\right) = (-1)^\tfrac{p^2-1}{8} =
        \begin{cases}
           1 & \mbox{ if }p \equiv 1\mbox{ or }7 \pmod{8} \\
          -1 & \mbox{ if }p \equiv 3\mbox{ or }5 \pmod{8}.
        \end{cases}$
    - $3$元素：$p \ne 3$，$\left(\frac{3}{p}\right) = (-1)^{\big\lfloor \frac{p+1}{6}\big\rfloor} =
        \begin{cases}
           1 & \mbox{ if }p \equiv 1\mbox{ or }11 \pmod{12} \\
          -1 & \mbox{ if }p \equiv 5\mbox{ or }7 \pmod{12}.
        \end{cases}$
    - $5$元素：$p \ne 5$，$ \left(\frac{5}{p}\right) =(-1)^{\big\lfloor \frac{2p+2}{5}\big \rfloor} =
        \begin{cases}
           1 & \mbox{ if }p \equiv 1\mbox{ or }4 \pmod5 \\
          -1 & \mbox{ if }p \equiv 2\mbox{ or }3 \pmod5.
        \end{cases}$
    - 与斐波那契数列相关($1,1,2,3...$)：$F_{p-\left(\frac{p}{5}\right)} \equiv 0 \pmod p, \quad F_{p} \equiv \left(\frac{p}{5}\right) \pmod p$
    - 若奇质数$p$存在二次剩余，则一定存在$\frac{p-1}{2}$个二次剩余

- 欧拉判别法

  - $a$与质数$p$互质，则：$\left(\frac{a}{p}\right) \equiv a^{\tfrac{p-1}{2}} \pmod p$

- 二次互反律

  - 令$p,q$为不同奇质数，$\left(\frac{q}{p}\right)\left(\frac{p}{q}\right) = (-1)^{\tfrac{p-1}{2}\cdot\tfrac{q-1}{2}}$

- 高斯引理

  - 令$p$为任意奇质数，$a$与$p$互质，$a, 2a, 3a, \dots, \frac{p-1}{2}a$这些数转化为他们的模$p$最小正余数(两两不同)，则$\left(\frac{a}{p}\right) = (-1)^n$，其中$n$为它们中大于$\frac{p}{2}$的元素个数

-  马克思·艾森斯坦引理

  - 令$p$为任意奇质数，$a$为任意奇数，故$\left(\frac{a}{p}\right) = (-1)^{T(a,p)}$，其中$T(a,p)=\sum_{j=1}^{(p-1)/2} \lfloor \frac{ja}{p} \rfloor$

- 其他等式

  - $\left(\frac{p}{q}\right) =sgn\left(\prod_{i=1}^{\frac{q-1}{2}}\prod_{k=1}^{\frac{p-1}{2}}\left(\frac{k}{p}-\frac{i}{q}\right)\right)$
  - $\left(\frac{q}{p}\right) =\prod_{n=1}^{\frac{p-1}{2}} \frac{\sin\left(\frac{2\pi qn}{p}\right)}{\sin\left(\frac{2\pi n}{p}\right)}$

- 基本扩展：合数的二次剩余

  - 令$m=2^k\prod_{i=1}^np_i^{a_i},p_i$是奇质数；令$\omega=\omega(m)=\begin{cases}
         2^n & \mbox{ if  } \space k \in \{0,1\} \\
        2^{n+1} & \mbox{ if } \space k=2 \\ 2^{n+2} & \mbox{ if } \space k \ge 3
      \end{cases}$，即$\omega=\omega(m)=2^{n+[k>1]+[k>2]}$
  - 二次剩余判定(必要条件)：$\Large a^{\frac{\phi(m)}{\omega(m)}}\%m=1$
  - 二次剩余计数：$m$的二次剩余有$\frac{\phi(m)}{\omega(m)}$个

- 基本应用：二次同余方程(正整数)解个数，$a$与$m$互质

  - 合数版本的二次同余方程等价于模质数幂次的二次同余方程组，且解的个数等于各方程组解的个数乘积
  - $x^2\%p^k=a,p>2$：有$2$个解；$p=2$时，$k=1$，有$1$个解，$k=2$，$a\%4=1$条件下有$2$个解，否则无解；$k \ge 3$时，$a \%8=1$条件下，有$4$个解，否则无解

【11】生成函数与狄利克雷卷积

狄利克雷卷积本质：无穷高维普通卷积$fft$

【12】类欧几里得算法

【13】高斯消元法的应用：解线性方程/异或方程组/数学期望问题

【14】几类重要的数列

【15】线性规划问题

【16】组合恒等式的推导与论证

【17】几类积性函数的求和方法/杜教筛（有论文）

【18】几个重要的概率期望的公式

【19】快速傅里叶变换FFT/分治NTT/快速子集变换FWT/FST/快速莫比乌斯变换FMT

【20】康拓展开与其逆

【21】几何：圆反演相关

- 定义：点$P$关于圆$O$(半径为$r$)做反演得到反演点$P'$满足$|OP|*|OP'|=r^2$，反演中心$O$无反演点，其他点均存在唯一反演点，且反演关系是相互对称的
- 性质
  - 反演圆上的点保持不变，圆内的点反演到圆外，圆外的点反演到圆内
  - 若$P$为圆外点，则$P'$为$P$对圆$O$的切点弦与$OP$交点；若$P$为圆内点，则过$P$做$OP$垂线交圆$O$于$A,B$点，过$A$和$B$分别引切线，两条切线交点即为$P'$
  - 直线(经过$O$)$\leftrightarrow$保持不变
  - 直线(不经过$O$)$\leftrightarrow$圆(经过$O$)
  - 圆(不经过$O$)$\leftrightarrow$圆(不经过$O$)，且两圆位似，$O$为位似中心
  - 反演变换具有保角性，两曲线夹角(切线夹角)在变换前后保持不变，故相切图形保持相切
- 方法
  - 多圆相切时，常常以公共切点为反演中心$O$，以两个关键的圆的直径乘积为反演幂$k=r^2=r_1*r_2$
  - 两圆相交，若交点为两个，以其中一个为反演中心，则两个圆为两条相交直线，相交于两圆另一个交点的反演点
  - 注意圆内点$P$，引入其圆外反演点$P'$，常常产生三角形相似(与圆上一点$D$)
  - 注意反演幂为已知常量，往往提供隐含的等量关系
  - 反演点的坐标是可以用代码很容易求的，有坐标之后容易得到长度等量
- 题目：$hdu 6158$，$hdu6097$

【22】几何：几个重要的平面几何定理

【23】代数：几个重要的不等式

【24】几何：快速凸包问题

【25】几何：半平面交

【26】几何：最近点对与最远点对

【27】几何：最小覆盖

【28】几何：费马点/皮克定理

- 皮克定理：简单多边形面积$S=a+\frac{b}{2}-1$，其中$a$为内部整点个数，$b$为边界上整点个数
- 费马点：三角形三边分别向外做正三角形，最外层三个顶点为$A_1,B_1,C_1$，则直线$AA_1,BB_1,CC_1$相交于一点于$P$

【29】几何：非常重要的旋转卡壳与几个经典的应用

【30】几何：计算几何中的分治思想（论文）

【31】数论：连分数

【32】几何：$simpson$积分法
模拟的函数应该是二次函数能近似会比较科学，可以多切几段去积分	
1.http://acm.hdu.edu.cn/showproblem.php?pid=1724

【33】$Kummer$定理

- $Legendre's \space formula$
  - $\nu_{p}(n !)=\sum_{i=1}^{\infty}\left\lfloor\frac{n}{p^{i}}\right\rfloor=\frac{n-s_{p}(n)}{p-1}$
  - 其中$\nu_{p}(x)$表示$x$在$p$进制下末尾$0$个数
- $Multinomial \space coefficient \space  generalization \space for \space  Kummer$
  - $\nu_{p}\left(\left(\begin{array}{c}{n} \\ {m_{1}, \ldots, m_{k}}\end{array}\right)\right)=\frac{1}{p-1}\left(\sum_{i=1}^{k} S_{p}\left(m_{i}\right)-S_{p}(n)\right)$
  - 其中$S_p(x)$表示$x$在$p$进制下的数位之和

1.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3842

【34】数论：小数与循环节

【35】数论：素数分布，素数测试

【36】数论：勾股方程与佩尔方程

【37】数论：哥德巴赫猜想、华林问题、拉格朗日四平方和定理

【38】数论：大数因数分解$Pollard_rho$算法

【39】几何：三角形的$5$心

【40】几何：四点共圆问题

【41】数论：积性函数前缀和与杜教筛

【42】组合：五边形数定理与划分数

【43】组合：基尔霍夫矩阵生成树计数

【44】组合：$Ramsey$定理

【45】组合：约瑟夫环结论
$$
g(n,k) = \begin{cases}
0 & \text{if } n=1\\
(g(n-1,k)+k) \bmod n & \text{if } 1 < n < k\\
\left \lfloor \frac{k((g(n',k)-n \bmod k) \bmod n')}{k-1} \right \rfloor \text{where } n'= n- \left \lfloor \frac{n}{k} \right \rfloor & \text{if } k \le n\\
\end{cases}
$$
【46】组合：$prufer$编码

prufer序列长度为n - 2，与有标号无根树一一对应

（1）无根树转化为prufer序列。

首先定义无根树中度数为1的节点是叶子节点。

找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下2个节点。

（2）prufer序列转化为无根树

维护两个集合，S是不在prufer序列中出现编号，T是在prufer序列中出现编号，每次取S的最小值，与序列当前值连边，然后S中去掉最小值，T中序列当前值次数-1，如果为0将其加入S中，最后S中剩下两个编号连边

（3）每个点在prufer序列中出现次数是du[i] - 1。

（4）有标号无根树数量为 $$n^{n-2}$$

（5）一些点度数确定时，相当于在n-2个位子中先选这些点的位子，其他位子值随便取其他值，所有点都确定是数量是
$$
\frac{(n-2)!}{ \prod_{i=1}^n(d_i-1)!}
$$
（6）有标号有根树数量，每一种有标号无根树选一个标号为根都是不同的，所以数量为
$$
n^{n-2}*n = n^{n - 1}
$$
（7）n个点，k个联通块求有标号无根树的方案数

​	假设我们有 n 个点，被分成了 k 个点集，每个点集里的点已经连通，不同点集之间的点两两无边，现在我们要在这个 n 个点 n-k 条边的基础上求生成树个数。设第 i 个点集包含的点数为 size[i] 。

​	那么，如果我们把这 k 个点集每一个点集都看作一个点，做一个 k 个点的生成树，那么有$k^{k-2}$
 种方案；但是由于这里的每一个点都是一个点集，所以假设它是点集 i，那么从他连出去的每一条边的属于集合i的端点，都有 size[i] 种选法。也就是说，对于一个 k 个点的 prufer 编码，假设在这个编码中，数字 i 出现了 c[i] 次，那么这个编码对应到原树上就会贡献$\prod_{i=1}^k size[i] ^ {c[i]+1}$次。

​	我们把每一个 "c[i]+1" 中多出来的 1 提出，看作常量，我们来对于所有 prufer 编码求贡献总和：
$$
\sum_{P是一个prufer编码}\ \ \ \ \ \prod_{i=1}^k size[i] ^ {c[i]}
$$
​	考虑到这个prufer编码的每一位选择第 i 个点集，就会对乘积有 size[i] 的贡献，根据乘法分配律，我们可以得到上面的那个式子就是： 
$$
(\sum_{i=1}^k size[i])^{k-2} = n ^ {k-2}
$$
​	再乘上之前提出的东西，所以答案就是：
$$
(\sum_{i=1}^k size[i])^{k-2} \cdot \prod_{i=1}^k size[i]
$$
这个可以推出比如n个点k个森林，1-k号点分别属于不同森林的数量，其实可以看成1-k属于一个联通块，其他点各自是一个联通块的计数

【47】线代：线性基

【48】数论：扩展$lucas$定理



【49】数论：完全剩余系与简化剩余系

【50】组合：置换群与波利亚计数法

【51】线代：行列式与矩阵求逆/矩阵的秩/线性相关

【52】线代：矩阵的特征值与特征向量

【53】线代：矩阵的相似对角化

【54】线代：二次型

注：一个多元二次函数，可以通过一个线性变换化为标准型，即只含变量的平方项，这样有利于求函数最值等

【55】线代：基变换与坐标变换

【56】概率论/随机过程：$Markov Chain$ 马尔可夫链与状态转移概率矩阵

【57】几何：数形结合

【58】代数：$(min,+)$卷积/最值反演/$min-max$容斥

注意为叙述方便，以下公式中，$\subset$类似符号常常表示非空包含；

对$\empty$不定义$min/max/gcd/lcm$等函数；

且$d|S$表示$\forall x\in S,d|x$，此处$S\ne\empty$.

- 基础公式


$$
\max(S)=\sum_{T \subseteq S}(-1)^{|T|+1}\min(T)
$$

$$
\min(S)=\sum_{T \subseteq S}(-1)^{|T|+1}\max(T)
$$

- $k$大值扩展

$$
kth\max(S)=\sum_{T \subseteq S} (-1)^{|T|-k} {|T|-1 \choose k-1} \min(T)
$$

主要用于一些求期望的题目，求一些随机变量的最大值可以转化为求这些随机变量最小值实现

$kthmax$容斥这个系数是可以关于$k$进行递推的，如洛谷$4707$



- $lcm$与$gcd$扩展



$$
lcm(S)=\prod_{T\subset S}gcd(T)^{(-1)^{|T|+1}}
$$
- 一个加速求值的应用

如果函数$f$已知，且满足$gcd$分配率，即：
$$
f(gcd(S))=gcd(f(S))
$$
我们要求：
$$
g(n)=\prod _{T\subset[n]}f(gcd(T))^{(-1)^{|T|+1}},[n]=\{1,\cdots,n\}
$$
若函数$f$是某个函数$h$的偏序前缀积：
$$
f(n)=\prod _{d|n}h(d)
$$
则有
$$
g(n)=\prod _{d=1}^{n}h(d)
$$

证明过程：

令$S=[n]$，令$p=\lfloor \frac{n}{d} \rfloor$.

将$f(n)$带入到$g(n)$表达式中得：
$$
g(n)=\prod _{T\subset S}\prod_{d|gcd(T)}h(d)^{(-1)^{|T|+1}}\\
=\prod _{T\subset S}\prod_{d|T}h(d)^{(-1)^{|T|+1}}\\
\large=\prod_{d=1}^nh(d)^{\sum_{T\subset S,d|T}(-1)^{|T|+1}}\\
其中\sum_{T\subset S,d|T}(-1)^{|T|+1}=\sum_{k=1}^p\binom{p}{k}(-1)^{k+1}=1,命题得证。
$$

- 应用扩展

  - 假设$S$为一般有穷正整数集合，则令$S_d\subset S$表示$\{x|x\in S,d|x\}$，$S_d\ne \empty$.令$G=\{x|x|y ,y \in S\}$为$S$的约数集$,G$显然满足一种偏序单调性.
    $$
    \sum_{T\subset S_d}(-1)^{|T|+1}=1\\
    g(S)=\prod _{T\subset S}f(gcd(T))^{(-1)^{|T|+1}}=\prod_{d\in G}h(d)^{\sum_{T\subset S_d}(-1)^{|T|+1}}=\prod_{d\in G}h(d)
    $$
    也就是说，我们推广了函数$g$在更一般的有限集$S$中与函数$h$的关系，简单的类比可以得到：
    $$
    f(n)=\sum_{d|n}h(d)\quad \Longrightarrow \quad g(S)=\sum_{d\in G}h(d) \\
    其中：g(S)=\sum_{T\subset S}{(-1)^{|T|+1}}f(gcd(T))
    $$

  - 令$f(S)$表示$\{f(x)|x\in S\}$，注意$g(S)$不是这样定义的，则
    $$
    lcm(f(S))=\prod_{T\subset f(S)}gcd(T)^{(-1)^{|T|+1}}=\prod_{T\subset S}gcd(f(T))^{(-1)^{|T|+1}}\\
    =\prod_{T\subset S}f(gcd(T))^{(-1)^{|T|+1}}=g(S)=\prod_{d\in G}h(d)
    $$
    推论：当$S=[n]$时，$lcm(f(S))=\prod_{d=1}^nh(d)$.

    仍然可以做简单的类比，得到$gcd(f(S))$.

  - 与类$lucas$数列结合，求$lcm(f(S))$，因为该数列$f$满足$gcd$分配率，处理出$f$之后，莫比乌斯反演得到$h$，利用集合$S$构造下标$bool$数组$S$，对其做莫比乌斯变换，得到约数偏序集$G$，求$G$中所有元素$h$函数值之积













1.http://acm.hdu.edu.cn/showproblem.php?pid=4336

  ​	发现集合中的元素即使不是独立的好像也可以使用

  2.https://www.lydsy.com/JudgeOnline/problem.php?id=4036

  ​	min-max容斥并取反后发现要求子集和，可以用高维前缀和或者fwt

  3.https://www.luogu.org/problemnew/show/P4707

  ​	应用kthmax转换后发现就是对于容斥集合计数dp的套路，但是这样复杂度还是不够，因为k比较小，发现这个公式的系数其实是可以关于k递推的，于是就优化了复杂度，可以做了

  4.http://acm.hdu.edu.cn/showproblem.php?pid=4624

  ​	min-max容斥后转为dp求相同区间数的集合方案数，这题要高精度，比较坑

  5.https://www.lydsy.com/JudgeOnline/problem.php?id=4833

     这题套路很多，首先看出递推式后要发现有两项gcd等于下标gcd那一项的性质，然后是min-max容斥在整数上使用就是lcm-gcd容斥，然后还要构造一个h函数使
$$
  f(n) = \prod_{d|n} h(d)
$$
  改为计算每个h的贡献，发现指数被消成1了，就只要计算出h即可

  6.https://loj.ac/problem/2542

  ​	计算树上随机游走经过给定集合所有点期望次数，min-max容斥后要求第一次经过一个集合的点期望次数，虽然可以高斯消元，但复杂度不行，如果结构是树的话其实可以求每个点期望还要走多少次，然后把f[i]表示成只和f[fa[i]]以及常数b[i]有关,就可以O(n)实现了




【59】几何：$Szemerédi–Trotter \space theorem$

定理内容：

It asserts that given n points and m lines in the Euclidean plane, the number of incidences (i.e., the number of point-line pairs, such that the point lies on the line) is


$$
O(n^{2/3}*m^{2/3}+n+m)
$$

https://en.wikipedia.org/wiki/Szemer%C3%A9di%E2%80%93Trotter_theorem

使用到的题目：http://codeforces.com/problemset/problem/949/F





【60】几何：三维叉积的应用

求过两点的直线方程一般形式，判断两直线关系，并且求交点坐标

代码短，精度高，不容易出错

参考：https://blog.csdn.net/abcjennifer/article/details/7584628

摘要如下：

$$
一般方程法：\\

直线的一般方程为F(x) = ax + by + c = 0。既然我们已经知道直线的两个点，\\

假设为(x_0,y_0), (x_1, y_1)，那么可以得到a = y_0 – y_1, b = x_1 – x_0, c = x_0y_1 – x_1y_0。\\

因此我们可以将两条直线分别表示为\\

F_0(x) = a_0x + b_0y + c_0 = 0, F_1(x) = a_1x + b_1y + c_1 = 0\\

那么两条直线的交点应该满足\\

a_0x + b_0y +c_0 = a_1x + b_1y + c_1\\

由此可推出\\

x = (b_0c_1 – b_1c_0)/D\\

y = (a_1c_0 – a_0c_1)/D\\

D = a_0b_1 – a_1b_0， (D为0时，表示两直线平行)\\
$$


【61】几何：理解向量除法的定义，公式和理论解释与性质

参考资料：

http://blog.sina.com.cn/s/blog_6b7148a80102w4rg.html

https://www.zhihu.com/question/29160144




摘要如下：



**同时已知点乘和叉乘定义矢量除法运算**

若  

$$
\left\{
\begin{aligned}
\vec{a}\cdot \vec{b}=c\\
\vec{a}\times \vec{b}=\vec{d}
\end{aligned}
\right.
$$

,则有
$$
\vec{a}\times (\vec{a}\times \vec{b})=\vec{a}(\vec{a}\cdot \vec{b})-\vec{b}(\vec{a}\cdot \vec{a})
$$

解出
$$
\vec{b}=\frac{\vec{a}(\vec{a}\cdot  \vec{b})-\vec{a}\times (\vec{a}\times \vec{b})}{\vec{a}\cdot \vec{a}}=\frac{\vec{a}c-\vec{a}\times \vec{d}}{\vec{a}\cdot \vec{a}} .
$$

四、复数解释

当矢量为平面矢量时，其可与一复数对应。即

$$
\left\{
\begin{aligned}
\vec{a}&=a_{x}\vec{i}+a_{y}\vec{j}\leftrightarrow a=a_{x}+ia_{y} \\
\vec{b}&=b_{x}\vec{i}+b_{y}\vec{j}\leftrightarrow b=b_{x}+ib_{y} 
\end{aligned}
\right.
$$

则有

$$
\bar{a}b=(\vec{a}\cdot \vec{b})+i(\vec{a}\times  \vec{b})
$$

显然有

$$
b=\frac{a(\vec{a}\cdot \vec{b})+ia(\vec{a}\times \vec{b})}{\left| a \right|^{2} } (a\ne 0)
$$

注意到其点积和叉积是福函数中的一对实部和虚部，若为一般解析函数即满足Cauchy条件。



**相关性质和理解：**

A：a和b的商的模等于$a$和$b$模的商

B：a和b的商所得向量的倾斜角等于$a$的倾斜角减去$b$的倾斜角。

C：可以这样理解二维向量所蕴含的变换：

将某个二维向量所代表的平面点与原点连线的倾斜角加上一个幅角（逆时针），
然后按照一定比例放大（乘法是乘模），
除法是上述运算的逆

D：从二元运算的角度，可以得到更进一步的理解：

假设$a,b,c$均为二维点或者二维的向量，令$p=a/b,q=a-b$

可以这样理解除法和减法运算，他们表示的均为两个操作数的有序关系

也就是说，他们本身就存储了某些变换关系的具体参数，

可以具体的揭示出，利用某种或者某些变换，如何把第二个几何对象（右侧的）变换为第一个对象

所以：令方向向右的单位向量$x=(1,0)$，原点为$t=(0,0)$

则：$a/b=p/x,a-b=q-t$

他们都表示两个对象同时发生同种变换（参数相同），相对关系不变，
均转换为某种单位对象和某个具体对象的关系，这个具体对象就是运算的结果；

除法蕴含旋转和伸缩，减法蕴含平移；

这个时候，如果用运算结果“右逆运算”某个向量：$c*p,c+p$
就表示将这种关系，作用于新的对象

因此：乘法和加法是将一个关系作用于某一对象，
而除法和减法是为了得到两个对象的具体关系（或者已知关系的具体参数）

事实上，平面上任两个等模的有向线段，均可以先通过旋转缩放，然后平移得到彼此
这样的变换是唯一的，参数的获取可以参见以下模板：

	P r=(a[2]-a[1])/(b[2]-b[1]);
	P c=a[1]-b[1]*r;

注意：这里的旋转是指的是以原点为中心的旋转，如果旋转中心不是原点，可以先全体平移

上面代码中：$r$是旋转伸缩向量,$r=|r|*(cost,sint)$,表示逆时针旋转$t$，然后伸缩$|r|$比例

这样就得到了$b$线段是如何旋转伸缩到与$a$线段有向平行的线段的

$(b[1],b[2]) ---r---> (b[1],b[2])*r  ==  (b[1]*r,b[2]*r)$

然后再看看$(b[1]*r)$是如何平移得到$a[1]$的，根据前面的理解就是代码中的$c$向量

事实上，$(r,c)$已经是完备的关系表述了

因此：$y=x*r+c$，我们可以很轻松的把$x$点，通过相同的关系变换到目标点$y$




**简要模板：**

	P operator *(const P &a)const{
		return (P){x*a.x-y*a.y,x*a.y+y*a.x};
	}
	
	P operator /(const P &a)const{
		return (P){x*a.x+y*a.y,-x*a.y+y*a.x}/a.len()/a.len();
	}





【62】数论：洲阁筛

【63】数论：分治fft

1.https://www.lydsy.com/JudgeOnline/problem.php?id=5342

​	一个和自己卷积有关的递推式，可以用分治fft，但是麻烦一点，要分类讨论，还有就是这个递推式的推导过程感觉有问题，不过这种结构析合树应该还是有点用的。

2.https://www.lydsy.com/JudgeOnline/problem.php?id=4836

​	对权值去分治，然后分类讨论，分别做和卷积和差卷积

3.https://www.lydsy.com/JudgeOnline/problem.php?id=3456

​	求带标号联通图数量，那个递推式可以写成卷积形式，用分治fft优化

4.https://www.lydsy.com/JudgeOnline/problem.php?id=4555

​	bell数的一个变形，考虑求和式的组合意义，然后根据这个推出递推式，然后用分治fft去计算，但是这种递推式也可以用多项式求逆去做，还没有学。

5.https://www.lydsy.com/JudgeOnline/problem.php?id=4332

​	求多项式等比数列和的第m项系数，可以用递归除2去做。

【64】数论：斯特林反演

【65】代数：拉格朗日插值法/拉格朗日多项式/拉格朗日条件极值

【66】组合：两个常用的自然数积和式

- 在$[1..k]$中选择$n$个不同的数，所有方案乘积之和
  $$
  e_n(1,2,\ldots,k)=\left[{k+1 \atop k+1-n}\right]
  $$

- 在$[1..k]$中选择$n$个可以相同的数，所有方案乘积之和
  $$
  h_n(1,2,\ldots,k)= \left\{\begin{matrix} n+k \\ k \end{matrix}\right\}
  $$
  注：公式右侧涉及两类斯特林数，详细理论参见对称多项式

【67】数论：$Min\_25$筛

参考资料：https://blog.csdn.net/oi_Konnyaku/article/details/81346998

【68】代数：多项式理论

基础：$FFT$，多项式求逆/求导/求倒，$+-*/$，乘方，开方，整除，取模，求$ln$，求$exp$，生成函数，牛顿迭代，泰勒展开，任意模数$FFT$等多项式基础，积分，多项式嵌套，多点求值和插值

参考资料：https://blog.csdn.net/oi_Konnyaku/article/details/79682528

题目：

1.https://www.nowcoder.com/acm/contest/157/F

注：生成函数优化背包$dp$

题解：https://www.nowcoder.com/discuss/93531?type=101&order=3&pos=14&page=1



【69】贪心博弈：极大极小定理

【70】代数：拟阵

【71】代数：BEST定理

https://en.wikipedia.org/wiki/BEST_theorem


【72】代数：排列与笛卡尔树的关系

【73】代数：表达式树/表达式计算

- **将中缀表达式转换为后缀表达式** 

转载自 https://blog.csdn.net/fireflylane/article/details/83017889*

**适用于二元运算，且都为左结合**

step1：初始化一个栈和一个后缀表达式字符串 
step2：从左到右依次对中缀表达式中的每个字符进行以下处理，直到表达式结束

如果字符是‘（’，将其入栈
如果字符是数字，添加到后缀表达式的字符串中
如果字符是运算符，先将栈顶优先级不低于该运算符的运算符出栈，添加到后缀表达式中，再将该运算符入栈。注意，当‘（’在栈中时，优先级最低
如果字符是‘）’，将栈顶元素出栈，添加到后缀表达式中，直到出栈的是‘（’ 
step3：如果表达式结束，但栈中还有元素，将所有元素出栈，添加到后缀表达式中

- **将一棵后缀表达式转换成表达式树的方法**

*转载自 https://blog.csdn.net/zy010101/article/details/83027514*

**其实就是模拟后缀表达式求值的过程**

我们每次读入一个符号，如果是操作数，我们建立一个单节点树（该节点是没有左右子树的），并将指向这棵树的指针入栈；如果读到的符号是操作符，那么从栈中弹出两个子树，分别作为该操作符的左右子树，将形成的这颗新树压入栈中。接着继续读取符号，重复上面的步骤，直到读取结束为止。这时候，栈中只剩一个元素，该元素就是这颗表达式树的根节点。

【74】代数：求$n!$模大质数($fft/ntt$应用)

https://www.cnblogs.com/zzqsblog/p/8408691.html

【75】代数：拉格朗日反演公式

【76】代数：初等对称轮换多项式简单应用

https://www.cnblogs.com/zzqsblog/p/7265111.html

【77】代数：线性递推$Berlekamp-Massey(BM)$算法

https://www.cnblogs.com/zzqsblog/p/6877339.html

【78】数论：$O(1)$查询$gcd$

https://www.cnblogs.com/zzqsblog/p/5436775.html

【79】代数：$abel$阿贝尔求和变换公式



【80】组合：$gcd$卷积与$lcm$卷积

卷积是一种比较耗费计算资源的基础数学运算，在数学上我们处理卷积的一般方法都是通过各种变换或者转化，使得问题转化为比较容易计算的计算类型(比如序列点积)，想方设法加速计算的效率，当然这需要卷积本身具有一定的数学性质。

***gcd*卷积**是说我们需要计算的卷积公式为：


$$
\Large
c_k=\sum_{(i,j)=k}a_i*b_j
$$



令$A,B,C$分别为$a,b,c$的类点值序列(闭区间$[1,n]$,下标超过$n$值为$0$)，

其中一个定义如下：


$$
\Large
A_k=\sum_{k|d}a_d
$$

那么即有：

$$
\Large
C_k=\sum_{k|d}c_d=\sum_{k|d}\sum_{(i,j)=d}a_i*b_j=\sum_{k|(i,j)}a_i*b_j \\

\Large
=\sum_{k|i}\sum_{k|j}a_i*b_j=(\sum_{k|i}a_i)*(\sum_{k|i}b_i)=A_k*B_k
$$

我们得到：

$$
\Large
C=A\bullet B
$$

序列反演公式： 

$$
\Large
a_k=\sum_{k|d}A_d*\mu_{\frac{d}{k}}
$$

***lcm*卷积**是说我们需要计算的卷积公式为：


$$
\Large
c_k=\sum_{[i,j]=k}a_i*b_j
$$

令$A,B,C$分别为$a,b,c$的类点值序列，其中一个定义如下：


$$
\Large
A_k=\sum_{d|k}a_d \Leftrightarrow A=a \circ I
$$

那么即有：


$$
\Large
C_k=\sum_{d|k}c_d=\sum_{d|k}\sum_{[i,j]=d}a_i*b_j=\sum_{[i,j]|k}a_i*b_j \\

\Large
=\sum_{i|k}\sum_{j|k}a_i*b_j=(\sum_{i|k}a_i)*(\sum_{i|k}b_i)=A_k*B_k
$$

我们得到：


$$
\Large
C=A\bullet B
$$

序列反演公式： 

$$
\Large
a_k=\sum_{d|k}A_d*\mu_{\frac{k}{d}}=\sum_{x*y=k}A_x*\mu_y \Leftrightarrow a=A \circ\mu
$$

更多信息可以参见模板和配套的$md$说明文件

【81】集合幂级数和快速莫比乌斯变换$FMT$/分治乘法

参见2015国家集训队论文

【82】组合：单位根反演

【83】组合：循环卷积

简单的说，与普通FFT算法的唯一区别在于：

**变换采用的单位根的阶是与变换序列长度一样的**，因此当我们限制FFT变换的长度的时候，

会产生越界，而越界在低阶单位根中会产生循环，而卷积的本质并没有发生变化，都是选用合适的线性变换矩阵，左乘带变换的向量，进行正变换

【84】组合/数论：分圆多项式
https://yhx-12243.github.io/OI-transit/memos/17.html#pr-1-1

**Cyclotomic polynomial**

https://en.wikipedia.org/wiki/Cyclotomic_polynomial

注：参见onenote笔记



【85】组合：k进制fwt/高维广义快速离散傅里叶变换fft

**本质**：有穷高维循环卷积$fft$，循环周期为$k$

http://www.cnblogs.com/TinyWong/p/10351109.html

https://www.cnblogs.com/reverymoon/p/10197711.html

需要变换的下标每个数都是$n$位的$k$进制数，那么下标空间为$[0,k^n)$

这相当于一种$n$维的($n=log_kN$)每维长度为$k$的$fft$循环异或卷积变换($k$进制不进位加法)，按照高维$fft$的思路，应该按照某种维度的排列顺序(比如从高位到低位)，逐维正变换，然后每个位置独立做点积，最后再逐维逆变换(对应一种递归或者迭代过程)

$2$进制宏观上正变换的实质：$\large c_i=\sum_{j=0}^{2^k-1}(-1)^{num(j\&k)}a_j,i\in[0,2^k-1]$

$k$进制微观上每维正变换的实质，与$fft$相似，是**向量左乘一个变换矩阵**$T$，满足$T(i,j)*T(i,k)=T(i,j \oplus k)$

我们采用$k$阶单位根的***范德蒙德矩阵***：
$$
T=\begin{bmatrix}
 1& 1 &  1& ... & 1\\ 
 1& w_k^1&  w_k^2& ... & w_k^{k - 1}\\ 
 1&  w_k^2 &  w_k^4&  ... & w_k^{2(k - 1)}\\ 
 ...&  ...&  ...&  ...& ...\\ 
 1&  w_k^{k - 1}& w_k^{2(k - 1)} & ... & w_k^{(k - 1)(k - 1)}
\end{bmatrix}
$$
其行列式为：
$$
det(T)=\prod \limits_{i < j} (x_i - x_j)，x_i\ne x_j \\
det(T)\ne 0 \leftrightarrow T可逆
$$
其逆矩阵为：
$$
T^{-1}=\frac{1}{k} \begin{bmatrix}
 1& 1 &  1& ... & 1\\ 
 1& w_k^{-1}&  w_k^{-2}& ... & w_k^{-(k - 1)}\\ 
 1&  w_k^{-2} &  w_k^{-4}&  ... & w_k^{-2(k - 1)}\\ 
 ...&  ...&  ...&  ...& ...\\ 
 1&  w_k^{-(k - 1)}& w_k^{-2(k - 1)} & ... & w_k^{-(k - 1)(k - 1)}
\end{bmatrix}
$$
证明用到结论：
$$
[n | t] = \sum \limits_{i = 0}^{n - 1} w_n^{ti}
$$
注：2进制下的特殊情形
$$
T=\begin{bmatrix} 1& 1\\  1& -1 \end{bmatrix} =  \begin{bmatrix} 
0.5& 0.5\\
0.5& -0.5\\
\end{bmatrix}^{-1}
$$
一种**实现思路**是：

采用递归，传入参数FWT(a,S,n,op)，表示的是将a数组中以S开头的长度为n的一段区间进行正/逆变换(op=1为正/op=-1为逆)，那么首先将这段区间平均分为k段，每段长度n/k，逐段递归FWT，然后回溯合并时扫描段长(穷举一个段中偏移为i的位置)，将这些位置取出来构成一个k维向量，将这个向量左乘单位根矩阵$T$或者$T^{-1}$，变换后按顺序放置回去，对每个偏移量i都这样操作即可



**数的表示技巧：单位根表示法**

注意到一个数$x$，需要与$k$阶单位根做乘积，正常的思路是用一个$pair<double,double>$保存其复数的实部和虚部，用复数的乘法规则运算，但是这样显然精度损失严重，最终不容易回到其整数形态

注意到数$x$一定具有形式：$x=\sum_{i=0}^{k-1}a_i\omega^i$，故可以使用$k$维向量$\overrightarrow{a}$表示数$x$

那么普通的加减就是模意义下逐位加减，普通的乘法变为$k$维向量的**循环卷积**即可

而与$\omega^t$相乘相等于，此向量循环右移$t$位

考虑最后如何由向量$\overrightarrow{a}$得到整数值$x$:
$$
令cnt=k\&-k，L=k/cnt \\
容易发现，[0,k)这些下标可以分成cnt组，每组L个元素，分组的依据是一个下标i\&cnt的值的不同 \\
比如k=20可以分为以下4组： \\
$$

| 组/元素 | /4=0 | /4=1 | /4=2 | /4=3 | /4=4 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 组0   | 0    | 4    | 8    | 12   | 16   |
| 组1   | 1    | 5    | 9    | 13   | 17   |
| 组2   | 2    | 6    | 10   | 14   | 18   |
| 组3   | 3    | 7    | 11   | 15   | 19   |

当$k$为偶数时，$0$和$k/2$这两个位置保存整数值；当$k$为奇数时，只有$0$这个唯一的位置保存整数值

我们每组独立考虑，首先$0$和$k/2$不会分到同一组，因为$k/2$存在，则必定$k$为偶数，$k$为偶数，则可以先按照每个下标的最后一位是$0$或者$1$暂时分成两组，若$0$和$k/2$同分在组$A$，则$x$轴上方和下方显然有一样多的元素属于组A，那么组$A$显然包含了偶数个元素，则组$A$，还可以继续拆分为两组，重复应用这个过程，由无穷递降法知矛盾

**基本事实**：每组单位根之和为$0$，这是因为：
$$
x^n-1=\prod_{i=0}^{n-1}(x-\omega^i)=(x-1)(x^{n-1}+x^{n-2}+\dots+1) \\
约去x-1得到：\\
x^{n-1}+x^{n-2}+\dots+1=\prod_{i=1}^{n-1}(x-\omega^i) \\
而\sum_{i=0}^{L-1}\omega_{k}^{cnt*i+t}=\omega^t(\sum_{i=0}^{L-1}\omega_{cnt*L}^{cnt*i})=\omega^t(\sum_{i=0}^{L-1}\omega_{L}^{i})=0
$$
若一个组不含$0$和$k/2$，那么这个组元素都相同，可消去为$0$；若含有其中一个，则其余元素全相同，可消除为除$0$下标之外元素为$0$；那么我们最多考虑两个组贡献，就是$a[t]-a[t+cnt],t \in \{0,k/2\}$

可以得到模板代码求整数值如下：

```c++
inline ll Value() {
	int cnt=K&-K,L=K/cnt; ll ret=a[0]-(L>1)*a[cnt];
	if (K&1^1) ret-=a[K>>1]-(L>1)*a[(K>>1)+cnt],ret%=_p;
	return ret;
}
```



**单位根表示法的优化**：

很显然，对于一个偶数进制k(k为奇数的两倍)，除了用k阶单位根表示一个数，还可以用k/2阶单位根，这主要是因为有类似于折半引理的复数性质，可以节约一些常数；如果这里可以找到一些更本质的性质，也许可以推广下去，或者针对具体的进制，具体的分析



**数的表示技巧：模域表示法**

这是一种可以让高进制卷积，加速好几倍同时没有精度误差的方法

- 适用条件：只适用于**特殊进制$k$**和**模数$p$**，要求$p$为质数且$k|p-1$.
  - 模$p$意义下循环群阶为$p-1$，元素阶以及循环子群的阶均为其约数
  - 主要思想是用模域中的数刻画有理数，实数，以及复数域中的数
  - $\sqrt[m]{t}$用$m$次剩余去刻画，虚数单位$i$使用$\sqrt{-1}$刻画，一定条件下，复数可以得到刻画
  - 令$g$为模$p$原根，$k$阶单位根，共$k$个，构成循环子群；原根$g$为其生成元，$w_k=g^{\frac{p-1}{k}}$
  - 模数为$10^9+9$或$998244353$最为适用，进制$k$为$2,3,4,7,8$最为得当
- 表示方法：根据前面的分析，一个数$x=\sum_{i=0}^{k-1}a_iw_k^i$，带入单位根即得到模域表示
- 基本运算
  - 乘法转化为循环卷积，这里即普通乘法，衍生出乘方
  - 左右移，通过乘除单位根的幂次得到
  - 实数求值，该值就是答案，因为虚部为$0$，在模域里也抵消了
  - 逆向分解，不大可能，因为相当于降维了，信息与高维比不充分
- 主要用途
  - 对卷积运算加速常数
  - 在复数域中扩展多项式操作，比如生成函数带入单位根，或者单位根反演，支持三角函数操作等
  - $ntt$本身就是一种特殊的$2^k$阶单位根处的多点求值






**求逆技巧**：

注意在$FWT$的逆变换中，最中间的赋值语句要除以一个进制数，或者最终结果每个元素要除以一个长度$N=k^p$

而$FWT$正变换中没有除法，所以最终结果每个元素只要除以$N^t$，其中$t$为逆变换的总次数



**模数变更**：

当模数不是一个质数的时候，考虑进制数$k$可能和模数不互质，那么将$k$分解为$k=k'*q$，其中$q$使用数学技巧转化掉(事实上要视情况而定，可能不能转化掉)，而$k'$是互质成分，存在逆元

当存在特殊模数的时候，比如$2^{58}$，可以不取模，常数可能会小很多



**公共性质：**

卷积定理表明：
$$
T(a\oplus b)=T(a)\cdot T(b) \\
T(a+b)=T(a)+T(b) \\
T(h(a,b))=h(T(a),T(b)) \\
T(h(\overrightarrow{a}))=h(\overrightarrow{T}(\overrightarrow{a})) \\
其中h(a,b,c)是关于多项式a,b,c之间的组合多项式函数
$$




【86】组合/数论：fft应用：优化进制转化

【87】代数/数论：狄利克雷定理(用于等差数列)

**Dirichlet's theorem on arithmetic progressions**

https://en.wikipedia.org/wiki/Dirichlet%27s_theorem_on_arithmetic_progressions

【88】数论：高斯整数

**Gaussian integer**

https://en.wikipedia.org/wiki/Gaussian_integer

【89】组合：二维fft

***形式化的理解***：
$$
\Large D F T : : f(x, y)=\sum_{u=0}^{M-1} \sum_{v=0}^{N-1} F(u, v) e^{2 \pi i\left(\frac{ux}{M}+\frac{vy}{N}\right)} \\
\Large I D F T : : F(x, y)=\frac{1}{N M} \sum_{u=0}^{M-1} \sum_{v=0}^{N-1} f(u, v) e^{-2 \pi i\left(\frac{x u}{M}+\frac{y v}{N}\right)}
$$
范德蒙德矩阵：
$$
V=\left[ \begin{array}{ccccc}{1} & {x_{1}} & {x_{1}^{2}} & {\dots} & {x_{1}^{n-1}} \\ {1} & {x_{2}} & {x_{2}^{2}} & {\cdots} & {x_{2}^{n-1}} \\ {1} & {x_{3}} & {x_{3}^{2}} & {\dots} & {x_{3}^{n-1}} \\ {\vdots} & {\vdots} & {\vdots} & {\ddots} & {\vdots} \\ {1} & {x_{n}} & {x_{n}^{2}} & {\dots} & {x_{n}^{n-1}}\end{array}\right]
$$
$n$阶单位根对应的范式矩阵：令上式中的$x_i=\omega_n^i$，则$n$阶单位根一个对应一行，我们令为行向量$\overrightarrow{a_i}$

则此范式矩阵可重写为：
$$
V(n)=\left[ \begin{array}{ccccc}{\overrightarrow{\omega_n^0}} \\ {\overrightarrow{\omega_n^1}} \\ {\overrightarrow{\omega_n^2}} \\ {\vdots} \\ {\overrightarrow{\omega_n^{n-1}}} \end{array}\right]
$$
假设待变换的一维向量为$\overrightarrow{x}$：

**一维fft​**：

其正变换实质为：
$$
T(\overrightarrow{x})=V(n)*\overrightarrow{x}=\left[ \begin{array}{ccccc}{\overrightarrow{\omega_n^0} \cdot\overrightarrow{x}} \\ {\overrightarrow{\omega_n^1} \cdot \overrightarrow{x}} \\ {\overrightarrow{\omega_n^2}\cdot \overrightarrow{x}} \\ {\vdots} \\ {\overrightarrow{\omega_n^{n-1}}\cdot \overrightarrow{x}} \end{array}\right] \\
其中*表示broadcasting乘法，\cdot表示向量或者矩阵点积(内积)
$$
假设待变换的二维矩阵为$X$：

**二维fft：**

其正变换实质为：
$$
V(n,m)=V(n)*V(m)^T=\left[ \overrightarrow{\omega_n^{i}} \circ \overrightarrow{\omega_m^j }\right]_{n\times m} \\
其中*表示矩阵乘法，\circ表示向量或者矩阵卷积 \\
T(X)=V(n,m)*X=\left[\left( \overrightarrow{\omega_n^{i}} \circ \overrightarrow{\omega_m^j }\right) \cdot X \right]_{n\times m} \\
其中*表示broadcasting乘法，\cdot表示向量或者矩阵点积(内积) \\
$$
***形象化的理解***：

将所有的维度编号，且按照一定顺序排成一排，从左往右逐维度正变换(每次变换的是一个一维向量)；

两个带卷积矩阵或者张量都这样做，然后将整个超立方体或者类似结构，整体做点积(对应相乘但是不加)；

最后结果按照原来的相反顺序，逐维度做逆变换

比如$A \circ B$：先把$A$和$B$分别逐行变换，再逐列变换，形成$A'$和$B'$，然后两者做不加点积$C'=A'\cdot B'$，然后对$C'$先做逐列逆变换，再做逐行逆变换，形成$C$

**注意**：这里的$n$和$m$，是待卷积序列或者矩阵规模，不需要扩充到具体$2$的幂次，后者是具体的快速算法的实现



【90】数论：Kummer's theorem

https://en.wikipedia.org/wiki/Kummer%27s_theorem



【91】代数：暴力多项式取模$m^2logn$，用于特征多项式法解$k$阶常系数线性齐次递推数列(k>=1000)

蕴含着：Cayley–Hamilton theorem

https://en.wikipedia.org/wiki/Cayley%E2%80%93Hamilton_theorem

参考资料：

https://blog.csdn.net/joker_69/article/details/80869814

https://blog.csdn.net/hzj1054689699/article/details/85683342

有模板题和模板：***LinearRecursion***ZP版本$O(m^2logn)$

https://www.lydsy.com/JudgeOnline/problem.php?id=4161

**简要笔记**：

$O(m^2logn)$可以使用长除法，模拟多项式除法/取模(被除$deg=n \le 1e18$,除数$deg=m \le 1000$)，参见模板

令递推变换矩阵为$A_{m \times m}$，其特征多项式$G(\lambda)$为：
$$
G(\lambda)=|\lambda I-A|=\lambda^{m}-\sum_{i=0}^{m-1} a_{m-i} \lambda^{i}=[-a_m,-a_{m-1},-a_{m-2},\dots,-a_1,1]
$$
根据$Cayley–Hamilton$定理，有：$G(A)=0$

若$x^n=F(x)G(x)+C(x),deg(C)<m$，则有$A^n=C(A)$

更进一步地：$A^n \overrightarrow{x}=C(A)\overrightarrow{x}=(\sum_{i=0}^{m-1}c_iA^{i})\overrightarrow{x}=\sum_{i=0}^{m-1}c_i(A^{i}\overrightarrow{x})$

假设我们取具体而特定的：$\overrightarrow{x}^T=[x_{m-1},x_{m-2},x_{m-3},\dots,x_1,x_0]$

为了得到$x_n$，我们应该左乘$A^{n-m+1}$,取结果向量第一个元素$x_n=(A^{n-m+1}\overrightarrow{x})[1]$

我们得到：
$$
x_n=\sum_{i=0}^{m-1}c_ix_{m-1+i}
$$
上述差卷积需要已知：$X'=[x_{m-1},x_{m},x_{m+1},\dots,x_{2m-3},x_{2m-2}]=[x_i],i \in [m-1,2m-2]$

此种方法可能还需要我们多算$O(m)$项，如果我们左乘$A^{n}$取结果向量第m个元素(最后一个)，亦即：
$$
x_n=(A^n\overrightarrow{x})[m]=\sum_{i=0}^{m-1}c_i(A^{i}\overrightarrow{x})[m]=\sum_{i=0}^{m-1}c_i((A^{i}\overrightarrow{x})[m])=\sum_{i=0}^{m-1}c_ix_i=\overrightarrow{C}\cdot\overrightarrow{X} \\

其中：\overrightarrow{C}=[c_i],\overrightarrow{X}=[x_i], i \in [0,m-1],另\cdot表示向量点积
$$
可以看到，这种方法没有什么冗余计算，$\overrightarrow{C}$和$\overrightarrow{X}$均为已知的，只要直接做一次点积即可

而$\overrightarrow{C}$通过多项式$x^n$对$G(x)$取模得到，由于$n$巨大，所以不能用普通的多项式取模模板，考虑使用快速幂$Pow(x,n,G)$,令多项式$x^t$在模$G$意义下不断自乘即可，故我们需要写一个模板函数，$mul(A,B,G)$表示模$G$意义下多项式$A$和$B$乘积，其中如果多项式乘和取模用暴力$O(m^2)$，则此方法复杂度$O(m^2logn)$，而如果使用多项式模板($ntt$实现)，则复杂度为$O(mlogmlogn)$

如果我们只知道$\overrightarrow{a}=[a_i],i \in [1,m]$，和$x_0$，而不知道整个$\overrightarrow{X}$，现在要求$x_n$，就需要先求$\overrightarrow{X}$：

$O(m^2)$可以暴力线性递推，$O(mlog^2m)$可以使用分治$fft/ntt$，$O(mlogm)$可以使用以下生成函数方法：
$$
令\overrightarrow{H}=\sum_{i=0}^{+\infin}x_iz^i为普通型生成函数 \\

\overrightarrow{H}=\frac{\overrightarrow{H}(1-\overrightarrow{a})}{1-\overrightarrow{a}} \\
故：\overrightarrow{X}=\overrightarrow{H}\%x^m=\frac{\overrightarrow{H}(1-\overrightarrow{a}) \% x^m}{1-\overrightarrow{a}}=\frac{(\overrightarrow{H}\%x^m(1-\overrightarrow{a}) \% x^m)\%x^m}{(1-\overrightarrow{a})\%x^m} \\
注：上式分子实际上是个有穷多项式，特别当心\overrightarrow{a}下标是从1开始的，即[1,m]
$$

当然，上述方法适用于知道$x_0$，比较快速地求出$f[1..n],k \le n \le 10^6$

更本质地讲，如果我们把所有序列下标为负的部分，都看作$0$，那么其实$x_0$不再是序列$x$的首项

这样讲的意义在于，我们可以重构序列$\overrightarrow{X'}=[x_i],i \in [-(m-1),0]$

从而重构：$\overrightarrow{x'}^T=[x_{0},x_{-1},x_{-2},\dots,x_{-(m-2)},x_{-(m-1)}]$

我们仍然左乘$A^{n}$取结果向量第1个元素，亦即：
$$
x_n=(A^n\overrightarrow{x'})[1]=\sum_{i=0}^{m-1}c_i(A^{i}\overrightarrow{x'})[1]=\sum_{i=0}^{m-1}c_i((A^{i}\overrightarrow{x'})[1])=\sum_{i=0}^{m-1}c_ix_i=\overrightarrow{C}\cdot\overrightarrow{X} \\

其中：\overrightarrow{C}=[c_i],\overrightarrow{X}=[x_i], i \in [0,m-1],另\cdot表示向量点积
$$

发现最终需要的还是$\overrightarrow{X}$，而不是$\overrightarrow{X'}$；我们左乘$A^{n+m-1}$取结果向量第$m$个元素，亦即：

$$
x_n=(A^{n+m-1}\overrightarrow{x'})[m]=\sum_{i=0}^{m-1}c_i'(A^{i}\overrightarrow{x'})[m]=\sum_{i=0}^{m-1}c_i'((A^{i}\overrightarrow{x'})[m])=\sum_{i=0}^{m-1}c_i'x_{i-m+1}=\overrightarrow{C'}\cdot\overrightarrow{X'}=c'_{m-1}x_0 \\

其中：\overrightarrow{C'}=[c_i'],i \in [0,m-1],\overrightarrow{X'}=[x_i], i \in [-(m-1),0],另\cdot表示向量点积
$$
因此可以看到，我们不再需要计算多余的前$m$项内容，只要计算多项式快速幂模，亦即$\overrightarrow{C'}$即可

**推广：**

求递推序列$\{x_i\}$的前$n+1$项和$s_n$，沿用上述的方法：

令$C_i$表示多项式$x^i$对特征多项式$G$取模，令$C=\sum_{i=0}^nC_i=(\sum_{i=0}^nx^i)\%G$，类似于快速幂的递归算法可以求解$C$，结果仍然是$\overrightarrow{C}\cdot\overrightarrow{X}$





【92】在线性递推中，涉及到的多项式取模，倍增快速幂，以及求逆计算的fft常数优化技巧

参考资料：https://blog.csdn.net/joker_69/article/details/80869814



【93】概率论：全期望公式
$$
E(E(X|Y))=E(X) \\
注意：E(X|Y)是个随机变量，概率分布：以P(Y=y)概率取到E(X|Y=y)
$$
进一步分析可见维基百科或者2013年国家集训队论文《概率论应用》



【94】组合：超平面切平面的规律

经典问题：$n$个$k-1$维超平面最多可以将$k$维空间分割成多少个空间区域
$$
f(n,k)=\sum_{i=0}^{min(k,n)}\binom{n}{i}
$$

| $f(n,k)$ | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | $\dots$ |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ------- |
| 0        | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | $\dots$ |
| 1        | 1    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | $\dots$ |
| 2        | 1    | 3    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | $\dots$ |
| 3        | 1    | 4    | 7    | 8    | 8    | 8    | 8    | 8    | 8    | $\dots$ |
| 4        | 1    | 5    | 11   | 15   | 16   | 16   | 16   | 16   | 16   | $\dots$ |

递推公式：
$$
f(0,k)=1,k \ge 0 \\
f(n,k)=f(n-1,k-1)+f(n-1,k)
$$
显然将上表中，每一行都差分一下，记得到组合数表；可以这样理解，每个第$0$行的$1$都为下面区域带来一个组合数的贡献，那么$(n,k)$相当于得到了行总是$n$但是列$\in [0,k]$的组合数贡献之和

该序列可以通过莫队算法或者分治$fft$快速求得一组，线性时间可预处理一行或者一列

特别的，令$k=2$有：直线分割平面的区域数目：
$$
f(n,2)=\binom{n}{0}+\binom{n}{1}+\binom{n}{0}=n(n+1)/2+1
$$
一些其他问题，比如折线划分平面，或者闭曲线椭圆划分平面，这些都可以用类似的类比递推归纳的方法，得到递推式，但暂时不便于推广到高维情形



【95】代数/拓扑：全序关系、偏序关系与偏序集

全序关系$\le$满足：完全性，即$\forall x,y \in S,x \le y || y \le x$

偏序关系$\le$满足：自反性(反身性)，即$\forall x \in S,x \le x$

两者均满足：

反对称性，即$\forall x,y \in S,x\le y \&\& y \le x \leftrightarrow x=y$

传递性，即$\forall x,y,z\in S, x \le y \&\& y \le z \to x \le z$

由于完全性是反身性的特例，故全序关系是偏序关系的特例，即全序关系一定是偏序关系

二者直观的区别在于，偏序关系并不是两两可比(默认只知道自己和自己可比)，但是全序关系是两两可比的



全序集及其笛卡尔积偏序线性空间中的$min/max$函数的基本性质与推广

- 都满足交换律，结合律等基本性质
- 满足对称分配率，即$min$对$max$满足分配率，反之亦然

设全序集$(S,\le)$中运算$+$表示二元$min$函数，运算$*$表示二元$max$函数，该表示可以用多元多项式刻画复杂的$min/max$嵌套表达式

令$T_n=S^n,n\in[1,+\infin]$，注意$(T_n,\le)$一般不再是全序集，但是如果定义$T_n$上的$min$为各维$min$的笛卡尔积，可以发现仍然满足上述的分配率；当$S=\{0,1\}$时，$\&$为$S^n$上的$min$，$|$为$S^n$上的$max$；当$S=N$时，$gcd$为$S^n$上的$min$，$lcm$为其$max$，可以推广到$S=Z$，涉及到有理数的$gcd$；当$S^k$为全集$U$($|U|=n$)的$k$元子集簇时，$\cap$为其$min$，$\cup$为其$max$

与$gcd$有关的分配率的直接推论：

- $lcm(gcd(x,y),gcd(x,z),gcd(y,z))=gcd(lcm(x,y),lcm(x,z),lcm(y,z))$
- $n$元整数集$(k-k)gcd$的$lcm$等于$((n-k+1)-(n-k+1))lcm$的$gcd$



【96】代数：偏序闭包



【97】代数：偏序矩阵及其行列式

- $n \times n$的矩阵$S_n[i][j]=gcd(i,j),i,j \in [1,n]$，其行列式$|S_n|=\prod_{i=1}^n \phi(i)$
- $ n \times n $的矩阵$S_n[i][j]=g(gcd(i,j)),i,j \in [1,n]$，其行列式$|S_n|=\prod_{i=1}^n h(i)$，其中$\sum_{d|n}h(d)=g(n)$，其中$h$序列可由莫比乌斯反演得到
- 推广数集为$A$，满足$A$中元素对$gcd$封闭，则$S_n[i][j]=gcd(a_i,a_j)$，其行列式$|S_n|=\prod_{i=1}^nh(a_i)$
- 若$A$不对$gcd$封闭，则$|S_n|=\prod_{x \in f(A)}h(x)$，其中$f(A)$为$A$的元素所有约数构成的新集合

【98】组合：网格图不交路径计数



【99】代数：线性基的持久化与简单扩充



【100】数论/密码学：RSA公钥体系

公钥加密，私钥解密，$RSA$可靠性取决于大数因式分解的困难性

取两个大而不太接近的质数$p,q$，令$n=pq,t=\phi(n)=(p-1)(q-1)$

取一个随机数$e \in [2,t),gcd(e,t)=1$，令$d=e^{-1}\pmod{t}$

$(n,e)$为公钥，$(p,q,d)$为私钥，明文为$M$，密文为$C$

加密算法：$C=M^e \pmod{n}$

解密算法：$M=C^d \pmod{n}$



【101】数论/密码学：$ElGamal$密码

其可靠性取决于大数离散对数的困难程度

选择一个大质数$p$，且要求$p-1$含大质因子，选择一个$p$的生成元或原根$a$

随机选择一个$d \in [2,p-2]$，令$y=a^d \pmod{p}$

公开$p,a$，取$y$为公钥，$d$为私钥，明文为$M$，密文为$(C_1,C_2)$

加密算法：随机选取$k \in [2,p-2]$

$C_1=a^k \pmod{p}$

$C_2=My^k \pmod{p}$

解密算法：$M=C_2C_1^{-d} \pmod{p}$



【102】数论/密码学：椭圆曲线密码学



【103】微积分：椭圆积分



【104】代数：基与线性空间及其关系和运算



【105】几何：高维叉积的定义和几何性质



【106】数论：$Vantieghems theorem$

$n$是质数当且仅当：
$$
\prod_{1 \leq k \leq n-1}\left(2^{k}-1\right)\equiv n\pmod{2^n-1}
$$
可以换成其他的公式：
$$
\prod_{1 \leq k \leq n-1}\left(X^{k}-1\right) \equiv n-\left(X^{n}-1\right) /(X-1)\pmod{X^n-1} \\

\prod_{1 \leq k \leq n-1}\left(X^{k}-1\right) \equiv n \pmod{\frac{X^{n}-1}{X-1}}
$$

【107】概率论：正规数

[维基百科](https://en.wikipedia.org/wiki/Normal_number)



【108】数论：高度合成数

[维基百科](https://en.wikipedia.org/wiki/Highly_composite_number)



【109】代数：一些基本代数函数的基本性质

二进制含$1$个数奇偶性函数$p(x)$基本性质

- $p(x\oplus y)=p(x)\oplus p(y)$，即$p$对异或$\oplus$满足分配率



【110】代数：拉格朗日乘子法



【111】概率：简单随机游走



【112】代数/组合：生成函数算子符号展开



【113】代数/组合：生成函数法求数列极限



【114】线代：线性基修改查询全家桶

【115】代数：幂等序列对的构成生成方程

简单的情形：将$i$按照二进制表示中$1$的个数奇偶性分成两类


【116】代数：一维特殊序列的经典卷积结论

【117】代数：整除序列和强整除序列

【118】组合/代数：杨氏矩阵/杨表(Young tableaux) [维基百科：杨表](https://en.wikipedia.org/wiki/Young_tableau)

- 定义
  - **形状**：$N$的一个不严格降序拆分称为形状，$\lambda=(\lambda_1,\lambda_2,\lambda_3,...,\lambda_m)$，$\lambda_i \ge \lambda_{i+1}$，$\lambda \vdash N$
  - **杨图**：某种形状$\lambda$的未填数字的表格，共$m$行，第$i$行$\lambda_i$列
  - **杨表**：填满数字的杨图
    - **标准杨表**：从上向下严格増，从左往右严格増，$1..N$各出现一次
    - **半标准杨表**：从上向下严格増，从左往右不严格増
    - **杨表权重**：一个向量$(1,1,...,1)$表示各数字出现次数
  - **斜杨图/表**：$\lambda/\mu$，$\lambda_i \ge \mu_i$，第$i$行在$[\mu_i+1,\lambda_i]$列填数字
    - 标准/半标准：参见上面
  - **边角**：一个格子为边角，其下面和右边的格子不存在
  
- 杨表与排列
  - 行插入算法$S \gets x$
    
    - 所移动的格子看上去一定是向不严格的左下方移动
    
      ![杨表_行插入](\pic\数学\杨表_行插入.PNG)
    
  - 列插入算法$x \to S$
    
    - 与行插入对称
    
      ![杨表_列插入](\pic\数学\杨表_列插入.PNG)
    
  - 边角删除算法
    
    - 与行插入互为逆操作
    
      ![杨表_边角删除](\pic\数学\杨表_边角删除.PNG)
    
  - 记录表：一个排列$X$进行行插入得到杨表$P_X$，同时可以得到记录表$Q_X$，只需要每次在将元素$x_i$插入时，杨表增加新元素的位置，放入下标$i$；记录表$Q_X$与$P_X$同规模
  
    ![杨表_记录表](\pic\数学\杨表_记录表.PNG)
  
  - 一一对应：[Robinson–Schensted correspondence](https://en.wikipedia.org/wiki/Robinson%E2%80%93Schensted_correspondence)
  
    - 长度为$n$的排列与**一对形状相同的标准杨表**一一对应
    - 令$f_{\lambda}$表示形状为$\lambda$的标准杨表的数量，则$\sum_{\lambda \vdash n}f_{\lambda}^2=n!$
  
  - 排列插入算法的性质
  
    - 行列交换律：$(x \to S) \gets y=x \to (S \gets y)$，这表明相邻两个对行列的插入操作(一个对行，一个对列)是可交换的
    - 行列相对独立性：一个插入操作序列，可以调整为先完成行操作，再做列操作，每种相对顺序不变
    - 翻转特性：$X^R$表示排列的左右翻转，则$P_X=(P_{X^R})^T$，这表明排列行插入等价于倒序列插入，注意只对杨表成立，对记录表**不**成立
    - 相反数特性：排列倒序行插入得到的杨图(形状)等价于原排列***相反数序列***行插入得到的杨图，注意不是杨表相同
  
- 杨表与对称矩阵
  
  - 普通非负整数矩阵
  
    - 矩阵$A$拆成序列对$X$：其中$(i,j)$这个数对出现$A[i][j]$次，数对按照$pair$排序，即构成$(first,second)$序列对
  
    - $X^{-1}$：只要把每个数对两维交换，重新排序，得到新的序列对
  
    - $P_X$表示将$X$第二行(即第二维，或者$second$序列)插入构造的杨表，$Q_X$表示在$P_X$构造过程中，将$first$序列视为下标构造的记录表
  
    - 性质关系：$(P_X,Q_X)=(Q_{X^{-1}},P_{X^{-1}})$
  
      ![性质关系](\pic\数学\杨图1.PNG)
      
    - 普通的每行每列严格有一个$1$的$01$矩阵$M$，$P_M$为标准杨表
  
  - 对称矩阵
  
    - 一些定义：矩阵$M_{W \times H}$，行和$r_i$，列和$c_j$，$X_M$为其所构序列对，$P_M=P_{X_M}$，同理定义$Q_M$，$X_M^{-1}=X_{M^T}$
    - 一一对应：$M$和一对形状相同的半标准杨表$P_M$和$Q_M$一一对应，$P_M$中$i$出现$c_i$次，$Q_M$中$i$出现$r_i$次；特别的，$M$为对称矩阵，与半标准杨表$P_M$一一对应，$P_M$中$i$出现$r_i$次，且$X_M^{-1}=X_M$，$P_M=Q_M$
    - 对称矩阵$M$的迹$tr(M)=\sum_{i=1}^nM_{ii}$等于$P_M$中长度为奇数的列数
  
  - 对合排列(*involution permutation*)
  
    - 定义：对合排列$X=X^{-1}$，即$X$的圈结构中，圈长非$1$即$2$；对应着每行每列只有一个$1$的$01$对称矩阵
    - 性质：其自环个数等于其所对应的标准杨表中奇数长度的列的个数
    - 对合数：$a_0=a_1=1,a_n=(n-1)a_{n-2}+a_{n-1}$
    - 简单扩展：$n \times n$的数值$\in [0,k]$的对称矩阵，满足任两个正数不在同行同列，即每行每列最多一个正数的方案数；先转化为每行每列严格一个正数的方案数，再用组合数加权求和即可；$a_n=k((n-1)a_{n-2}+a_{n-1})$；若对多个$k$进行回答，考虑求出$n$个点的以圈个数为指标的生成函数$p_n(x)=\sum_{t=1}^{+\infin}b_tx^t$，$p_n(k)$即为答案，故考虑多项式多点求值即可
  
- 杨表与最长上升/下降子序列

  - 基本结论：$X$为一个排列
    
    - $P_X$第一行长度为$len(LIS_X)$，第一列长度为$len(LDS_X)$
    
  - 最长$k-LIS$子序列
  
    - 定义：$len(LIS) \le k$的子序列为$k-LIS$子序列，该子序列可被拆分为$\le k$个下降子序列
    - 结论：排列$X$的最长$k-LIS$子序列长度等于杨表$P_X$的前$k$列长度之和
    - 例题：$CTSC2017$最长上升子序列，询问$Q$次排列前缀的最长$k-LIS$子序列长度($k$变化)，杨氏矩阵+分块；每次询问等价于求前$k$列长度之和；只维护杨表前$\sqrt{n}$行和$\sqrt{n}$列，若$k \le \sqrt{n}$，则直接在维护范围内，若$k > \sqrt{n}$，则答案为前$\sqrt{n}$列长度之和$+$前$\sqrt{n}$行长度的部分和；前$\sqrt{n}$列，通过插入相反数序列维护杨图(形状)，这是因为一个前缀倒序行插入得到的杨图与此前缀相反数序列行插入得到的杨图是相同的；复杂度$O(n\sqrt{n}logn)$
  
  - $LIS$计数
  
    - 结论
  
      - 长度为$n$的$LIS$长度为$\alpha$，且$LDS$长度为$\beta$的排列个数为：
        $$
        \large num(n,\alpha,\beta)=\sum_{行数为\beta,列数为\alpha,\lambda \vdash n} f_{\lambda}^2
        $$
  
      - 权值范围为$[1,n]$，各权值数量分布为$\mu$，即：$\sum_{i=1}^n\mu[i]=n$；令$g_{\lambda/\mu}$表示形状为$\lambda$且权值分布为$\mu$的**半标准**杨表数量；则这样的长度为$n$的序列中，最长**非严格**上升子序列长度为$\alpha$且最长**严格**下降子序列长度为$\beta$的序列数量为：
        $$
        \large num(n,\alpha,\beta)=\sum_{行数为\beta,列数为\alpha,\lambda \vdash n,\mu}g_{\lambda/\mu}f_{\lambda}
        $$
  
    - 例题：$BJWC2018$最长上升子序列
  
      - 题目：长度为$n$的随机排列$X$，求$E(len(LIS_X)$
      - 分析：枚举$n$的所有降序拆分$\lambda$，用钩子公式$O(n^2)$计算$f_{\lambda}$，$ans=\sum_{\lambda} \lambda_1f_{\lambda}^2$，复杂度$O(n^2p(n))$，可轻松做到$n \le 63$
  
- 杨表与钩子公式

  - 钩子函数：$h_{\lambda}(i,j)$表示在形状为$\lambda$的杨图中$(i,j)$右侧和下侧以及自己所确定的一块钩子区域的格子数量

  - 标准杨表钩子公式：
    $$
    \large f_{\lambda}=\frac{n !}{\prod h_{\lambda}(i, j)} \\
    \large f_{\lambda}= n ! \frac{\prod_{1 \leq j<k \leq m}\left((\lambda_{j}-j)-(\lambda_{k}-k\right))}{\prod_{i=1}^{m}\left(\lambda_{i}+m-i\right) !}
    $$
    注：上面的公式更便于理解和记忆，下面的公式更便于计算和实现，时间复杂度为$O(m^2)$

- 杨图随机游走

  - 定义：从杨图上某个格子出发，随机向右边或下边走一格，直到走到边角停止

  - 等概率随机游走，$\lambda=(\lambda_1,\lambda_2,\cdots,\lambda_m)$
    $$
    \large p(\space(1,1) \to 边角(r,s)\space)=\frac{1}{n} \prod_{i=1}^{r-1} \frac{h_{\lambda}(i, s)}{h_{\lambda}(i, s)-1} \prod_{j=1}^{s-1} \frac{h_{\lambda}(r, j)}{h_{\lambda}(r, j)-1}
    $$

  - 带权随机游走，$\lambda_i'=|\{j|\lambda_j \ge i\}|$，$x_i,y_i$为每列/每行的权重，$(i,j)$这个格子有权值$x_j$走到右边一列，有权值$y_i$走到下面一行，概率为权值占比(当前选择的权值除以总的可以选择的权值和)
    $$
    \large p(\space(1,1) \to 边角(r,s)\space)= \\
    \frac{x_{r} y_{s}}{\sum_{(p, q) \epsilon[\lambda]}} \prod_{i=1}^{r-1}\left(1+\frac{x_{i}}{x_{i+1}+\cdots+x_{r}+y_{s+1}+\cdots+y_{\lambda_{i}}}\right) \\
    \times \prod_{j=1}^{s-1}\left(1+\frac{y_{j}}{x_{r+1}+\cdots+x_{\lambda_{j}'}+y_{j+1}+\cdots+y_{s}}\right)
    $$

- 杨表与网格图路径

  - 卡特兰数相关

    - $2 \times n$的标准杨表个数为卡特兰数：$C_n=\binom{2n}{n}/(n+1)$

    - 分析方法：对每一维坐标，记录为杨表的一行，$x_{ij}$表示$i$这一维坐标，第一次到达$j$的时刻；考虑一条合法的路径，每个时刻会且仅会使得一维坐标达到新的值，当走到终点$(a_1,a_2,\cdots,a_m)$时，每维均取到了终点坐标的上界，因此我们得到的是一个$m$行，$\lambda=\overrightarrow{a}$的标准杨表；考虑杨表的限制，每列递增，表示不同维到达同一个值的时刻偏序关系，对应到路径中任何时刻走到的点的坐标应该满足逐维递减；例如卡特兰数要求路径每点横坐标不小于纵坐标，即不穿过对角线

    - 例题：$LOJ6051$PATH

      - 题目：$m$维空间，从原点出发，到达$\overrightarrow{a}$，每次某一维坐标增加$1$，问随机路径中能够保持坐标逐维不升的概率，保证$\overrightarrow{a}$满足此性质；即求***高维卡特兰数***

      - 分析：令$r_i=\lambda_i+m-i$，$n=\sum_{i=1}^ma_i$，由钩子公式：
        $$
        \large ans=\frac{\frac{n !}{\prod_{i=1}^{m} r_{i} !} \prod_{1 \leq j<k \leq m}\left(r_{j}-r_{k}\right)}{\frac{n !}{\prod_{i=1}^{m} a_{i} !}}=\left(\prod_{i=1}^{m} \frac{a_{i} !}{r_{i} !}\right) \prod_{1 \leq j<k \leq m}\left(r_{j}-r_{k}\right)
        $$
        注：最右边的公式可以用$ntt$优化到$mlogm$，这是一个差卷积，考虑求出符号，将$<$去掉

  - 不交叉网格路径

    - [Lindström–Gessel–Viennot lemma](https://en.wikipedia.org/wiki/Robinson%E2%80%93Schensted_correspondence)($LGVL$)

      该定理是说：边带权$DAG$中有两个点集$A,B,|A|=|B|=n$，我们枚举$A \to B$的$n!$个对应关系，对每种对应关系(一个排列$\sigma$)，对每对对应点，枚举一条有向路径，且这$n$条路径不交，令$\omega(P)$表示路径边权之积，则累乘$n$条不交路径的权，最后叠加到答案中(正负取决于$\sigma$逆序对)，该答案等于下面矩阵的行列式的值
      $$
      M=\left(\begin{array}{cccc}{e\left(a_{1}, b_{1}\right)} & {e\left(a_{1}, b_{2}\right)} & {\cdots} & {e\left(a_{1}, b_{n}\right)} \\ {e\left(a_{2}, b_{1}\right)} & {e\left(a_{2}, b_{2}\right)} & {\cdots} & {e\left(a_{2}, b_{n}\right)} \\ {\vdots} & {\vdots} & {\ddots} & {\vdots} \\ {e\left(a_{n}, b_{1}\right)} & {e\left(a_{n}, b_{2}\right)} & {\cdots} & {e\left(a_{n}, b_{n}\right)}\end{array}\right)
      $$

      $$
      \operatorname{det}(M)=\sum_{\left(P_{1}, \ldots, P_{n}\right) : A \rightarrow B} \operatorname{sign}(\sigma(P)) \prod_{i=1}^{n} \omega\left(P_{i}\right)
      $$

      其中$e(a,b)=\sum_{P:a \to b}\omega(P)$，即所有$a\to b$的有向路径权值积的和

      特别的，若图的边权均为$1$，则该行列式的值即为$A \to B$的不交路径元祖计数

      注意上述的乘法，可以换成一些可重载的运算，如字符串的连接操作等

      参考阅读：[1](https://graphicallinearalgebra.net/2017/07/31/determinants-and-the-lindstrom-gessel-vienot-lemma/) [文献](https://kam.mff.cuni.cz/~ashutosh/lectures/Presentation_Diptapriyo.pdf)

    - $LGVL$用于网格图

      - 如果是网格图，只允许向右向上走，不过是特殊化的$DAG$，带入$e(x,y)$即可
      - 由于在此意义下，所枚举到的排列$\sigma$，只有一种是合法的，因此适当排序之后，上述行列式值直接等于$A_i \to B_i$所构成的$n$元组路径方案；形式化的，我们要求$A,B$中点横坐标不升，纵坐标不降

    - 一一对应

      - 权值$\in [1,n]$且$m$行($n=\sum_{i=1}^m\lambda_i$)的半标准杨表与$A=\{(-i,1)\},B=\{(\lambda_i-i,n)\},i \in [1,m]$的$m$条不交路径元组一一对应；构造方法：每条路径对应杨表一行，该路径每右行一步，记录其行号

        ![杨表_不交路径1](\pic\数学\杨表_不交路径1.PNG)

      - 权值$\in [1,n]$且$m$行($n=\sum_{i=1}^m\lambda_i$)的半标准斜杨表$\lambda/\mu$与$A=\{(\mu_i-i,1)\},B=\{(\lambda_i-i,n)\},i \in [1,m]$的$m$条不交路径元组一一对应(图表右移了两格)
      
        ![杨表_不交路径2](\pic\数学\杨表_不交路径2.PNG)
    
  - 行列式公式
  
    - 标准斜杨表数量公式：$|\lambda|=m$为行数
      $$
      f_{\lambda / \mu}=\left(\sum_{i} \lambda_{i}-\mu_{i}\right) !\left|\frac{1}{\left(\lambda_{i}-i-\mu_{j}+j\right) !}\right|_{i, j=1}^{|\lambda|}
      $$
  
      - 注：负数的阶乘倒数定义为$0$
  
    - 标准杨表数量公式
      $$
      f_{\lambda}=\left.\left(\sum_{i} \lambda_{i}\right) !\left|\frac{1}{\left(\lambda_{i}+j-i\right) !}\right|\right|_{i, j=1} ^{|\lambda|}
      $$
  
    - 欧拉数：长度为$2n$的波形排列计数
      $$
      (2 n) ! \operatorname{det}\left(\frac{1}{(2 j-2 i+2) !}\right)_{i, j=1}^{n}
      $$
  
      - 思路：构造一个斜杨表$(2n-i+2)/(2n-i),i \in [1,m]$，填好数之后从下而上，从左向右取数构造排列
  
  -  [Hankel 矩阵](https://en.wikipedia.org/wiki/Hankel_matrix)
  
    - 定义：$Hankel$矩阵每条副对角线值相等，由序列$a$生成的矩阵如下：
      $$
      A=\left[\begin{array}{ccccc}{a_{0}} & {a_{1}} & {a_{2}} & {\dots} & {\dots} & {a_{n-1}} \\ {a_{1}} & {a_{2}} & {} & {} & {} & {\vdots} \\ {a_{2}} & {} & {} & {} & {} & {\vdots} \\ {\vdots} & {} & {} & {} &  {} &{a_{2 n-4}} \\ 
      {\vdots} & {} & {} & {} & {a_{2 n-4}} & {a_{2 n-3}} \\ {a_{n-1}} & {\cdots} & {\cdots} & {a_{2 n-4}} & {a_{2 n-3}} & {a_{2 n-2}}\end{array}\right]
      $$
  
    - $Hankel$变换：由$b$序列变换为$h$序列
      $$
      h_{n}=\operatorname{det}\left(b_{i+j-2}\right)_{1 \leq i, j \leq n+1} \\
      令c_{n}=\sum_{k=0}^{n}\left(\begin{array}{l}{n} \\ {k}\end{array}\right) b_{k}\\
      则有：\operatorname{det}\left(b_{i+j-2}\right)_{1 \leq i, j \leq n+1}=\operatorname{det}\left(c_{i+j-2}\right)_{1 \leq i, j \leq n+1} \\
      即h在原序列二项式变换下，保持不变
      $$
  
    - 相关定理
  
      - $$
        \operatorname{det}\left(\left(X_{i}+A_{n-1}\right) \cdots\left(X_{i}+A_{j+1}\right)\left(X_{i}+B_{j}\right) \cdots\left(X_{i}+B_{1}\right)\right)_{i, j=0}^{n-1}\\
        =\prod_{0 \leq i<j \leq n-1}\left(X_{i}-X_{j}\right) \prod_{1 \leq i \leq j \leq n-1}\left(B_{i}-A_{j}\right)
        $$
  
      - $$
        \operatorname{det}\left(C_{\alpha_{i}+j}\right)_{i, j=0}^{n-1}=\prod_{0 \leq i<j \leq n-1}\left(\alpha_{j}-\alpha_{i}\right) \prod_{i=0}^{n-1} \frac{(i+n) !\left(2 \alpha_{i}\right) !}{(2 i) ! \alpha_{i} !\left(\alpha_{i}+n\right) !}
        $$
  
  - $k-Dyck \space Path$
  
    - $Dyck \space Path$是说一条从$(0,0)$到$(2n,0)$的一条路径，每次横坐标增加$1$，纵坐标增加$1$或$-1$，且不越过$x$轴；其路径计数等价于$n$对括号的括号序列计数，即卡特兰数$C_n$
    
    - $k-Dyck \space Path$是说有$k$条这样的路径，第一条不越过$x$轴，第$i$条不越过即不低于第$i-1$条路径
    
    - 一一对应：列数不超过$2k$的，元素$\in [1,n]$内的且**每行长度为偶数**的**半标准杨表**和长度均为$2n+2$的$k-Dyck \space Path$构成一一对应；若将其旋转一下，可转化为从$(0,0)$到$(n+1,n+1)$的$k$条路径，每次只可以向右向上走一步，不能越过上一条路径，第一条不低于$y=x$
    
    - 计数公式
      $$
      \large b_{n,k}=\prod_{1 \le i \le j \le n} \frac{2k+i+j}{i+j}
      $$
    
    - 下三角矩阵的$LDS$
    
      - 下三角矩阵$M$的$LDS$定义为权值和最大的路径，可选一个起点，然后每次走向右上方的某个格子，或者同行的右侧的某个格子，注意不要求权值递增
    
      - $LDS(M) \le k$的下三角矩阵$M$与$k-Dyck \space Path$一一对应
    
      - 元素$\in[1,n]$，每行长度为偶数，半标准杨表和$n \times n$的对称矩阵$M'$一一对应，杨表列数$=LDS(M')$；$LDS(M') \le 2k$的对称矩阵$M'$和满足$LDS(M) \le k$的下三角矩阵$M$一一对应。
    
      - 元素$\in[1,n]$，列数$\le k$半标准杨表与$n \times n$元素$\in[0,k]$满足每行每列均非严格递增的**对称矩阵**数量相等
        $$
        \large a_{n,k}=\prod_{1 \le i \le j \le n} \frac{k+i+j-1}{i+j-1}
        $$
  
- 半标准杨表计数

  - 元素$\in[1,n]$，半标准杨表$ \lambda = (\lambda_1,\cdots,\lambda_m),n=\sum_{i=1}^m\lambda_i$的计数公式
    $$
    \large \prod_{(i,j) \in \lambda} \frac{n+j-i}{h_\lambda(i,j)}=\prod_{1 \le i < j \le n} \frac{\lambda_i-\lambda_j+j-i}{j-i}
    $$

  - 例题：$CodeChef \space BillBoards(BB) $  [Billboards ](https://www.codechef.com/problems/BB)  

- 形状带限制的杨表计数

  - 列数$\le k$，即$LIS \le k$的排列计数(注意不是杨表计数)

    - 定义
      $$
      \begin{aligned} u_{k}(n) &=\sum_{\lambda \vdash n, \lambda_{1} \leq k} f_{\lambda}^{2} \\ U_{k}(x) &=\sum_{n \geq 0} u_{k}(n) \frac{x^{2 n}}{n !^{2}} \\ I_{i}(2 x) &=\sum_{n \geq 0} \frac{x^{2 n+i}}{n !(n+i) !} \end{aligned} \\
      其中I_k(2x)=I_{-k}(2x)表示第一类修正贝塞尔函数，有许多性质
      $$

    - 定理
      $$
      \large U_{k}(x)=\operatorname{det}\left(I_{i-j}(2 x)\right)_{i, j=1}^{K} \\
      \begin{aligned} U_{2}(x) &=\left|\begin{array}{cc}{I_{0}(2 x)} & {I_{1}(2 x)} \\ {I_{1}(2 x)} & {I_{0}(2 x)}\end{array}\right|=I_{0}(2 x)^{2}-I_{1}(2 x)^{2} \\ \Rightarrow u_{2}(n) &=\frac{1}{n+1}\left(\begin{array}{c}{2 n} \\ {n}\end{array}\right) \end{aligned} \\
      u_{3}(n)=\frac{1}{(n+1)^{2}(n+2)} \sum_{j=0}^{n}\left(\begin{array}{c}{2 j} \\ {j}\end{array}\right)\left(\begin{array}{l}{n+1} \\ {j+1}\end{array}\right)\left(\begin{array}{l}{n+2} \\ {j+2}\end{array}\right) \\
      (n+4)(n+3)^{2} u_{4}(n)=\left(20 n^{3}+62 n^{2}+22 n-24\right) u_{4}(n-1)-64 n(n-1)^{2} u_{4}(n-2) \\
    (n+6)^{2}(n+4)^{2} u_{5}(n)=\left(375-400 n-843 n^{2}-322 n^{3}-35 n^{4}\right) u_{5}(n-1) \\ 
      +\left(259 n^{2}+622 n+45\right)(n-1)^{2} u_{5}(n-2) \\ 
    -225(n-1)^{2}(n-2)^{2} u_{5}(n-3)
      $$
  
  - 行数$\le k$
  
  - 定义
      $$
      y_{k}(n)=\sum_{\lambda \vdash n, \lambda_{1} \leq k} f_{\lambda}
      $$
  
    - 定理
      $$
      \begin{aligned} y_{2}(n) &=\left(\begin{array}{c}{n} \\ {\lfloor n / 2\rfloor}\end{array}\right) \\ y_{3}(n) &=\sum_{i=0}^{\lfloor n / 2\rfloor}\left(\begin{array}{c}{n} \\ {2 i}\end{array}\right) C_{i} \\ y_{4}(n) &=C_{\lfloor(n+1) / 2 \rfloor} C_{\lceil(n+1) / 2\rceil} \\ y_{5}(n) &=6 \sum_{i=0}^{\lfloor n / 2\rfloor}\left(\begin{array}{c}{n} \\ {2 i}\end{array}\right) C_{i} \frac{(2 i+2) !}{(i+2) !(i+3) !} \end{aligned}
      $$





【119】代数：抽象代数基础

- 代数结构基础

  - 二元运算的性质：交换律，结合律，幂等律，分配率，吸收率，消去律
  - 特殊元素：幂等元，单位元，零元，逆元
  - 单位元与零元存在唯一性定理
  - 代数系统定义：**代数系统** ![[公式]](https://www.zhihu.com/equation?tex=V%3D%3CA%2C%5COmega%2CK%3E) **，其中** ![[公式]](https://www.zhihu.com/equation?tex=A) **为非空集合，称为载体；** ![[公式]](https://www.zhihu.com/equation?tex=%5COmega) **为所有** ![[公式]](https://www.zhihu.com/equation?tex=1%2C2%2C...) **元运算的集合；** ![[公式]](https://www.zhihu.com/equation?tex=K) **为代数常数集合（** ![[公式]](https://www.zhihu.com/equation?tex=0) **元运算）。**
  - 同类型代数系统
  - 子代数：平凡与非平凡
  - 积代数与因子代数：**积代数不保持消去律**
  - 同余关系与置换性质
  - 商代数：**不保持消去律**
    - 等价关系与集合划分
  - 同态与同构
    - 单同态，满同态，自同态，自同构，自然同态
    - 同态像：**不保持消去律**
    - 同余关系与同态的相互诱导
    - **同态基本定理**

- 群

  - 半群与独异点及其子代数

  - 群定义，子群

    - 子群判定定理：

      - **![[公式]](https://www.zhihu.com/equation?tex=G) 为群， ![[公式]](https://www.zhihu.com/equation?tex=H%5Cleq+G) 当且仅当 ![[公式]](https://www.zhihu.com/equation?tex=%5Cforall+a%2Cb%5Cin+H) 有**![[公式]](https://www.zhihu.com/equation?tex=ab%5E%7B-1%7D%5Cin+H)**。**
      - ![[公式]](https://www.zhihu.com/equation?tex=G) **为群，** ![[公式]](https://www.zhihu.com/equation?tex=H%5Csubset+G) **，则**![[公式]](https://www.zhihu.com/equation?tex=H%5Cleq+G) **成立当且仅当** ![[公式]](https://www.zhihu.com/equation?tex=HH%5E%7B-1%7D%5Csubset+H) **。**

    - 子群生成方式：**![[公式]](https://www.zhihu.com/equation?tex=G) 为群， ![[公式]](https://www.zhihu.com/equation?tex=a%5Cin+G%2CB%5Csubset+G)**

      **则 ![[公式]](https://www.zhihu.com/equation?tex=%3Ca%3E%3D+%5Cleft+%5C%7B++a%5Ek%7Ck%5Cin+%5Cmathbb%7BZ%7D%5Cright+%5C%7D) 称为由元素 ![[公式]](https://www.zhihu.com/equation?tex=a) 生成的子群。**

      **![[公式]](https://www.zhihu.com/equation?tex=%3CB%3E%3D%5Cleft+%5C%7B++b_1%5E%7Be_1%7Db_2%5E%7Be_2%7D...b_n%5E%7Be_n%7D%7Cb_i%5Cin+B%2Ce_i%3D%5Cpm+1%5Cright+%5C%7D) 称为由子集 ![[公式]](https://www.zhihu.com/equation?tex=B) 生成的子群。**

    - 子群结构

      - 同一个群的两个子群的交必定为子群，但是并不一定
      - ![[公式]](https://www.zhihu.com/equation?tex=G%3D%3Ca%3E) 为 ![[公式]](https://www.zhihu.com/equation?tex=n) 阶循环群，则 ![[公式]](https://www.zhihu.com/equation?tex=G) 子群的阶整除 ![[公式]](https://www.zhihu.com/equation?tex=n) 。且对 ![[公式]](https://www.zhihu.com/equation?tex=n) 的每个因子 ![[公式]](https://www.zhihu.com/equation?tex=d) ，存在 ![[公式]](https://www.zhihu.com/equation?tex=G) 的一个 ![[公式]](https://www.zhihu.com/equation?tex=d) 阶子群与之一一对应。（**![[公式]](https://www.zhihu.com/equation?tex=G) 的所有子群个数为 ![[公式]](https://www.zhihu.com/equation?tex=%5Ctau%28n%29)** ）

    - 群的中心

    - 共轭子群

  - 循环群

    - 群的阶与元素的阶
      - 一个推论： ![[公式]](https://www.zhihu.com/equation?tex=G%3D%3Ca%3E) 为 ![[公式]](https://www.zhihu.com/equation?tex=n) 阶循环群，若 ![[公式]](https://www.zhihu.com/equation?tex=%7Ca%5Er%7C%3Dd) ，则 ![[公式]](https://www.zhihu.com/equation?tex=d%3D%5Cfrac%7Bn%7D%7B%28n%2Cr%29%7D) 。
      - 一个推论：**![[公式]](https://www.zhihu.com/equation?tex=G) 为群， ![[公式]](https://www.zhihu.com/equation?tex=a%2Cb%5Cin+G%2Cab%3Dba%2Ca%5Cneq+b) ， ![[公式]](https://www.zhihu.com/equation?tex=%7Ca%7C%3Dn%2C%7Cb%7C%3Dm%2C%28n%2Cm%29%3D1) ，则 ![[公式]](https://www.zhihu.com/equation?tex=%7Cab%7C%3Dmn) 。**
      - 偶数阶群中必存在二阶元，奇数阶群中必无二阶元
    - 循环群定义：**![[公式]](https://www.zhihu.com/equation?tex=G) 为群，若 ![[公式]](https://www.zhihu.com/equation?tex=%5Cexists+a%5Cin+G%2CG%3D%5Cleft+%5C%7B++a%5Ek%7Ck%5Cin+%5Cmathbb%7BZ%7D%5Cright+%5C%7D) ，则 ![[公式]](https://www.zhihu.com/equation?tex=G%3D%3Ca%3E) 为循环群， ![[公式]](https://www.zhihu.com/equation?tex=a) 为 ![[公式]](https://www.zhihu.com/equation?tex=G) 的生成元。**
    - 生成元结构
      - **对于无限阶循环群 ![[公式]](https://www.zhihu.com/equation?tex=G%3D%3Ca%3E) ，生成元只有 ![[公式]](https://www.zhihu.com/equation?tex=a%2Ca%5E%7B-1%7D) 两个。**
      - **对于 ![[公式]](https://www.zhihu.com/equation?tex=n) 阶循环群 ![[公式]](https://www.zhihu.com/equation?tex=G%3D%3Ca%3E)，共有 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvarphi%28n%29) 个生成元。对于 ![[公式]](https://www.zhihu.com/equation?tex=r%3D1%2C2%2C...%2Cn) ， ![[公式]](https://www.zhihu.com/equation?tex=a%5Er) 为生成元当且仅当 ![[公式]](https://www.zhihu.com/equation?tex=%28n%2Cr%29%3D1) 。**

  - 群同态与同构

    - 如何将同态升级为同构

      - **对于满同态，我们取定义域集合中的部分元素使得 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvarphi) 恰好遍历像集合中所有元素恰好一次就可以将其变为同构**。
      - 先**将像集合缩小为同态像 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvarphi%28G_1%29) 将其变为满同态再按照上述方法改造即可**。

    - 同态性质定理：**同态将一个群的幺元映射为另一个群的幺元，且 ![[公式]](https://www.zhihu.com/equation?tex=%5Cvarphi%28g%5E%7B-1%7D%29%3D%5B%5Cvarphi%28g%29%5D%5E%7B-1%7D) 。**

    - 同态的像与核：

      - **![[公式]](https://www.zhihu.com/equation?tex=Im%5Cvarphi%3D%5Cvarphi%28G_1%29%3D%5Cleft+%5C%7Bg_2%5Cin+G_2%7C%5Cexists+g_1%5Cin+G_1%2Cg_2%3D%5Cvarphi%28g_1%29++%5Cright+%5C%7D) 为同态的像。**
      - **![[公式]](https://www.zhihu.com/equation?tex=Ker%5Cvarphi%3D%5Cleft+%5C%7B++g_1%5Cin+G_1%7C%5Cvarphi%28g_1%29%3De_2%5Cright+%5C%7D) 为同态的核。**
      - 重要性质：![[公式]](https://www.zhihu.com/equation?tex=Ker%5Cvarphi%5Cleq+G_1%2CIm%5Cvarphi+%5Cleq+G_2)
      - 核的意义
        - **![[公式]](https://www.zhihu.com/equation?tex=Ker) 衡量的是一个映射的单性的程度**。
        - **![[公式]](https://www.zhihu.com/equation?tex=%5Cvarphi) 为单的充要条件是 ![[公式]](https://www.zhihu.com/equation?tex=Ker%5Cvarphi%3D%5Cleft+%5C%7B++e_1%5Cright+%5C%7D)**
        - **![[公式]](https://www.zhihu.com/equation?tex=G_1) 中存在 ![[公式]](https://www.zhihu.com/equation?tex=k) 个不同元素的像为幺元，那么对于 ![[公式]](https://www.zhihu.com/equation?tex=G_2) 中存在原像的任意元素，有且仅有 ![[公式]](https://www.zhihu.com/equation?tex=G_1+) 中的 ![[公式]](https://www.zhihu.com/equation?tex=k) 个不同元素为其原像。**
        - **![[公式]](https://www.zhihu.com/equation?tex=Ker%5Cvarphi) 决定了映射到幺元的元素的结构，而映射到幺元的元素的结构与映射到 ![[公式]](https://www.zhihu.com/equation?tex=Im%5Cvarphi) 中的任意一个元素的元素的结构是相同的**

    - 陪集

      - 定义：**![[公式]](https://www.zhihu.com/equation?tex=G) 为群， ![[公式]](https://www.zhihu.com/equation?tex=H%5Cleq+G%2C%5C+%5Cforall+g%5Cin+G%2C%5C+gH) 称为 ![[公式]](https://www.zhihu.com/equation?tex=H) 在 ![[公式]](https://www.zhihu.com/equation?tex=G) 中的一个左陪集， ![[公式]](https://www.zhihu.com/equation?tex=Hg) 称为 ![[公式]](https://www.zhihu.com/equation?tex=H) 在 ![[公式]](https://www.zhihu.com/equation?tex=G)中的一个右陪集。**

      - 本质：**左陪集 ![[公式]](https://www.zhihu.com/equation?tex=gH) 本质上为一个等价关系 ![[公式]](https://www.zhihu.com/equation?tex=R) 诱导出的等价类。**

        **![[公式]](https://www.zhihu.com/equation?tex=R) 如下定义： ![[公式]](https://www.zhihu.com/equation?tex=%5Cforall+a%2Cb%5Cin+G%2C%5C+aRb) 当且仅当 ![[公式]](https://www.zhihu.com/equation?tex=a%5E%7B-1%7Db%5Cin+H) 。**

      - 性质：**![[公式]](https://www.zhihu.com/equation?tex=%5Cforall+a%2Cb%5Cin+G%2C)** **![[公式]](https://www.zhihu.com/equation?tex=aH) 与 ![[公式]](https://www.zhihu.com/equation?tex=bH) 要么不交要么相等，且 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbigcup_%7Ba%5Cin+G%7DaH%3DG) 。**

      - Lagrange定理

        - **若 ![[公式]](https://www.zhihu.com/equation?tex=%7CG%3AH%7C) 表示在 ![[公式]](https://www.zhihu.com/equation?tex=G) 中 ![[公式]](https://www.zhihu.com/equation?tex=H) 的左陪集数，则： ![[公式]](https://www.zhihu.com/equation?tex=%7CG%7C%3D%7CH%7C%5C+%7CG%3AH%7C) 。**

      - ![[公式]](https://www.zhihu.com/equation?tex=A%5Cleq+G%2CB%5Cleq+G) ，若存在 ![[公式]](https://www.zhihu.com/equation?tex=g%2Ch%5Cin+G%2CgA%3DhB) ，则： ![[公式]](https://www.zhihu.com/equation?tex=A%3DB)，即不同的子群不可能有相同的陪集

    - 共轭

      - 共轭映射： ![[公式]](https://www.zhihu.com/equation?tex=%5Cforall+g%5Cin+G%2C%5C+%5Cvarphi_g%3AG%5Crightarrow+G%2C%5C+%5Cforall+a%5Cin+G%2C%5C+%5Cvarphi_g%28a%29%3Dg%5E%7B-1%7Dag) 。
      - 等价关系：共轭关系实际上也是一个等价关系，**![[公式]](https://www.zhihu.com/equation?tex=aRb) 当且仅当 ![[公式]](https://www.zhihu.com/equation?tex=%5Cexists+g%5Cin+G%2Ca%3Dg%5E%7B-1%7Dbg) 。**

    - 群的分类方程：**![[公式]](https://www.zhihu.com/equation?tex=%7CG%7C%3D%7CC%7C%2B%5Csum_%7Bi%3D1%7D%5Ek%7CG%3AN%28a_i%29%7C) ，其中 ![[公式]](https://www.zhihu.com/equation?tex=C) 为群的中心， ![[公式]](https://www.zhihu.com/equation?tex=a_i)为所含元素个数不少于 ![[公式]](https://www.zhihu.com/equation?tex=2) 的共轭类的任意代表元。**

  - 正规子群

    - 定义与性质
      - **![[公式]](https://www.zhihu.com/equation?tex=H) 为 ![[公式]](https://www.zhihu.com/equation?tex=G) 的正规子群当且仅当对于任意的 ![[公式]](https://www.zhihu.com/equation?tex=g%5Cin+G) ，![[公式]](https://www.zhihu.com/equation?tex=gH%3DHg) ，记为** ![[公式]](https://www.zhihu.com/equation?tex=H%5Cunlhd+G) 。
      - **![[公式]](https://www.zhihu.com/equation?tex=%5Cforall+g%5Cin+G%2Cg%5E%7B-1%7DHg%3DH)**
      - **![[公式]](https://www.zhihu.com/equation?tex=%5Cforall+g%5Cin+G%2C%5Cforall+h%5Cin+H%2Cg%5E%7B-1%7Dhg%5Cin+H)**
      - 所有共轭子群都等于自身的子群是正规的
      - 正规子群中任意元素所在共轭类必定包含于正规子群中。即：正规子群必定为若干个共轭类之并，关于共轭运算是封闭的。
    - 判定
      - **如果** ![[公式]](https://www.zhihu.com/equation?tex=H%5Cleq+G%2C%7CG%3AH%7C%3D2) **，则** ![[公式]](https://www.zhihu.com/equation?tex=H%5Cunlhd+G) 。
      - **如果 ![[公式]](https://www.zhihu.com/equation?tex=H%5Cleq+G%2C%7CH%7C%3Dn) ，且![[公式]](https://www.zhihu.com/equation?tex=H) 是 ![[公式]](https://www.zhihu.com/equation?tex=G) 的唯一的 ![[公式]](https://www.zhihu.com/equation?tex=n) 阶子群，则 ![[公式]](https://www.zhihu.com/equation?tex=H%5Cunlhd+G)** 。
    - 单群：如果一个群只含有平凡的正规子群，其被称为单群。

  - 商群

    - **![[公式]](https://www.zhihu.com/equation?tex=H%5Cunlhd+G) ， ![[公式]](https://www.zhihu.com/equation?tex=G%2FH%3D%5Cleft+%5C%7BgH%7Cg%5Cin+G++%5Cright+%5C%7D) ，且定义运算： ![[公式]](https://www.zhihu.com/equation?tex=aH%5C+bH%3DabH) ，则构成商群 ![[公式]](https://www.zhihu.com/equation?tex=G%2FH) 。**
    -  ![[公式]](https://www.zhihu.com/equation?tex=%7CG%2FH%7C%3D%7CG%3AH%7C%3D%5Cfrac%7B%7CG%7C%7D%7B%7CH%7C%7D)

  - 同态基本定理：**![[公式]](https://www.zhihu.com/equation?tex=%5Cvarphi%3AG_1%5Crightarrow+G_2) 为同态，则 ![[公式]](https://www.zhihu.com/equation?tex=G_1%2FKer%5Cvarphi+%5Ccong+Im%5Cvarphi) 。**

  - 换位子群

    - **![[公式]](https://www.zhihu.com/equation?tex=%5Cforall+a%2Cb%5Cin+G%2C%5Ba%2Cb%5D%3Daba%5E%7B-1%7Db%5E%7B-1%7D) 称为 ![[公式]](https://www.zhihu.com/equation?tex=a) 与 ![[公式]](https://www.zhihu.com/equation?tex=b) 的换位子。**

    - **由 ![[公式]](https://www.zhihu.com/equation?tex=G) 的所有换位子生成的子群被称为 ![[公式]](https://www.zhihu.com/equation?tex=G) 的换位子群（导群），记为** ![[公式]](https://www.zhihu.com/equation?tex=G%5E%7B%27%7D) 。

    - 换位子群是对于群 ![[公式]](https://www.zhihu.com/equation?tex=G) 的**非交换性的一种度量**。

    - **![[公式]](https://www.zhihu.com/equation?tex=G%5E%7B%27%7D%5Cunlhd+G) ，且 ![[公式]](https://www.zhihu.com/equation?tex=G%2FG%5E%7B%27%7D) 为Abel群。**

    - **换位子群事实上是为了使得商群可交换所需要模去的最小的子群**。

    - **递归地定义 ![[公式]](https://www.zhihu.com/equation?tex=G) 的 ![[公式]](https://www.zhihu.com/equation?tex=n) 级导群 ![[公式]](https://www.zhihu.com/equation?tex=G%5E%7B%28n%29%7D%3D%28G%5E%7B%28n-1%29%7D%29%5E%7B%27%7D)**

      **若存在正整数 ![[公式]](https://www.zhihu.com/equation?tex=n) 使得 ![[公式]](https://www.zhihu.com/equation?tex=G%5E%7B%28n%29%7D%3D%5Cleft+%5C%7Be++%5Cright+%5C%7D) ，则 ![[公式]](https://www.zhihu.com/equation?tex=G) 为可解群。**

  - 同构定理

    - 第一同构定理：**![[公式]](https://www.zhihu.com/equation?tex=G) 为群， ![[公式]](https://www.zhihu.com/equation?tex=H+%5Cunlhd+G%2CK+%5Cunlhd+G%2CH%5Csubset+K) ，则 ![[公式]](https://www.zhihu.com/equation?tex=G%2FK%5Ccong+%28G%2FH%29%2F%28K%2FH%29) 。**
    - 第二同构定理：**![[公式]](https://www.zhihu.com/equation?tex=H+%5Cunlhd+G%2CK+%5Cleq+G) ，则 ![[公式]](https://www.zhihu.com/equation?tex=HK%2FH%5Ccong+K%2F%28H%5Ccap+K%29) 。**
    - 推论：
      -  ![[公式]](https://www.zhihu.com/equation?tex=%7CG%3AK%7C%3D%5Cfrac%7B%7CG%3AH%7C%7D%7B%7CK%3AH%7C%7D)
      -  ![[公式]](https://www.zhihu.com/equation?tex=%5Cfrac%7B%7CHK%7C%7D%7B%7CH%7C%7D%3D%5Cfrac%7B%7CK%7C%7D%7B%7CH%5Ccap+K%7C%7D)

  - 置换群
  
    - 置换的轮换分解：**![[公式]](https://www.zhihu.com/equation?tex=S_n) 中任意非幺元元素可以在不计顺序意义下唯一地分解为不交轮换之积。**
    - **将 ![[公式]](https://www.zhihu.com/equation?tex=%5Csigma%5Cin+S_n) 表示为不交轮换之积，令 ![[公式]](https://www.zhihu.com/equation?tex=c_k%28%5Csigma%29) 表示 ![[公式]](https://www.zhihu.com/equation?tex=%5Csigma) 的分解式中的 ![[公式]](https://www.zhihu.com/equation?tex=k) 阶轮换的个数。则 ![[公式]](https://www.zhihu.com/equation?tex=1%5E%7Bc_1%28%5Csigma%29%7D2%5E%7Bc_2%28%5Csigma%29%7D...n%5E%7Bc_n%28%5Csigma%29%7D) 称为其轮换指数。**
    - **任意一个置换的阶数等于其不交轮换分解中所有轮换阶数的最小公倍数**。
    - 共轭类中元素个数公式：有 ![[公式]](https://www.zhihu.com/equation?tex=%5Cfrac%7B%7CS_n%7C%7D%7B%7CN_%7BS_n%7D%28%5Csigma%29%7C%7D%3D%28n-1%29%21) 个元素；**![[公式]](https://www.zhihu.com/equation?tex=%5Csigma) 的共轭类中元素的个数就是 ![[公式]](https://www.zhihu.com/equation?tex=n) 个不同物体的环排列数**。
    - **对于 ![[公式]](https://www.zhihu.com/equation?tex=pq) 阶元素， ![[公式]](https://www.zhihu.com/equation?tex=p%2Cq) 为不同的素数，其在 ![[公式]](https://www.zhihu.com/equation?tex=S_n) 中存在的必要条件是 ![[公式]](https://www.zhihu.com/equation?tex=n%5Cgeq+p%2Bq)**
    -  **![[公式]](https://www.zhihu.com/equation?tex=S_n) 中任意两个元素共轭当且仅当他们拥有相同轮换指数**
    - **Cayley**定理：**任意一个群同构于某一个集合上的置换群。**
    - **所有 ![[公式]](https://www.zhihu.com/equation?tex=4) 阶群在同构意义下只有两种结构：要么为循环群，要么为Klein四元群**。
  
- 格

  - 定义
    - **对于偏序集 ![[公式]](https://www.zhihu.com/equation?tex=%3CL%2C%5Cleq%3E) ，若对于 ![[公式]](https://www.zhihu.com/equation?tex=%5Cforall+x%2Cy%5Cin+L%2C)** **![[公式]](https://www.zhihu.com/equation?tex=%5Cleft+%5C%7B+x%2Cy+%5Cright+%5C%7D) 的最大下界与最小上界都存在，则 ![[公式]](https://www.zhihu.com/equation?tex=%3CL%2C%5Cleq%3E) 构成格，简记为 ![[公式]](https://www.zhihu.com/equation?tex=L) 。**
    - **记 ![[公式]](https://www.zhihu.com/equation?tex=%5Cleft+%5C%7B+x%2Cy+%5Cright+%5C%7D) 的最大下界为 ![[公式]](https://www.zhihu.com/equation?tex=x%5Cwedge+y) ，最小上界为 ![[公式]](https://www.zhihu.com/equation?tex=x%5Cvee+y) 。**
  - 子格
    - **![[公式]](https://www.zhihu.com/equation?tex=S%5Csubset+L) 非空且 ![[公式]](https://www.zhihu.com/equation?tex=S) 关于最大下界与最小上界运算封闭，则 ![[公式]](https://www.zhihu.com/equation?tex=S) 为 ![[公式]](https://www.zhihu.com/equation?tex=L) 的子格。**
  - 格的对偶原理
    - **![[公式]](https://www.zhihu.com/equation?tex=%3CL%2C%5Cleq%3E) 为格， ![[公式]](https://www.zhihu.com/equation?tex=P) 为格中元素以及 ![[公式]](https://www.zhihu.com/equation?tex=%5Cgeq%2C%5Cleq%2C%3D%2C%5Cwedge%2C%5Cvee) 等符号表示的命题。则将其中 ![[公式]](https://www.zhihu.com/equation?tex=%5Cgeq%2C%5Cleq)对换， ![[公式]](https://www.zhihu.com/equation?tex=%5Cwedge%2C%5Cvee) 对换后得到的对偶命题与原命题等价（同时为真/假）**。
  - 格的代数系统定义
    - **![[公式]](https://www.zhihu.com/equation?tex=%3CL%2C%5Cwedge%2C%5Cvee%3E) ，其中 ![[公式]](https://www.zhihu.com/equation?tex=%5Cwedge%2C%5Cvee) 为 ![[公式]](https://www.zhihu.com/equation?tex=L) 上二元运算，满足交换律、结合律、吸收律，则 ![[公式]](https://www.zhihu.com/equation?tex=%3CL%2C%5Cwedge%2C%5Cvee%3E) 为格**。
    - **格的代数系统定义与格的偏序关系定义完全等价**
  - 特殊的格
    - 因子格：任意确定正整数 ![[公式]](https://www.zhihu.com/equation?tex=n) ，设 ![[公式]](https://www.zhihu.com/equation?tex=A_n) 为其所有正因子集合，那么在整除关系下构成格，称为**因子格**
    - 幂集格：任意集合 ![[公式]](https://www.zhihu.com/equation?tex=B) ， ![[公式]](https://www.zhihu.com/equation?tex=P%28B%29) 为其幂集，则 ![[公式]](https://www.zhihu.com/equation?tex=%3CP%28B%29%2C%5Csubset%3E) 构成格，称为 ![[公式]](https://www.zhihu.com/equation?tex=B) 的**幂集格**
    - 子群格： ![[公式]](https://www.zhihu.com/equation?tex=G) 为群， ![[公式]](https://www.zhihu.com/equation?tex=L%28G%29) 为 ![[公式]](https://www.zhihu.com/equation?tex=G) 的所有子群构成的集合，则 ![[公式]](https://www.zhihu.com/equation?tex=%3CL%28G%29%2C%5Csubset%3E) 构成格，称为 ![[公式]](https://www.zhihu.com/equation?tex=G) 的**子群格**
    - 完备格：格中集合任意子集的最小上界和最大下界均存在于格中集合中
    - 其他格：钻石格，五角格
  - 格中运算保序性
    - ![[公式]](https://www.zhihu.com/equation?tex=a%5Cleq+b%2Cc%5Cleq+d) ，则 ![[公式]](https://www.zhihu.com/equation?tex=a%5Cwedge+c%5Cleq+b%5Cwedge+d%2Ca%5Cvee+c%5Cleq+b%5Cvee+d)

  - 







【120】组合：几种基础排序算法的性质

- 排列的冒泡排序：从左到右扫描
  - 每轮会运送一个最值，到序列右端，即前$k$轮结束后，前$k$大元素已经就序了
  - 每轮中考虑某个特定元素$a_i$，其只会最多向左移动$1$，当$a_{i-1}>a_i$时，移动$1$；前$k$轮中，一个元素$x$最多向左移动$k$(更具体的，移动$min(f(i),k)$)
  - 令$f(i)$表示序列中$a_i$之前有多少个元素大于$a_i$，即$f(i)=|\{j<i|a_j>a_i\}|$，注意到一轮排序发生后，对任意$f(i)>0$，$f(i)--$，而$f(i)=0$，则$a_i$会被移动到右边，且$f(i)$保持为$0$；因此，$k$轮过后，$f(i)=max(f(i)-k,0)$；可以理解为，从左到右发洪水，$f(i)>0$的元素是被支配的，有物品挡住了洪水，所以他们不会向右，但是$f(i)=0$元素是自由的，所以会流动
  - 前$k$轮结束之后，至少前$k+1$个元素已经有序了
- 冒泡 k 趟之后，新序列的第 i 项是原序列前 min(i + k, n) 项中未在新序列前 i − 1 项中出现过的最小值。



【121】组合：$Dilworth$定理

应用于偏序集：

链：两两可比的元素集合

反链：两两不可比的元素集合

最小链拆分等于最长反链长度



【122】博弈论：基础知识梳理

- $NP$状态定理

- $sg$函数理论

  - 适用组合游戏特点
    - 二人博弈，双方绝对聪明且利己
    - 游戏在有限步内终止，无法决策方输
    - 游戏状态不能重复抵达，游戏无平局；即游戏图为$DAG$
    - 决策空间只与游戏状态有关，与游戏者无关，即游戏决策是对称的，游戏是信息公开的
  - $sg$函数定义与递推
  - 游戏和与$nim$和

- 普通$Nim$游戏

  - 一步策略：若$n$堆依次为$x_1,x_2,...,x_n$，异或和不为$0$，先手存在必胜策略；下面构造一个方案，令$X=XOR_{i=1}^nx_i$，只需要将某个$x_i$变成$x_i \oplus X<x_i$即可；考虑寻找一个$i \in [1,n]$，满足$x_i$在与$X$对其的最高位为$1$，即满足前述要求

- $Anti-Nim$游戏与$SJ$定理

  - 定义：$nim$游戏中，拿走最后一个石子者输，即决策空间为空者赢
  - 结论：先手必胜当且仅当：
    - 游戏的$sg>0$，且存在单一游戏$sg>1$
    - 游戏的$sg=0$，且所有单一游戏$sg \le 1$

- $Multi-Nim$游戏

  - 定义：可以将一堆石子分成若干堆(可指定或者不指定堆数)，即一个单一游戏的后继可以为多个单一游戏的和
  - 结论：利用经典的$sg$递推即可，不同决策的后继之间用$mex$操作，游戏和用$nim$和

- $Every-Nim$游戏

  - 定义：每一轮游戏，选手必须将每个没有结束的单一游戏，推进一步；必胜则要求最长的步数使得到达胜利状态，必败则要求最短的步数使得到达必败态
  - 令$step[x]$表示状态$x$的步数，满足上述所求
    - 若$v$为终止状态，$step[v]=0$
    - 若$sg[v]>0$，$step[v]=max\{step[u]\}+1$，$sg[u]=0$，$v \to u$
    - 若$sg[v]=0$，$step[v]=min\{step[u]\}+1$，$v \to u$
  - 结论：先手必胜当且仅当单一游戏的最大$step$为奇数

- 阶梯博弈

  - 定义：有一组阶梯编号为$0,1,2,...$；每个阶梯上有一些石子，每次可以选择一个阶梯移动一部分到左边紧靠着的阶梯，不能移动者输；$0$为地面。
  - 结论：等价于只考虑奇数编号的阶梯的$nim$游戏，因为对方将奇数移动到偶数，看成某一堆石子减少，将偶数移动到奇数，则你可以立刻将同样多的石子从奇数移动到偶数，故操作抵消，奇数编号石子数不变。

- $nimk$游戏

  - 定义：$n$堆石子，双方轮流取，每次可以取最多$k$堆，每堆可以取任意个石子(至少$1$个)，无子取者败
  - 结论：将每堆石子数$a_i$转化为二进制数，统计每一位上的$1$个数之和，若每一位的和都是$k+1$的倍数，则先手必败，否则先手必胜

- $Bash$博弈及其扩展

  - 普通$Bash$博弈
    - 定义：每次选择一堆，取走数量$\in [1,m]$
    - 结论：$n$为$m+1$倍数为必败态，否则为必胜态
  - $Bash$博弈扩展
    - 定义：每次选择一堆，取走数量$\in [a,b]$
    - 结论：$n \in [1,a) \cup (b,a+b)$平局，除此之外$n\%(a+b)=0$先手必败，否则先手必胜

- 硬币游戏

  - 定义：按照规则翻一系列硬币，要求满足所翻动的下标最大的硬币必须从正面到反面
  - 基本结论：局面的$sg$值等于局面中正面朝上即$1$单独存在时的单一游戏$sg$值的$nim$和
  - 已知经典游戏：下标从$1$开始
    - 每次翻连续$k$个
      - $sg$值分布为：$00...001$周期为$k$，即$sg(x)=[k|x]$
    - 每次先翻动$x$，然后在$x-1,x-2,x-3$中选择一个翻动
      - $sg$值分布为：$1,2,3,0,1,2,3,0...$，周期是$4$
    - 每次翻动严格$2$个，下标差$\in \{1,2,3\}$，下标从$0$开始
      - $sg$值分布为：$0,1,2,3,0,1,2,3,...$，注意$sg(0)=0$，周期为$4$
    - 每次翻动个数不超过$3$个，下标从$0$开始
      - $sg$值分布为：$sg(x)=2x+!parity(x)$，$parity(x)$表示$x$二进制$1$的个数是否为奇数
    - 每次翻动连续任意多个，至少$1$个，下标从$1$开始(尺子游戏)
      - $sg$值分布为：$sg(x)=lowbit(x)=x\&-x$

- 删边游戏

  - 树上删边游戏

    - 定义：给定$n$个点的有根树，双方轮流删边，移走不与根连通的分支，无法操作者输
    - 结论：叶子节点$sg$值为$0$，非叶节点的$sg$值等于儿子的$sg+1$的异或和
    - 分析：某棵子树$x$可以等效的替换为长度(边数)为$sg(x)$的单一链分支，那么考虑很多儿子的子树，他们需要先生长一条边，然后并联时，直接作为游戏和异或合并；等价于转化为一堆石子数为$x$的单一游戏，$sg(x)=x$

  - 特殊图上删边游戏：$Christmas \space Game$

    - 定义：图可看成从基础树，添加一些环得到；每次选择树上一个点，在空中生长出一个环还要回到这个点，不能经过其他树上的点

      ![博弈1](\pic\博弈论\博弈1.JPG)

    - 结论：偶环直接去掉，奇环等效为长度为$1$的链

      ![博弈2](\pic\博弈论\博弈2.JPG)

    - 分析：长度为偶数的环，无论剪去哪条边，都只能分成一奇一偶两条链，其异或和为奇数，故$sg=0$，可消去；或者说，无论先手删哪一条边，对方可以对称的删对应边，先手必败，$sg=0$；长度为奇数的环，首先先手是必胜的，因为可以删正中间的边，然后对称操作即可，故$sg>0$，而删去一条边后得到奇偶性相同的两条链，其异或和为偶数，故$sg=1$

  - 图上删边游戏

    - 定义：无向连通图，有一个点为根，不能删边者输，其余规则一样
    - 结论：$Fusion \space Principle$
      - 偶环缩成新点，所有与环相连的边直接与新点相连；奇环缩成新点，延伸一条新边；这样转换$sg$值不变

- 有环$sg$博弈/有向图博弈

  - 使用$spfa$更新$NP$状态值或者$sg$函数值

- 三人$nim$游戏

- $K-L-nim$游戏

- $k$倍动态减法游戏

  - 定义：有一堆石子，含$m$个，双方轮流取，不能取输；第一个人可以取任意个，不能一次取完；以后每次取的石子数量不超过上一次的$k$倍(严格小于$m$个)

  - 结论：

    - 特殊情况：$k=1$，当且仅当$m$为$2$的幂次时，后者胜利，否则先手胜利；$k=2$游戏退化为斐波那契博弈

    - 一般情况：令$NP(x,y)$表示当前有$x$个石子，本次所取不超过$y$个，是否先手必胜；显然存在单调性，即若$NP(x,y_0)=1$，则$\forall y \ge y_0,NP(x,y)=1$；故令$f(x)$表示石子个数为$x$时，使得$NP(x,y_0)=1$的最小$y_0$；考虑画出$NP$表格图，值为$0$的一行中连成一堵墙，如图所示：

      <img src="\pic\博弈论\博弈3.JPG" alt="博弈3" style="zoom: 200%;" />

      考虑一行一行求解$f(i)$，$i$为行数；$f(i)$具有几何意义：从$(i,0)$这个格子，沿着直线$y=x$出发，撞到第一赌墙，所走的步数；注意墙有单调性，即若一堵墙不能挡住当前的射线，则再也不可能挡住以后产生的射线；考虑采用单调栈，从栈顶开始，挡不住的墙依次弹栈，直到撞到，计算步数即$f(i)$，然后产生长度为$f(i)-1$的新墙，压栈；时间复杂度$O(m)$，从几何角度不难实现；先手必败当且仅当$f(m)=m$，因为先手第一次只能取$[1,m-1]$内的石子个数，即$NP(m,m-1)$

- 斐波那契博弈

  - 定义：一堆石子，先手不能全取完，以后每次一方取的个数不超过另一个方上次的两倍，不能取输
  - 结论：斐波那契数处先手必败，否则先手必胜

- 威佐夫博奕

  - 定义：两堆石子，每次任选一堆取走任意个，或者两堆同时取走同样多个，不能取者输
  - 结论：令两堆石子个数为$a,b(a \le b)$，令$k=\frac{\sqrt{5}+1}{2}$，若$(int)k(b-a)=a$，则先手必败，否则先手必胜，即必败态$\{\lfloor k\cdot\frac{1+\sqrt{5}}{2}\rfloor, k+\lfloor k\cdot\frac{1+\sqrt{5}}{2}\rfloor\}(k = 0,1,2,\cdots)$
  - 扩展：两堆石子，个数分别为$n,m(n \le m)$ ，两人轮流从某一堆拿任意数量的物品或同时从两堆中取绝对值$\le k$的物品，每次至少一个，不能操作的人败；$d = k + 1, t^2 + (d - 2) * t - d = 0$，解出$t$，$(m - n) / d * t = n$则为必败态

- 不平等博弈

  - $surreal \space number$基础

    - 定义：是一个包含无穷小、无穷大和实数的域，用它可以十分方便地研究一些不平等博弈问题。$surreal \space number$定义为一个集合对 $\{L|R\}$，其中 $L$ 中的每个元素小于 $R$ 中的每个元素。我们称 $x≤y$ 当且仅当不存在 $x_L∈X_L$ 使得 $y≤x_L$，且不存在 $y_R∈Y_R$ 使得 $y_R≤x$。
    - 性质：
      - 若$x=\{L|R\}$，则$L<x<R$，表示$x$严格大于$L$中的任何一个元素，严格小于$R$中的任何一个元素
      - 令$L_{max}$表示$L$中最大值，则$x=\{L_{max}|R_{min}\}$；注意$L,R$可以为空，这时可以认为其最值为正负无穷大，不影响结论
      - 若$a<x<b$，且$x$是在$a$和$b$之间最早出现的(在树结构中层数最小)，则可证明$x$是唯一的，且$x=\{a|b\}$
    - 运算：
      - 加法法则：$x+y=\{X_{L}|X_{R}\}+\{Y_{L}|Y_{R}\}=\{X_{L}+y,x+Y_{L}|X_{R}+y,x+Y_{R}\}$
      - 取反法则：$-x=-\{X_{L}|X_{R}\}=\{-X_{R}|-X_{L}\}$
      - 乘法法则：$xy=\{X_{L}|X_{R}\}\{Y_{L}|Y_{R}\}=\{X_{L}y+xY_{L}-X_{L}Y_{L}，X_{R}y+xY_{R}-X_{R}Y_{R}|X_{L}y+xY_{R}-X_{L}Y_{R}，xY_{L}+X_{R}y-X_{R}Y_{L}\}$
      - 求逆法则：$\displaystyle{\frac{1}{y}=\{0,\frac{1+(y^{R}-y)(\frac{1}{y})^{L}}{y^{R}},\frac{1+(y^{L}-y)(\frac{1}{y})^{R}}{y^{L}}|\frac{1+(y^{L}-y)(\frac{1}{y})^{L}}{y^{L}},\frac{1+(y^{R}-y)(\frac{1}{y})^{R}}{y^{R}}\}}$

  - 判定结论

    - 用一个$surreal \space number$   $x=\{L|R\}$表示一个局面，$L$集合表示左边玩家的决策空间(子局面)，则可利用$x$的值分类判定游戏状态的胜负情况：
      - $x>0$，$L$玩家总是获胜，无论他是先手还是后手
      - $x<0$，$R$玩家总是获胜，无论他是先手还是后手
      - $x=0$，后手获胜
      - $x||0$，先手获胜；这种情况$x$超出了实数的表示范围是一类无穷类数，表示在$0$附近且和$0$不可比的实数外的数
    - 游戏和：直接求出每个子游戏的$surreal \space number$值$x_i$，则总游戏值为其和$\sum_i{x_i}$
    - 更多结论，请参阅参考文献

  - 一些常见的无穷类数的表示
    $$
    \begin{aligned}\\
    &\{0|1,\frac{1}{2},\frac{1}{4},\cdots\}=\epsilon(无穷小)\\
    &\{0,1,2,3,\cdots|\}=\omega(无穷大)\\
    &\{\epsilon|1,\frac{1}{2},\frac{1}{4},\cdots\}=2\epsilon\\
    &\{0|\epsilon\}=\frac{\epsilon}{2}\\
    &\{0,1,2,3,\cdots,\omega|\}=\omega+1\\
    &\{0,1,2,3,\cdots|\omega\}=\omega-1\\
    &\{\omega|\omega+1\}=\omega+\frac{1}{2}\\
    \end{aligned}\\
    $$
    

- 纳什均衡理论

  - 纯策略均衡：画出$payoff$矩阵，容易检查某个状态是否是纯策略均衡，第一维在行中取最值，第二维在列中取最值，意思是当处于这个组合状态时，任何一方不会轻易改变自己的策略，这个组合是占优的
  - 混合策略均衡：纳什均衡点指的是一组策略，表示某一方对决策空间有一个概率分布，有一个固定的概率选择某个决策，双方均有；在此纳什均衡点处，双方任何一方，不会率先改变自己的策略，因为这样只会使得自己受益减少；无论对方选择何种具体决策，在此点处我们的期望受益$\sum_{c \in S}P_c*V_c$是相等的
  - 纳什均衡点存在定理：在允许混合策略的情况下，任意一个有限个玩家的，每个玩家有有限个可选纯策略的游戏，必然有至少一个纳什均衡点
  - 典型例子
    - 智猪博弈

- $nim$积理论

  - 定义：$x \otimes y = \mathrm{mex}\{(a \otimes b) \oplus (a \otimes y) \oplus (x \otimes b), 0 \le a < x, 0 \le b < y\}$

  - 数表：

    |      |  0   |  1   |  2   |  3   |  4   |
    | :--: | :--: | :--: | :--: | :--: | :--: |
    |  0   |  0   |  0   |  0   |  0   |  0   |
    |  1   |  0   |  1   |  2   |  3   |  4   |
    |  2   |  0   |  2   |  3   |  1   |  8   |
    |  3   |  0   |  3   |  1   |  2   |  12  |
    |  4   |  0   |  4   |  8   |  12  |  6   |

  - 运算性质：

    - $$
      \begin{aligned}
      x \otimes 0 &= 0 \otimes x = 0\\ 
      x \otimes 1 &= 1 \otimes x = x\\
      x \otimes y &= y \otimes x
      \end{aligned}
      $$

    - $$
      \begin{aligned}
      x \otimes (y \otimes z) &= (x \otimes y) \otimes z\\
      x \otimes (y \oplus z) &= (o \otimes y) \oplus (x \otimes z)
      \end{aligned}
      $$

    - $\forall n \in N_+,[0,2^{2^{n}}-1]$中的数在$(\otimes,\oplus)$下构成一域

    - $\forall n \in N_+,2^{2^{n}}\otimes x=2^{2^{n}}\times x(0\le x<2^{2^{n}})$

    - $\forall n \in N_+,2^{2^{n}}\otimes 2^{2^{n}}=\frac{3}{2}\cdot2^{2^{n}}=2^{2^{n}}\oplus2^{2^{n}-1}$

  - 复杂度：模板计算一次大约复杂度$O(log^2)$

  - 应用：高维硬币游戏

    - 考虑二维网格平面，选择一个正方形(边长$\ge 2$)，取角落$4$个格子，同时翻转硬币，要求右上角(横纵坐标都大)的一个格子是从正面翻到反面的，不能翻者败，其$sg(x,y)=x \otimes y$
    - 可以扩展成三维或者更高维，$sg(x,y,z)=x \otimes y \otimes z$
    - 考虑另一个版本的硬币游戏，每次选择一个正方形(边长$\ge 2$)，取右上角和左下角翻转，则$sg(x,y)=x \oplus y$

- $shannon$开关游戏

- 广义地理游戏

- $k-knights$游戏

  - 定义：棋盘上有$k$只马，每次玩家对每只马都要操作，每只马只能向左下角四个方向走(日子)，当无法操作者输
  - 结论：由于是一种$Every$游戏，故单一游戏需要满足：能够胜利的尽可能慢的胜利，不能胜利尽可能快的输掉；令$round(x,y)$表示单一的马在$(x,y)$时最快的步数，结论为：$round(x,y)-\lfloor\frac{x}{2}\rfloor-\lfloor\frac{y}{2}\rfloor$有规律(除了左下角$4 \times 4$和最外围一圈，可以$dp$)。



【123】代数：牛顿恒等式与对称多项式相关

- 几类基本的对称多项式定义与性质

  - 初等对称多项式$e$  [Elementary symmetric polynomial](https://en.wikipedia.org/wiki/Elementary_symmetric_polynomial)

    - $e_k (x_1 , \ldots , x_n )=\sum_{1\le  j_1 < j_2 < \cdots < j_k \le n} x_{j_1} \dotsm x_{j_k}$

    - 特殊情况：$k=0,e_0=1;k>n,e_k=0$

    - $\prod_{j=1}^n ( \lambda - X_j)=\lambda^n - e_1(X_1,\ldots,X_n)\lambda^{n-1} + e_2(X_1,\ldots,X_n)\lambda^{n-2} + \cdots +(-1)^n e_n(X_1,\ldots,X_n)$

    - $\sum_{k=0}^\infty e_k(X_1,\ldots,X_n)(-t)^k = \prod_{i=1}^n(1-X_it)$

    - $P(X_1,\ldots, X_n)=Q\big(e_1(X_1 , \ldots ,X_n), \ldots, e_n(X_1 , \ldots ,X_n)\big)$

      任何一个对称多项式，都可以表示成$e_i$的多项式表达$Q$，且这种表达是唯一的，若$P$是整系数的，$Q$也是整系数的

  - 幂和对称多项式$p$  [Power sum symmetric polynomial](https://en.wikipedia.org/wiki/Power_sum_symmetric_polynomial)

    - $p_k (x_1, x_2, \dots,x_n) = \sum_{i=1}^n x_i^k$
    - 与初等对称多项式之间的关系(缩写了变量，均含$n$个变量)
      - $p_k = (-1)^{k-1}ke_k+\sum_{j=1}^{k-1} (-1)^{k-1+j} e_{k-j} p_{j}$，$\forall n\ge 1,k \in [1,n]$
      - $p_k=\sum_{j=k-n}^{k-1}(-1)^{k-1+j}e_{k-j}p_j$，$k>n$
      - $ke_k = \sum_{j=1}^k (-1)^{j-1} e_{k-j} p_j$，$\forall n \ge 1,k \in [0,n]$

  - 完全齐次对称多项式$h$  [Complete homogeneous symmetric polynomial](https://en.wikipedia.org/wiki/Complete_homogeneous_symmetric_polynomial)

    - 定义
      - $h_k (X_1, X_2, \dots,X_n) = \sum_{1 \leq i_1 \leq i_2 \leq \cdots \leq i_k \leq n} X_{i_1} X_{i_2} \cdots X_{i_k}$
      - $ h_k (X_1, X_2, \dots,X_n) = \sum_{l_1+l_2+ \cdots + l_n = k \atop l_i \geq 0 } X_{1}^{l_1} X_{2}^{l_2} \cdots X_{n}^{l_n}$
      - $h_k (X_1, X_2, \dots,X_n) = \sum_{1 \leq i_1, i_2 , \cdots , i_k \leq n} \frac{m_1! m_2 !\cdots m_n!}{k!} X_{i_1} X_{i_2} \cdots X_{i_k}$
      - 特殊情况：$k=0,h_0=1;k>n,h_k未必为0$
    - 生成函数
      - $\sum_{k=0}^\infty h_k(X_1,\ldots,X_n)t^k = \prod_{i=1}^n\sum_{j=0}^\infty(X_it)^j = \prod_{i=1}^n\frac1{1-X_it}$
    - 与其他对称多项式之间的关系
      - $\sum_{i=0}^k(-1)^ie_i(X_1,\ldots,X_n)h_{k-i}(X_1,\ldots,X_n)=[k=0]$，$\forall k \ge 0$
      - $kh_k=\sum_{i=1}^kh_{k-i}p_i$，$k \in [0,n]$

- 计算方法：令$S=\{x_1,x_2,x_3,\cdots , x_n\}$

  - 由$S$计算$e$
    - 直接将$f(t)=\prod_{i=1}^n(1+x_it)$展开，利用分治$fft/ntt$得到系数即是$e$，复杂度$O(nlog^2n)$
  - 由$e$计算$S$
    - 将$e$交错化($e_i=(-1)^ie_i$)之后看成多项式，求其$n$个根即是$x_i$
  - 由$e$计算$p$
    - 由$p,e$关系直接分治$fft/ntt$，复杂度$O(nlog^2n)$，注意如果$k>n$需要再做一次
    - 多项式除法，$P=\frac{Q}{1-E}$，$P$为$p_k$的生成函数，$Q$为$(-1)^{k-1}e_kk$的生成函数，$E$为$(-1)^{k-1}e_k$的生成函数，注意这里强制令$e_0=p_0=0$以防卷积边界出错，复杂度$O(nlogn)$，注意这里只用于计算前$n$项
    - $\log\left(\sum_{n=0}^\infty e_n \,x^n \right)= \sum_{n=1}^\infty \frac{(-1)^{n+1}}{n} p_n \,x^n$，复杂度$O(nlogn)$
  - 由$p$计算$e$
    - $\sum_{n=0}^\infty e_n \,x^n = \exp\left(\sum_{n=1}^\infty \frac{(-1)^{n+1}}{n} p_n \,x^n \right)$，复杂度$O(nlogn)$
    - 由$p,e$关系直接分治$fft/ntt$，复杂度$O(nlog^2n)$， 注意这里只用于计算前$n$项 
  - 由$e$计算$h$
    - 将$e$交错化($e_i=(-1)^ie_i$)之后看成多项式，多项式求逆系数即为$h$，复杂度$O(nlogn)$
  - 由$p$计算$h$
    - 由$h,p$关系直接分治$fft/ntt$，复杂度$O(nlog^2n)$， 注意这里只用于计算前$n$项

【124】代数：奇数双阶乘对$2^p$分块模数列的性质

函数$f(n)=1\times 3 \times 5 \times \cdots \times n$，其中$n$为奇数，则令$b_n=f(2^n) \% 2^p$。则$b_{kn}=b_k^n$对$k \ge \frac{p+1}{3}$恒成立。若已知$b_k=B$，则$f(n)=B^{\lfloor n/2^k \rfloor}*\prod_{k \in [\lfloor n/2^k \rfloor\times 2^k +1,n] 且 odd(k)}k$，复杂度$O(2^k)$。

【125】代数：关于下降阶乘幂的多项式间的运算

- 两个下降阶乘幂多项式的乘法

  - 令$f(x)=\sum_{i=0}^{+\infin} a_ix^{\underline{i}},A(x)=\sum_{i=0}^{+\infin}a_ix^i$

  - $g(x)$与$f(x)$形式类似，要求$f(x)g(x)$一种思路是利用斯特林数将两个多项式本身的具体系数求出来，然后用$fft/ntt$做多项式乘法，但是那样没有利用好阶乘幂本身的性质

  - 不难发现：$\frac{k^{\underline{i}}}{k!}=\frac{1}{(k-i)!}$

  - 我们考虑绕过$f(x)$本身的具体系数，直接求其点值序列的指数型生成函数$F(x)$

  - $$
    F(x)=\sum_{k=0}^{+\infin}\frac{f(k)}{k!}x^k=\sum_{k=0}^{+\infin}\frac{x^k}{k!}\sum_{i=0}^{+\infin}a_ik^{\underline{i}}=\sum_{i=0}^{+\infin}a_i\sum_{k=0}^{+\infin}\frac{x^k}{(k-i)!}=e^x\sum_{i=0}^{+\infin}a_ix^i=e^xA(x)
    $$

  - 我们已知$A(x)$，即可从$F(x)$中取出点值序列，$G(x)$类似，点值序列直接点乘，构成指数型生成函数$F_{ret}(x)$，再利用上述公式逆向求得$A_{ret}(x)=e^{-x}F_{ret}(x)$，取出系数即可

【126】图论：图有关的定理

- $Petersen's$   $theorem$
  - $3-$正则无桥边的无向图，必存在完美匹配(此图不可能有奇数个点)
  - 推广：$d-$正则无向图，边连通度$\ge d-1$(至少删除$d-1$条边，图才可能不连通)，若点数为偶数，则必存在完美匹配；更进一步的，对每一条边，都存在一个包含此边的完美匹配
- $Tutte$   $theorem$
  - 无向图$G=(V,E)$，存在完美匹配，当且仅当$\forall U\subseteq V$，$G-U$至多含有$|U|$个奇数联通块
  - 即$G=(V,E),\forall U \subseteq V,odd(G-U) \le |U|$，其中$odd(G)$表示$G$中奇数连通块的个数
- $Tutte–Berge$   $formula$
  - $G=(V,E)$的最大匹配的个数$=\frac{1}{2}min_{U \subseteq V}(|U|-odd(G-U)+|V|)$
- $Matrix$  $Tree$  $theorem$
- $BEST$   $theorem$

【127】代数：常见的代数恒等式

【128】组合/图论：图的点染色相关

- 色数
  - 定义：图$G$的色数$\chi(G)$表示，最小的正整数$k$，使得图$G$是$k-$可着色的。
  - 界：$\chi(G) \ge \omega(G), \chi(G)(\chi(G)-1) \le 2m$，$\omega(G)$表示$G$的最大团中点的个数(团数)，$m$为边数
- 着色算法
  - 贪心着色算法：$\chi(G) \le d(G)+1$，$d(G)$为$G$的最大点度数。选择一个点编号的排列，依次染色；对节点$x$，寻找与其相邻且被染的颜色中未使用的最小颜色编号$c$，将$x$染成$c$。每个点的颜色编号不超过其度$+1$。
- 特殊图性质
  - 平面图
    - 四色定理：任何平面图是$4-$可着色的
    - 度性质：平面图的最小度节点，其度数$\le 5$
    - $6-$着色方案：每次寻找一个最小度节点删掉，先染剩余图，最后染这个节点，递归构造方案
  - 弦图
    - $\chi(G)=\omega(G)$
    - 构造算法：先构造其完美消除序列$a$，翻转得到序列$b$，对$b$序列应用贪心染色构造算法
- $Brooks$定理：$G$不是完全图或奇环时，$\chi(G) \le d(G)$
- $k-$可着色判定
  - $k=3,n \le 40,O(3^{n/3}n^2)$：枚举一个极大独立集$I$，判定$G-I$是否是二分图 。
  - 任意 $k$：$O(2^nn)$
    - 令$f(x)=\sum_{S \subseteq V}[S是G中的独立集(允许为空)]x^S$表示$G$的独立集集合幂级数
    - 定义乘法为集合并卷积：$h=f \circ g \quad \leftrightarrow \quad h_S=\sum_{L \cup R=S \\ L,R \subseteq 2^U}f_Lg_R$
    - 计算$h=f^k$，若$h_V>0$表示存在使用不超过$k$种颜色的染色方案，即$G$是$k-$可着色的
    - 具体先对$f$做莫比乌斯变换得到$\hat{f}$，然后对$\hat{h}=\hat{f}^k(这里是点积)$做莫比乌斯反演得到$h$
    - 更进一步的，若$k \le |V|=n$，则可严格$k-$着色，即不允许颜色不使用
- 求图的色数$\chi(G)$
  - 二分+判定：$O(2^nnlogn)$
  - 改进着色判定算法：$O(2^nn)$
    - 求出$\hat{f}$之后，枚举$k \in [1,n]$，找到最小的符合要求就退出
    - 每次$check(k)$，先$O(2^n)$刷新一下$\hat{h}=\hat{f}^k$数组，$O(2^n)$判定$h_V=\sum_{S \subseteq V}(-1)^{|V|-|S|}\hat{h}_S>0$
    - 因为判定只需要求单点，所以可以将莫比乌斯反演展开



【129】组合/图论：图的染色多项式   [Chromatic polynomial](https://en.wikipedia.org/wiki/Chromatic_polynomial)

- 定义
  - $k-$染色数：对点带标号无向图$G=(V,E)$进行点染色，使得一条边两端点异色；使用带标号的$k$种颜色染色的方案数(允许颜色不使用)，记为$P(G,k)$。
  - $k-$独立集划分方案数：将$V$划分为$k$个非空不交且并为$V$的点独立集的方案数，独立集之间相对无序，即无标号，记为$h(G,k)$。等价于严格使用$k$种无标号的不同颜色的染色方案数(颜色不允许不用，且颜色之间无差别)。
  - 染色多项式：对无向图$G=(V,E)$的关于$x$的多项式$P(G,x)$，令$x=k$即得到$k-$染色数。
  - 独立集划分多项式：$H(G,x)=\sum_{i=0}^{+\infin}h(G,i)x^i$，这是一个$n=|V|$次首$1$多项式。
  
- 基本性质：令$G$含有$c$个联通块$G_i$
  - $P(G,x)$是关于$x$的$n$次首$1$多项式
  - $P(G,x)$中$x^0,\cdots,x^{c-1}$系数为$0$；$x^c,\dots,x^n$系数非$0$且正负交替；常数项必为$0$
  - $x^n$系数为$1$，$x^{n-1}$系数为$-|E|=-m$
  - $P(G,x)=\prod_{i=1}^cP(G_i,x)$
  - $\chi(G)$为使得$P(G,k)>0$的最小正整数$k$
  - 系数绝对值满足对数上凸性：$a_i^2 \ge a_{i-1}a_{i+1}$
  
- 特殊图的染色多项式
  - 完全图$K_n$：$P(G,x)=\prod_{i=0}^{n-1}(x-i)=x^{\underline{n}}$
  - 无边空图$\overline{K_n}$：$P(G,x)=x^n$
  - 树$T_n$：$P(G,x)=x(x-1)^{n-1}$，可作为树的判定充要条件
  - 简单环$C_n$：$P(G,x)=(x-1)^n+(-1)^n(x-1)$
  - 弦图$Ch_n$：$P(G,x)=\prod_{i=1}^n(x-x_i)$，令$a$表示其一个完美消除序列，令$x_i$表示和节点$a_i$相邻的且在$a$排在$a_i$后面的节点个数。
  
- 染色多项式和独立集划分多项式之间的关系及其系数的意义

  - 令$p_k,h_k$分别表示$P(G,x),H(G,x)$中$x^k$系数，由于$H$表示严格使用无区别的颜色，故：$P(G,x)=\sum_{k=0}^x\binom{x}{k}k!h_k=\sum_{k=0}^xh_kx^{\underline{k}}$，即$P(G,x)$是以$\{h_k\}$为系数的下降阶乘幂多项式
  - $p_{k}=\sum_{j=0}^{n}(-1)^{j-k}\left[\begin{array}{l}{j} \\ {k}\end{array}\right] h_{j} , h_{k}=\sum_{j=0}^{n}\left\{\begin{array}{l}{j} \\ {k}\end{array}\right\} p_{j},n=|V|$，转换系数为两类斯特林数
  - 事实上，由于$x^n$表示空图的染色多项式，而$x^{\underline{n}}$表示$n$个点的团的染色多项式；故将$P(G,x)$写成$x^n$形式，本质上相当于用删除收缩算法将图$G$规约为若干个空图的和，而写成$x^{\underline{n}}$则是将$G$规约为若干个团的和
  - 假设用$x$种颜色染色，考虑容斥原理，将不符合要求的染色方案删去；每一条边都是一个限制，它们未必独立，但是不影响容斥过程：我们从全集$x^n$减去打破某一条边的方案，加上打破某两条边的方案，减去三条边的...故$P(G,x)=\sum_{r=0}^{m}\sum_{k=1}^n(-1)^rN(k,r)x^k=\sum_{k=1}^n\{\sum_{r=0}^m(-1)^rN(k,r)\}x^k$，即$p_k=\sum_{r=0}^m(-1)^rN(k,r)$，其中$m$表示边数，$N(k,r)$表示$G$中只保留$r$条边，保留所有点，且联通块个数为$k$的方案数。

- 计算染色多项式
  - 令$w(0)=0,w(i)=P(G,i),i \in [1,n]$；计算出$w$数组之后，利用拉格朗日插值计算$P(G,x)$
  - 本质上我们要对独立集集合幂级数做多重子集卷积，应改造为二元生成函数
  - 令$f(x)=\sum_{S \subseteq V}[S是G中的独立集(允许为空)]u^{|S|}x^S$为$G$的二元独立集集合幂级数；定义乘法：$x^S*x^T=x^{S \cup T}$为集合并卷积，$u^x*u^y=u^{x+y}\%u^{n+1}$为模$u^{n+1}$意义下多项式乘法
  - 则系数$[u^nx^{V}]f^k=w(k)$，即$k-$染色方案数，复杂度$O(2^nn^3)$
  - 具体仍然先用莫比乌斯变换求$\hat{f}$，中间涉及的是多项式加减；对每个$k \in [1,n]$，求$\hat{h}=\hat{f}^k$，应用模意义下多项式乘法，然后用莫比乌斯反演计算$h=f^k$，中间涉及多项式加减；实现的时候只需要将$fwt\_or$改造为模板类即可
  
- 删除收缩

  - 删除操作：$G-uv$表示从图$G$中删除边$uv$得到的新图

  - 收缩操作：$G/uv$表示从图$G$中收缩掉边$uv$，即将$u$和$v$合并为同一个点，去掉重边和自环，得到的新图

  - 递归式：$P(G-uv,x)=P(G,x)+P(G/uv,x)$，讨论$u,v$两点是否同色即可得到；类似的$h(G-uv,x)=h(G,x)+h(G/uv,x)$也是成立的

  - 删除收缩算法计算染色多项式：$O(1.62^{|V|+|E|})$

    ![删除收缩](\pic\数学\删除收缩.JPG)

- 图之间的运算
  
  - 并(和)：将两个图$A,B$不连接的放在一个新图中，其染色多项式等于二者相乘
  - 全连接(积)：将$A,B$之间的点对都连上边，得到新图$C$；则$P(C,x)=P(A,x) \circ P(B,x)$，这里$\circ$运算表示将两个多项式的下降幂形式写出，视下降幂为普通幂$x^n$，进行多项式乘法运算，最后则换回。如：$x^{\underline{2}}(x^{\underline{2}}+x^{\underline{3}})=x^{\underline{4}}+x^{\underline{5}}$
  - 团连接：若$A,B$相交于一个$k$元团$G$，则$P(A \cup B,x)=P(A,x)P(B,x)/P(G,x)$
  
- 简单应用：与无向图边定向的关系
  
  - 无向图的无环定向方案数([Acyclic orientation](https://en.wikipedia.org/wiki/Acyclic_orientation))：为每条边指定一个方向，使得$G'$为$DAG$方案数为$P(G,-1)*(-1)^{|V|}$
  - 以任一特定点$x$为唯一汇点(出度为$0$)的无向图无环定向方案数($DAG$上蕴含着每个点都可以走到$x$)与$x$无关，$ans=(-1)^{|V|-1}[x^1]P(G,x)$，即一次项系数乘$(-1)^{n-1}$；例如：$n$个点的树的染色多项式$P(G,x)=x(x-1)^{n-1}$所计算答案为$1$，表示以每个点$x$为唯一汇点的无环定向方案数均为$1$种，就是以这个点$x$为根的有根树，树边方向向上，其他的方案，至少存在两个汇点(出度为$0$)
  - [Gallai–Hasse–Roy–Vitaver theorem](https://en.wikipedia.org/wiki/Gallai%E2%80%93Hasse%E2%80%93Roy%E2%80%93Vitaver_theorem)   
    - 色数为$k$的无向图的每一种定向方案，都存在从点$x$出发的点数为$k$的有向路径，其中$x$可以是在定向之后的有向图中能走到任何其他点的任何节点
    - 对无向图$G$进行边定向，使得得到的有向图中有向简单路径最长路最短；这样的最短最长路含的点数等于图$G$的色数$\chi(G)$



【130】组合/图论：竞赛图相关

- 定义：竞赛图指的是将简单完全无向图进行边定向得到的有向图
- 对于$n$个点的竞赛图$T$，以下几个命题相互等价：且满足以下命题的竞赛图$T$有$n!$种
  - $T$满足传递性
  - $T$中节点满足严格全序
  - $T$中无环
  - $T$中不含三元环
  - $T$中节点出度集合为$\{0,1,2,3,\cdots,n-1\}$
  - $T$有严格一条哈密尔顿路径
- 竞赛图必含有哈密尔顿路径，其$O(n^2)$构造算法为：考虑递归构造，逐一加点；假设存在一个哈密尔顿路径$v_1,v_2,v_3,...,v_n$，现在加一个点$p$，只要暴力寻找一个合适的位置插入即可，可以证明一定可以插入。考虑$p$不能插入在开头，故$v_1 \to p$；若$p \to v_2$，则$p$可插入在$v_1,v_2$之间，否则$v_2 \to p$；同理进而推导出所有点可走到$p$，则$p$可插入在最后。
- 其他性质
  - 若$T$为强连通图，则必存在哈密尔顿圈；进一步的，对每个节点$x$，存在长度为$k$的哈密尔顿圈经过$x$，其中$k \in [3,n]$
  - 若$T$为$4-connected$，则对于$\forall x \neq y$，存在从$x$走到$y$的哈密尔顿路径
  - 所有$n$个带标号点的竞赛图中，含有的无环竞赛子图总数量为：$\sum_{k=1}^n\binom{n}{k}k!2^{\binom{n}{2}-\binom{k}{2}}$
  - 选取$T$中任一出度最大的点$u$，可以最小化$\max_{v \in V}dist(u,v)$，且此值$d \le 2$
- $score$序列与$score$集：能作为$n$个节点得分的序列$s$(即出度序列)，当且仅当：
  - $0 \le s_1 \le s_2 \le \cdots \le s_n$
  - $\sum_{i=1}^ks_i \ge  \binom{k}{2},i \in [1,n-1]$
  - $\sum_{i=1}^ns_i=\binom{n}{2}$



【131】组合/代数：类二项系数与类斯特林数

- 斐波那契二项系数  [Fibonomial coefficient](coefficient)

- 高斯二项系数   [Gaussian binomial coefficient](https://en.wikipedia.org/wiki/Gaussian_binomial_coefficient)
- $q-$级数与$q-$符号   [*q*-Pochhammer symbol](https://en.wikipedia.org/wiki/Q-Pochhammer_symbol#q-series)   [*q*-analog](https://en.wikipedia.org/wiki/Q-analog)    [List of *q*-analogs](https://en.wikipedia.org/wiki/List_of_q-analogs)



【132】组合：斐波那契数列循环节

- 斐波那契数列模任意数周期的性质
  - 令$\pi(m)$表示斐波那契模$m$的模数列的周期，$\pi(lcm(a,b))=lcm(\pi(a),\pi(b))$
  - 若$m=\prod_{k}p_k^{a_k}$，则$\pi(m)=lcm(\pi(p_k^{a_k}))$
  - $\forall m$，$\pi(m) \le 6m$
  - 若$n|m$，则$\pi(n)|\pi(m)$
  - 若$p$为质数，则$\pi(p^e)=p^{e-1} \pi(p)$
  - $ 1, 3, 8, 6, 20, 24, 16, 12, 24, 60, 10, 24, 28, 48, 40 $为前$15$个正整数模数周期

- 实用方法

  - 根据$5$是否是$p$的二次剩余进行讨论

  - $$
    F(p)=\left\{\begin{array}{ll}{p-1} & {\left(5 \frac{p-1}{2} \equiv 1(\bmod p)\right)} \\ {2 *p +2} & {\left(5^{\frac{p-1}{2}} \equiv-1(\bmod p)\right)}\end{array}\right.
    $$

  - 由于$\pi(p) | F(p)$，所以可以枚举$F(p)$的约数，检查其是否为周期

- 简单推广

  - 若$f(n)=af(n-1)+bf(n-2),f(1)=c,f(2)=d$，求$f(n)\%p$周期，$p$为质数

  - $$
    F(p)=\left\{\begin{array}{ll}{p-1} & {\left(x \frac{p-1}{2} \equiv 1(\bmod p)\right)} \\ {(p-1)(p+1)} & {\left(x^{\frac{p-1}{2}} \equiv-1(\bmod p)\right)}\end{array}\right.
    $$

  - 同上，枚举其约数，检验是否为一个周期：即检查$f$序列的转移矩阵$A^T=E$是否成立

  - 如果时间比较充裕，直接采用$p^2-1$作为一个周期



【133】组合/图论：与哈密尔顿路径和回路有关的定理



【134】代数/几何：用于多圆相切问题的笛卡尔定理

- 若平面上有$4$个两两相切与不同点(共$6$个点)的圆
  - 令$k_i$表示第$i$个圆的曲率$k_i=\frac{1}{r_i}$
  - $(\sum_{i=1}^4k_i)^2=2\sum_{i=1}^4k_i^2$，圆的曲率$k_i$一般取正，若该圆与其他圆同时内切，则取负
- 若三维空间存在$5$个两两相切的球
  - $ (\sum_{i=1}^5k_i)^2=3\sum_{i=1}^5k_i^2 $



【135】群论：[Schreier–Sims algorithm](https://en.wikipedia.org/wiki/Schreier%E2%80%93Sims_algorithm)

1.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=010315    $H$题

注：难题，模板题



【136】组合：计算$f(n)=xor_{i=1}^ni$
$$
f(n)=\begin{cases}
n & n\%4=0 \\  
n+1 & n\%4=2 \\
1 & n\%4=1 \\
0 & n\%4=3
\end{cases}
$$

【137】概率论：树上随机游走

$d[x]$为$x$度(包括父亲)，$f[x]$表示$x$走到父亲的期望步数，$g[x]$表示从$x$的父亲走到$x$的期望步数
$$
f[x]=d[x]+\sum_{son}f[son] \\
g[x]=d[father]+g[father]+\sum_{brother}f[brother]
$$

【138】组合：卡特兰数列及其相关

- $Catalan \space Number$ [维基](https://en.wikipedia.org/wiki/Catalan_number)

  - 简要数表：$1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845...$

  - 通项公式：$C_n = {2n\choose n} - {2n\choose n+1} = {1\over n+1}{2n\choose n}= \frac{(2n)!}{(n+1)!\,n!} = \prod\limits_{k=2}^{n}\frac{n+k}{k}$

  - 递推式

    - $C_0 = 1,C_{n+1}=\frac{2(2n+1)}{n+2}C_n$
    - $C_0 = 1,C_{n+1}=\sum_{i=0}^{n}C_i\,C_{n-i},n\ge 0$

  - 多重卷积：
    $$
    \sum_{i_1+\cdots+i_m=n\\i_j\ge 0} C_{i_1}\cdots C_{i_m} = \begin{cases}
       \dfrac{m(n+1)(n+2)\cdots (n+m/2-1)}{2(n+m/2+2)(n+m/2+3)\cdots (n+m)}C_{n+m/2}, & m \text{ even}\\[5 pt]
       \dfrac{m(n+1)(n+2)\cdots (n+(m-1)/2)}{(n+(m+3)/2)(n+(m+3)/2+1)\cdots (n+m)}C_{n+(m-1)/2}, & m \text{ odd}
     \end{cases}
    $$

  - 渐进式：$C_n \sim \frac{4^n}{n^{3/2}\sqrt{\pi}}$

  - 生成函数
    $$
    c(x)=1+xc(x)^2 \\
    c(x) = \frac{1-\sqrt{1-4x}}{2x}=\frac{2}{1+\sqrt{1-4x}} \\
    \sqrt{1+y} = \sum_{n=0}^\infty {\frac12 \choose n} y^n = \sum_{n=0}^\infty \frac{(-1)^{n+1}}{4^n(2n-1)} {2n \choose n} y^n=1+\frac{1}{2}y-\frac{1}{8}y^2+\cdots \\
    c(x) = \sum_{n=0}^\infty {2n \choose n} \frac{x^n}{n+1}
    $$

  - 基本应用

    - $C_n$是$n$条边($n+1$个点)的有根有序树种类数，每个点的儿子是有序的
    - $C_n$是不穿过对角线的$n \times n$的从$(0,0)$走到$(n,n)$每次只能向右向上走的路径数量(下图$n=4$)![catalan_1](\pic\数学\catalan_1.JPG)
    - $len(LIS_X) \le 2$的$1..n$的排列$X$个数
    - $C_n$是用$n$个矩形覆盖$n \times n$的左上三角阶梯的方案数(下图$n=4$)![catalan_2](\pic\数学\catalan_2.png)
    - $C_n$是$\{1..n\}$的几何不交集合划分方案数，指的是将$1..n$排成圆周，同种集合的作用关系是不交的；如图$5$元素，上面是$42$种不交的方案，下面是$10$种相交的方案，总和为$Bell$数![catalan_3](\pic\数学\catalan_3.png)
    - $C_n$是$2n$个人的圆周不交握手方案，下图是$n=1,2,3,4$；这其实是几何不交集合划分，每个块都是大小为$2$的方案数![catalan_4](\pic\数学\catalan_4.JPG)
    - $C_n$是周长为$2n+2$的斜骨牌$Skew Polyominos$的方案数，斜骨牌要求联通且每一列的最高点递增、最低点递增，注意不特别限定骨牌个数![catalan_5](\pic\数学\catalan_5.JPG)

  - 证明相关

    - 考虑格路径计数，一条路径$p$对角线上方的竖直向上步数为$e(p) \in [0,n]$，事实上对每种$e(p)$取值路径数量相等，故$C_n=\frac{1}{n+1}\binom{2n}{n}$

  - 行列式相关

    - 若$n \times n$的矩阵$A_n[i][j]=C_{i+j-2}$，则$det(A_n)=1$，$\forall n \ge 1$
      $$
      \det\begin{bmatrix}1 & 1 & 2 & 5 \\ 1 & 2 & 5 & 14 \\ 2 & 5 & 14 & 42 \\ 5 & 14 & 42 & 132\end{bmatrix} = 1
      $$

    - 若$n \times n$的矩阵$A_n[i][j]=C_{i+j-1}$，则$det(A_n)=1$，$\forall n \ge 1$
      $$
      \det\begin{bmatrix}1 & 2 & 5 & 14 \\ 2 & 5 & 14 & 42 \\ 5 & 14 & 42 & 132 \\ 14 & 42 & 132 & 429 \end{bmatrix} = 1
      $$

    - 这是$Hankel$矩阵，若以上两个条件同时成立，则可唯一确定此矩阵所对应的序列必定为$Catalan$序列

  - 一些扩展

    - [Bertrand's ballot theorem](https://en.wikipedia.org/wiki/Bertrand%27s_ballot_theorem)

      - 将$p$个$+1$和$q$个$-1$排成一排，求方案数使满足任意前缀和严格$>0$，其中$p>q$：
        $$
        f_{>}(p_{+1},q_{-1})=\frac{p-q}{p+q} \binom{p+q}{p}
        $$

        - 证明：考虑将所有元素放在圆周上，构成圆排列，由于每个排列隶属于一个圆排列，故只分析一个圆排的概率；不断选取圆周上的相邻的两个未标记的元素左$+$右$-$，同时标记；最后必定剩余$p-q$个$+1$，任选一个作为开头展开序列为合法序列，故概率为$\frac{p-q}{p+q}$。相关序列：[Lobb number](https://en.wikipedia.org/wiki/Lobb_number)

      - 若前缀和$ \ge 0$，其中$p \ge q$：
        $$
        f_{\ge}(p_{+1},q_{-1})=\frac{p+1-q}{p+1+q} \binom{p+1+q}{q}=\frac{p+1-q}{p+1} \binom{p+q}{q}
        $$

        - 证明：只需要在一个合法序列开头追加一个$+1$，即可化归为前面的情形

      - 将$p$个$+1$和$q$个$-k$排成一排，求方案数使满足任意前缀和严格$>0$，其中$p>kq$：
        $$
        f_{>}(p_{+1},q_{-k})=\frac{p-kq}{p+q} \binom{p+q}{p}
        $$

      - 若前缀和$\ge 0$，其中$p \ge kq$：
        $$
        f_{\ge}(p_{+1},q_{-k})=\frac{p+1-kq}{p+1+q} \binom{p+1+q}{q}=\frac{p+1-kq}{p+1}\binom{p+q}{q}
        $$

      - 一维随机游走：从原点$0$开始等概率随机游走$n$步(每次等概率向左或者向右走$1$)，走到$x$轴上$m$坐标，且中途不走到负数坐标的方案数：
        $$
        \binom{n}{\tfrac{n+m}2}-\binom{n}{\tfrac{n+m}2+1} = \frac{m+1}{\tfrac{n+m}2+1}\binom{n}{\tfrac{n+m}2}
        $$
        
      - 穿过对角线严格$k$次的$Dyck(n)$格路径计数：平面上从起点$S(x,y)$走到终点$T(p,q)$，$T$在$S$右上方，每步只能向右向上，且穿过对角线$y=x+b$严格$k$次方案数记为$F_k(S,T)$，至少$k$次方案数记为$G_k(S,T)$；首先显然可以通过旋转对称以及平移的手段使得起点$S$不在对角线$l$之上，且对角线平移到$y=x$
      
        - 若$S$在$l$严格下方：无论从$S$出发第一步是向右还是向上，第一次穿过$l$的时候路径必然和$l_{+1}:y=x+1$相交，第二次必然和$l_{-1}:y=x-1$相交，根据反射原理，我们交替的将起点$S$关于直线$l_{+1},l_{-1},l_{+1}...$反射对称，容易发现：反射前$S \to T$穿过$l$至少$k$次的路径与反射后$S_1 \to T$穿过$l$至少$k-1$次的路径一一对应，故只需要做$k$次反射，即转化为计算$S_k \to T$的基本路径计数，这是个组合数，其中$S_k$表示$S$做$k$次交替反射的对称点。点$(x,y)$关于$l_{+1}$的对称点为$(y-1,x+1)$，关于$l_{-1}$的对称点为$(y+1,x-1)$；故当$k$为奇数时，$S_k=(y-k,x+k)$；当$k$为偶数时，$S_k=(x+k,y-k)$。若$T$不在$S_k$的不严格右上方，则$G_k(S,T)=0$；否则$\large G_k(S,T)=\binom{p+q-(x+y)}{p+(q-p)(k\&1)-(x+k)}$；而$F_k(S,T)=G_k(S,T)-G_{k+1}(S,T),k \ge 0$。
      
        - 若$S$在$l$上：平移$S$为原点$(0,0)$，注意到从$S$出发的第一步存在区别，令$G_{右/上k}(S,T)$表示从$S \to T$的每步非右即上的穿过对角线$l$至少$k$次的且第一步必须是向右/上的格路径条数。若第一步是向右的，那么第一次穿过$l$必定会与$l_{+1}$相交，这与上面情况相似；故这种路径一一对应于$S_k \to T$的第一步受限的基本路径($k$为奇数，第一步必须向上，否则第一步必须向右)。若$S_k$走完第一步得到$S_{k}'$，当$k$为奇数时，$S_k'(-k,k+1)$，否则$S_k'(k+1,-k)$。因此若$T$不在$S_k'$的不严格右上方，$G_{右k}(S,T)=0$；否则，$\large G_{右k}(S,T)=\binom{p+q-1}{q+(p-q)(k\&1)+k}$。令$T'(q,p)$，考虑$G_{上k}(S,T)=G_{右k}(S,T')$，故得到结论：**小心特判**
          $$
          G_{k}(S,T)=G_{右k}(S,T)+G_{上k}(S,T)\\
          =G_{右k}(S,T)+G_{右k}(S,T')=\binom{p+q-1}{p+k}+\binom{p+q-1}{q+k} \\
          一般情况写代码时，利用倒数第二个公式去分类讨论\\
          注意最后一步组合公式不一定总是成立(在p,q >k时成立)，考虑前面的特判\\
          F_k(S,T)=G_k(S,T)-G_{k+1}(S,T),k \ge 0\\
          此公式总是适用任何情况
          $$
      
          - 特殊情况：$T$也在$l$上，不妨设$T(n,n),n \ge 1$；则有：$\large G_k(S,T)=2\binom{2n-1}{n+k},k \in [0,n)$，注意$k$的范围特判
      
    - 卡特兰三角形和卡特兰梯形([Catalan's triangle](https://en.wikipedia.org/wiki/Catalan%27s_triangle))
    
      - 定义：$m \ge 1$，行列从$0$开始的数表，第$0$列均为$1$，第$0$行前$m$个元素为$1$，在$k \le n+m-1$范围内，$C_m(n,k)=C_m(n-1,k)+C_m(n,k-1)$，超出范围为$0$，称之为卡特兰梯形($C_m$)，在$m=1$时退化为卡特兰三角形
    
      - 简要数表：$m=3$
    
        | n\k  |   0   |   1   |   2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
        | :--: | :---: | :---: | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
        |  0   | **1** | **1** | **1** |      |      |      |      |      |      |      |
        |  1   | **1** |   2   |   3   |  3   |      |      |      |      |      |      |
        |  2   | **1** |   3   |   6   |  9   |  9   |      |      |      |      |      |
        |  3   | **1** |   4   |  10   |  19  |  28  |  28  |      |      |      |      |
        |  4   | **1** |   5   |  15   |  34  |  62  |  90  |  90  |      |      |      |
        |  5   | **1** |   6   |  21   |  55  | 117  | 207  | 297  | 297  |      |      |
        |  6   | **1** |   7   |  28   |  83  | 200  | 407  | 704  | 1001 | 1001 |      |
        |  7   | **1** |   8   |  36   | 119  | 319  | 726  | 1430 | 2431 | 3432 | 3432 |
    
      - 通项公式
        $$
        C_{m}(n,k)=\begin{cases}
        \left(\begin{array}{c}
        n+k\\
        k
        \end{array}\right) & \,\,\,0\leq k<m\\
        \\
        \left(\begin{array}{c}
        n+k\\
        k
        \end{array}\right)-\left(\begin{array}{c}
        n+k\\
        k-m
        \end{array}\right) & \,\,\, m\leq k\leq n+m-1\\
        \\
        0 & \,\,\, k>n+m-1
        \end{cases} \\
        其中:n,k \ge 0,m \ge 1
        $$
    
      - 组合意义：$C_m(n,k)$表示有$n$个$+1$和$k$个$-1$排成一排，满足任意前缀和$\ge 1-m$的排列方案数；等价的表示，在已经有$m-1$个$+1$的序列后，追加上述序列使得任意前缀和$\ge 0$的方案数；格路径与反射原理：计算$(0,0) \to (n,k)$不穿过直线$y=x+m-1$或者不接触直线$y=x+m$的每步只能向右或向上走单位距离的格路径条数，其打破限制的坏的排列一一对应于$(-m,m) \to (n,k)$的路径。由于$1-m \le 0$，若需要前缀和$\ge$一个正数，这显然没有方案，但是若允许前几项除外，则可以删去前几项，转化为之前的类型，这是惯用的伎俩。
    
      - 一个随机游走的应用：在一个只由$x,y$两个非负半轴以及第一象限组成的$1/4$平面区域中，从$(k,m) \to (k',m')$随机游走，其中$(k',m')$是坐标轴上的一点($x,y$非负半轴)，每次等概率随机，要么向下走一步，要么向左上走一步，要求中途不能走到坐标轴上的点，到达终点的概率为$\large P_{hit}^{k,m}(k',m')$，则有：
        $$
        \large 
        P_{h i t}^{k, m}\left(k^{\prime}, 0\right)=\left(\frac{1}{2}\right)^{2 k+m-2 k^{\prime}} C_{1}\left(k+m-k^{\prime}-1, k-k^{\prime}\right) , k' \in [1,k]\\
        \large 
        P_{h i t}^{k, m}\left(0, m^{\prime}\right)=\left(\frac{1}{2}\right)^{2 k+m-m^{\prime}} C_{m}\left(k-1, m+k-m^{\prime}\right),m' \in [2,k+m]
        $$
        ![catalan_6](\pic\数学\catalan_6.JPG)
    
      - 一类多重和式的应用：若序列$f(i)$已知，计算以下和式：
        $$
        \large S=\sum_{j_1=1}^m\sum_{j_2=1}^{j_1+1}\sum_{j_3=1}^{j_2+1}\dots\sum_{j_{n-1}=1}^{j_{n-2}+1}\sum_{j_n=1}^{j_{n-1}+1}f(j_n)\\
        \large
        =\sum_{j=1}^{m+n-1}C_m(n-1,m+n-1-j)f(j)
        $$
        这是一个卷积形式，其系数为$m$阶卡特兰梯形中$n-1$行；若求和的上指标没有$+1$，或者是$-1$，则显然系数为两类组合数
    
    - 正数方向的扩展：$n$个$+(m-1)$和$r$个$-1$排成一排，求使得任意前缀和$\ge 0$的方案数，其中$m \ge 2$，令为方案数$\begin{Bmatrix} n \\ r \end{Bmatrix}_{m-1}$，在所有的方案中，不符合要求的方案数为$\left \langle \begin{matrix} n \\ r \end{matrix} \right \rangle_{m-1}$。主要结论：
      $$
      基本递推式：\\
      \begin{Bmatrix} n \\ r \end{Bmatrix}_{m-1}=\begin{Bmatrix} n-1 \\ r \end{Bmatrix}_{m-1}+\begin{Bmatrix} n \\ r-1 \end{Bmatrix}_{m-1},1<r<n \\
      \begin{Bmatrix} n \\ (m-1)n \end{Bmatrix}_{m-1}=\begin{Bmatrix} n \\ (m-1)n-1 \end{Bmatrix}_{m-1}=\begin{Bmatrix} n \\ (m-1)n-2 \end{Bmatrix}_{m-1}\\=\dots=\begin{Bmatrix} n \\ (m-1)n-(m-1) \end{Bmatrix}_{m-1}\\
      特殊结论：\\
      \begin{Bmatrix} n \\ (m-1)n \end{Bmatrix}_{m-1}=\frac{1}{(m-1)n+1} \binom{mn}{n} \\
      通项公式(非闭)：\\
      \begin{Bmatrix} n \\ r \end{Bmatrix}_{m-1}=\binom{n+r}{r}-\left\langle\begin{array}{c}{ n} \\ {r}\end{array}\right\rangle_{m-1} \\
      \left\langle\begin{array}{c}{ n} \\ {r}\end{array}\right\rangle_{m-1}=\sum_{k=0}^{\left \lceil \frac{r}{m-1}\right \rceil-1} \frac{1}{(m-1) k+1}\left(\begin{array}{c}{m k} \\ {k}\end{array}\right)\left(\begin{array}{c}{n+r-m k-1} \\ {n-k}\end{array}\right) \\
      $$
      若令$m=2$即得到上述稍微普通的问题版本
    
  - $Eulerian \space Number$   [维基](https://en.wikipedia.org/wiki/Eulerian_number#Eulerian_numbers_of_the_second_kind)
  
    - 一些定义
      $$
      [n]:=\{1,2,\cdots,n\}\\
      w \in S_n表示w是一个[n]的排列\\
      Des(w):=\{i:w(i)>w(i+1)\}\\
      des(w):=|Des(w)|表示w的下降数\\
      同理，Asc(w),asc(w)表示上升\\
      \left\langle\begin{array}{c}{ n} \\ {k}\end{array}\right\rangle=A(n,k):=|\{w \in S_n:des(w)=k\}|,k \in [0,n)\\
      称之为欧拉数，表示全体定长排列关于下降数的分布，这种分布称之为:Eulerian \space Distribution\\
      $$
    
  - 递推式
      $$
      \left\langle\begin{array}{l}{ n} \\ {k}\end{array}\right\rangle=(n-k)\left\langle\begin{array}{l}{ n-1} \\ {k-1}\end{array}\right\rangle+(k+1)\left\langle\begin{array}{c}{ n-1} \\ {k}\end{array}\right\rangle,k \ge 0,n>0
      $$
    
  - 简易数表
    
  - | *k\n* |  0   |  1   |   2   |   3   |   4    |   5   |   6   |  7   |  8   |
      | :---: | :--: | :--: | :---: | :---: | :----: | :---: | :---: | :--: | :--: |
      |   1   |  1   |      |       |       |        |       |       |      |      |
      |   2   |  1   |  1   |       |       |        |       |       |      |      |
      |   3   |  1   |  4   |   1   |       |        |       |       |      |      |
      |   4   |  1   |  11  |  11   |   1   |        |       |       |      |      |
      |   5   |  1   |  26  |  66   |  26   |   1    |       |       |      |      |
      |   6   |  1   |  57  |  302  |  302  |   57   |   1   |       |      |      |
      |   7   |  1   | 120  | 1191  | 2416  |  1191  |  120  |   1   |      |      |
      |   8   |  1   | 247  | 4293  | 15619 | 15619  | 4293  |  247  |  1   |      |
      |   9   |  1   | 502  | 14608 | 88234 | 156190 | 88234 | 14608 | 502  |  1   |
    
  - 欧拉多项式与一些恒等式
    
    - $  Eulerian \space polynomials  $定义
        $$
        S_{n}(t)=A_n(t)=\sum_{w \in S_{n}} t^{\operatorname{des}(w)}=\sum_{k=0}^{n-1}\left\langle\begin{array}{l}{ n} \\ {k}\end{array}\right\rangle t^{k}\\
        S_0(t)=S_1(t) = 1\\
        S_2(t) = 1 + t\\
        S_3(t) = 1 + 4t + t^2\\
        S_4(t) =1 + 11t + 11t^2 + t^3
        $$
    
    - 一些恒等式和欧拉数通项公式
        $$
        多项式递推式：\\
        S_{n+1}(t) = (1 + nt)S_n(t) + t(1 − t)S_n'(t)\\
        S_{n}(t)=(1-t)^{n+1} \sum_{k \geq 0}(k+1)^{n} t^{k}\\
        (k+1)^{n}=\sum_{i=0}^{n-1}\left\langle\begin{array}{c}{ n} \\ {i}\end{array}\right\rangle\left(\begin{array}{c}{k+n-i} \\ {n}\end{array}\right)\\
        通项公式：\\
        \left\langle\begin{array}{c}{ n} \\ {k}\end{array}\right\rangle=\sum_{i=0}^{k}(-1)^{i}(k+1-i)^{n}\left(\begin{array}{c}{n+1} \\ {i}\end{array}\right),k \in [0,n]\\
        例如当k=n时：\sum_{i=0}^n\binom{n}{i}(n-i)^{n-1}(-1)^i=0\\
        多项式卷积递推式：\\
        S_{n}(t)=S_{n-1}(t)+t \sum_{i=0}^{n-2}\left(\begin{array}{c}{n-1} \\ {i}\end{array}\right) S_{i}(t) S_{n-1-i}(t),n>0\\
        定义二元生成函数S(t,z):\\
        S(t, z):=\sum_{n \geq 0} S_{n}(t) \frac{z^{n}}{n !}=\sum_{n, k \geq 0}\left\langle\begin{array}{l}{ n} \\ {k}\end{array}\right\rangle t^{k} \frac{z^{n}}{n !}\\
        微分方程形式：\\
        \frac{d}{d z} S(t, z)=S(t, z)+t S(t, z)(S(t, z)-1))\\
        解得二元生成函数：\\
        S(t, z)=\frac{t-1}{t-e^{z(t-1)}}\\
        其他恒等式：\\
        \sum_{m=0}^{n-1}A(n,m)=n!,n \ge 1\\
        \sum_{m=0}^{n-1}(-1)^{m}A(n,m)=\frac{2^{n+1}(2^{n+1}-1)B_{n+1}}{n+1},n \ge 1\\
        其中B_n指Bernoulli 数\\
        \sum_{m=0}^{n-1}(-1)^m\frac{A(n,m)}{\binom{n-1}{m}}=0,n \ge 2\\
        \sum_{m=0}^{n-1}(-1)^m\frac{A(n,m)}{\binom{n}{m}}=(n+1)B_{n},n \ge 2\\
        $$
    
    - 极限与积分公式
        $$
        \frac{e}{1-ex}=\sum_{n=0}^\infty\frac{A_n(x)}{n!(1-x)^{n+1}}\\
        可用于计算一些概率期望极限问题\\
        \int_0^1 \cdots \int_0^1 \left(\left\lfloor x_1 + \cdots + x_n\right\rfloor==k\right) dx_1 \cdots dx_n=\frac{A(n,k)}{n!}=\frac{1}{n!}\left\langle\begin{array}{c}{ n} \\ {k}\end{array}\right\rangle\\
        \int_0^1 \cdots \int_0^1 \left(\left\lceil x_1 + \cdots + x_n\right\rceil==k\right) dx_1 \cdots dx_n=\frac{A(n,n-k)}{n!}=\frac{1}{n!}\left\langle\begin{array}{c}{ n} \\ {n-k}\end{array}\right\rangle\\
        可计算一些与连续型随机变量和的下取整有关的复杂积分\\
        \int_0^1 \cdots \int_0^1 f\left(\left\lfloor x_1 + \cdots + x_n\right\rfloor\right) dx_1 \cdots dx_n \\
        = \sum_{k=0}^{n} f(k)\int_0^1 \cdots \int_0^1 \left(\left\lfloor x_1 + \cdots + x_n\right\rfloor==k\right) dx_1 \cdots dx_n\\
        =\sum_{k=0}^{n} A(n, k) \frac{f(k)}{n!}\\
        \int_0^1 \cdots \int_0^1 f\left(\left\lceil x_1 + \cdots + x_n\right\rceil\right) dx_1 \cdots dx_n=\sum_{k=0}^{n} A(n, k) \frac{f(n-k)}{n!} \\
        $$
        
        积分计算公式的扩展与复杂度：
        $$
        我们考虑扩展这个积分的计算：\\令变上限积分F(X_1,X_2,\cdots,X_n)=\int_0^{X_1} \cdots \int_0^{X_n} f\left(\left\lfloor x_1 + \cdots + x_n\right\rfloor\right) dx_1 \cdots dx_n,X_i \in N_+\\令S=\sum_{i=1}^nX_i,s=\sum_{i=1}^nx_i,注意总是上下文符号表示\\令p_{下}(k)=\int_0^{X_1} \cdots \int_0^{X_n} [\lfloor s \rfloor ==k] dx_1 \cdots dx_n\\p_{下}(k)=\sum_{p_1=0}^{X_1-1}\sum_{p_2=0}^{X_2-1}\cdots\sum_{p_n=0}^{X_n-1}\int_{0}^1\int _0^1\cdots \int_0^1[ \sum_{i=1}^np_i+ \lfloor s \rfloor ==k  ]dx_1dx_2\cdots dx_n \\=\sum_{P+Q=k\\P \ge 0,Q\in [0,n]} \left( \left( \sum_{p_1+p_2+\cdots+p_n=P\\ \quad p_i \in [0,X_i-1]}1 \right) \left( \int_{0}^1\int _0^1\cdots \int_0^1[\lfloor s \rfloor =Q]dx_1dx_2\cdots dx_n \right) \right) \\故p_{下}(k)=\sum_{P+Q=k\\P \ge 0,Q\in [0,n]}  H(n,P,\overrightarrow{X}) \frac{A(n,Q)}{n!} \\
        F=\sum_{k=0}^Sf(k)p_{下}(k)\\
        这里H(n,P,\overrightarrow{X})表示p_1+p_2+\cdots+p_n=P,p_i \in [0,X_i-1]不定方程整数解个数
        $$
        
        $$
        若下取整改成上取整，只需改变p(k)而H不变：\\令变上限积分G(X_1,X_2,\cdots,X_n)=\int_0^{X_1} \cdots \int_0^{X_n} f\left(\left\lceil x_1 + \cdots + x_n\right\rceil\right) dx_1 \cdots dx_n,X_i \in N_+\\p_{上}(k)=\sum_{P+Q=k\\P \ge 0,Q\in [0,n]}  H(n,P,\overrightarrow{X}) \frac{A(n,n-Q)}{n!} \\G=\sum_{k=0}^Sf(k)p_{上}(k)\\
        $$
        
        $$
        考虑计算复杂度：若X_i<m\\
        预处理H(n,P,\overrightarrow{X})，有O(nm)个值，每个需要二进制容斥O(2^n)\\
        注意可以状压计算子集上界和，故复杂度O(nm2^n)\\
        计算p(k)以及合并答案：O(n^2m)
        $$
        
        $$
        考虑积分上界的特殊情况：X_1=X_2=\cdots=X_n=m\\H(n,P,\overrightarrow{X})=h(n,P,m)=\sum_{t=0}^n\binom{n}{t}(-1)^t \binom{P+n-t \cdot m-1}{n-1}\\故H只需要O(n^2m)预处理，整个算法复杂度O(n^2m)\\
        注意若积分公式中，变量的下界不为0，而是别的正整数，\\
        只需要适当修改H的预处理即可，其他部分不变
        $$
        
        
        

【139】$Dirichlet \space series$相关

- 定义
  $$
  令F(s)=\sum_{n=1}^{+\infin}\frac{f_n}{n^s}\\
  表示序列f的Dirichlet级数\\
  我们使用大写字母表示级数，小写字母表示序列，序列可看成函数即f_n=f(n)\\
  f'(n),f^{-1}(n)表示导序列和逆序列的第n项，不表示元素的逆元，即f^{-1}(1) \ne (f(1))^{-1}\\
  使用\cdot表示序列的点积，使用\circ表示序列的狄利克雷卷积，使用*或者省略表示级数的乘积\\
  $$

- 补充定义
  $$
  完全积性：f(xy)=f(x)f(y)\\
  完全加性：f(xy)=f(x)+f(y),f(x^k)=kf(x)\\
  \log(n)函数：表示任意\log(1)=0且满足完全加性的数论函数，如n的质因子个数或者和等\\
  Von \space Mangoldt \space function\\
  \Lambda(n) = \begin{cases} \log p & \text{if }n=p^k \text{ for some prime } p \text{ and integer } k \ge 1, \\ 0 & \text{otherwise.} \end{cases}\\
  如果这里\log(p)选用新定义表示质因子个数，则\log(p)=1\\
  \log=\Lambda \circ I，即\log(n)=\sum_{d|n}\Lambda(d)\\
  故由莫比乌斯反演：\Lambda=\log \circ \mu，即\Lambda(n)=\sum_{d|n}\log(n/d)\mu(d)=-\sum_{d|n}\mu(d)\log(d)\\
  \log \zeta(s)=\sum_{n=2}^\infty \frac{\Lambda(n)}{\log(n)}\,\frac{1}{n^s}\\
  \frac {\zeta^\prime(s)}{\zeta(s)} = -\sum_{n=1}^\infty \frac{\Lambda(n)}{n^s}
  $$

- 基本运算与性质

  - $+/-/*/\cdot/\circ$
    $$
    */\circ对+满足分配率：\\
    a \circ(b+c)=a \circ b + a \circ c \\
    f是完全积性函数，\cdot 对 \circ 满足分配率\\
    f \cdot (g \circ h)=(f \cdot g) \circ (f \cdot h)\\
    $$

  - 卷积$\circ$求逆
    $$
    f \circ g=e,g=f^{-1}\\
    g(n) \ = \left( [n=1]-\mathop{\sum_{d\,\mid \,n}}_{d < n}
    f\left(\frac{n}{d}\right) g(d) \right)(f(1))^{-1}\\
    总复杂度O(nlogn)\\
    基本性质:\\
    f(1) \ne 0，则f存在Dirichlet逆f^{-1}\\
    若f是积性的，f^{-1}仍然积性\\
    (f\circ g)^{-1}=f^{-1} \circ g^{-1}\\
    积性函数f是完全积性的，其充要条件：f^{-1}(n)=\mu(n)f(n)\\
    注意：完全积性函数f(1)=f^{-1}(1)=1\\
    f完全积性，g(1) \ne 0，(f \cdot g)^{-1}=f \cdot g^{-1}\\
    对于任意函数f，f^{-1}(1)=(f(1))^{-1}，f(1) \ne 0
    $$

- 复杂运算

  - 求导
    $$
    F(s) =\sum_{n=1}^\infty \frac{f(n)}{n^s}\\
    导数定义：注意负号可不加，只是加上比较符合函数形式\\
    F'(s) =-\sum_{n=1}^\infty \frac{f(n)\log(n)}{n^s}\\
    即f'(n)=f(n)\log(n),n \ge 1\\
    复杂度O(n)\\
    注意：求导定义要求f'(1)=0，因此若\log(1)\ne 0，必须强制将常数项置0\\
    
    导数满足性质：\\
    (F * G)'=F' * G +F * G' \\
    (F^k)'=kF^{k-1}F', k\ge 1\\
    
    如果f是完全积性的，则:\\
    
    \frac {F^\prime(s)}{F(s)} = - \sum_{n=1}^\infty \frac{f(n)\Lambda(n)}{n^s}\\
    证明：\\
    \left[ n^{-s} \right]\frac {F^\prime(s)}{F(s)} = (f' \circ f^{-1})(n) = ((f \cdot \log) \circ f^{-1})(n)\\
    由于f完全积性，f^{-1}(n)=\mu(n)f(n)且\cdot 对 \circ满足分配率\\
    上式=((f \cdot \log) \circ (f \cdot \mu))(n)=(f \cdot (\log \circ \mu))(n)\\
    =(f \cdot \Lambda)(n)=f(n)\Lambda(n)
    $$

    $$
    因此：若f完全积性，f(1)=1；可以通过h(n):=f(n)\Lambda(n)从F计算F'/F；\\
    通过f(n):=g(n)/\Lambda(n)从F'/F计算F，注意只能先计算n为质数幂次的，\\
    再根据f是完全积性，计算剩余位置的值，f(1)=1，时间复杂度O(n)
    $$

    $$
    若f不是完全积性的，f(1) \ne 0，显然f^{-1}(1)=(f(1))^{-1}\\
    从F计算F'/F：按照展开定义暴力计算f'和f^{-1}，再做卷积，总复杂度O(nlogn)；\\
    从F'/F计算F：h(n)=(f' \circ f^{-1})(n)=\sum_{d|n}f(d) \log(d) f^{-1}(n/d)\\
    故f(n)=\frac{h(n)-\sum_{d|n且1<d<n}f(d) \log(d) f^{-1}(n/d)}{\log(n)f^{-1}(1)},n \ge 2\\
    首先h(1)必须为0，否则报错；\\
    每次计算一个f(n)，随即计算f^{-1}(n)，总复杂度O(nlogn)
    $$

  - 积分
    $$
    定义Int(F(s))=G(s)，g(n)=f(n)/log(n),n \ge 2 \\
    定义g(1)=0\\
    复杂度O(n)
    $$

  - 级数$\log$
    $$
    定义 \log(F(s))=Int \left(\frac{F'(s)}{F(s)} \right)+\log(f(1))，其中\log(f(1))常为0\\
    满足\log(F * G)=\log(F)+\log(G), \log(F^k)=k \log(F)\\
    计算方法：根据F计算F'/F，然后积分，复杂度O(n)
    $$

  - 级数$\exp$
    $$
    定义\exp(F(s))=\sum_{k \ge 0}\frac{F(s)^k}{k!}\\
    满足\exp(F+G)=\exp(F) * \exp(G) \\
    \log(\exp(F))=\exp(\log(F))=F \\
    计算方法：令G=\exp(F)，则F=\log (G)=Int(\frac{G'}{G}) \\
    首先g(1)=\sum_{k \ge 0}\frac{f(1)^k}{k!}=e^{f(1)}>0，判断f(1)若不为0，报错(整数域无解)；令g(1)=1\\
    故G'/G=F'为已知的，且g(1)=1,由此计算出G，时间复杂度O(nlogn)\\
    注意F'常数项已经为0，所以无论f(1)取何值，\exp(F)有唯一实数域解
    $$

  - 序列生长操作
    $$
    令F(s)=\sum_{n \ge 1}\frac{f(n)}{n^s}表示序列\{f(n)\}的Dirichlet级数\\
    则F(s-1)=\sum_{n \ge 1}\frac{f(n)}{n^{s-1}}=\sum_{n \ge 1}\frac{nf(n)}{n^{s}}\\
    表示序列\{nf(n)\}的Dirichlet级数\\
    故级数函数的右移位算子对应于序列的生长操作
    $$

  - 级数乘方
    $$
    令G=F^k，则\log(G)=k\log(F)\\
    亦即G=\exp(k \log(F))\\
    时间复杂度O(nlogn)\\
    当然若使用多项式快速幂，则复杂度为O(nlognlogk)
    $$

  - 级数开方
    $$
    令G=F^{1/k}，即F=G^k，则\log(F)=k \log(G)\\
    亦即G=\exp(\frac{1}{k}\log(F))\\
    时间复杂度O(nlogn)\\
    当然也可以直接使用容斥递推，复杂度与实现较细碎
    $$
    












##【题目：数论】

1.http://www.lydsy.com/JudgeOnline/problem.php?id=1041

2.http://www.lydsy.com/JudgeOnline/problem.php?id=1406

3.http://www.lydsy.com/JudgeOnline/problem.php?id=1951

4.http://www.lydsy.com/JudgeOnline/problem.php?id=3501

5.http://www.lydsy.com/JudgeOnline/problem.php?id=3884

6.http://www.lydsy.com/JudgeOnline/problem.php?id=2976

7.http://www.lydsy.com/JudgeOnline/problem.php?id=1876

8.http://www.lydsy.com/JudgeOnline/problem.php?id=1876

9.http://www.lydsy.com/JudgeOnline/problem.php?id=4373

10.http://www.lydsy.com/JudgeOnline/problem.php?id=4454

11.http://www.lydsy.com/JudgeOnline/problem.php?id=4488

12.http://www.lydsy.com/JudgeOnline/problem.php?id=4522

13.http://www.lydsy.com/JudgeOnline/problem.php?id=2721

14.http://www.lydsy.com/JudgeOnline/problem.php?id=2186

15.http://www.lydsy.com/JudgeOnline/problem.php?id=4544

16.http://www.lydsy.com/JudgeOnline/problem.php?id=2401

17.http://www.lydsy.com/JudgeOnline/problem.php?id=3601

18.http://www.lydsy.com/JudgeOnline/problem.php?id=2219

注：离散对数解高次同余方程模板，本题要求模数取奇数，详细分析过程参见网上题解或者上面知识点笔记

19.http://www.lydsy.com/JudgeOnline/problem.php?id=4176

20.http://www.lydsy.com/JudgeOnline/problem.php?id=4772

21.http://www.lydsy.com/JudgeOnline/problem.php?id=2277

22.http://www.lydsy.com/JudgeOnline/problem.php?id=1968

23.http://www.lydsy.com/JudgeOnline/problem.php?id=4635

24.http://www.lydsy.com/JudgeOnline/problem.php?id=4173

25.http://www.lydsy.com/JudgeOnline/problem.php?id=2818

//阅读一些积性函数求和的资料
http://blog.csdn.net/skywalkert/article/details/50500009

26.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1244

27.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1239

28.http://acm.hdu.edu.cn/showproblem.php?pid=5608

29.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1584

30.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1220

31.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1222

32.http://www.spoj.com/problems/DIVCNT2/

33.http://tsinsen.com/A1231

34.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1227

35.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1237

36.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1238

37.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1847

38.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1575

39.http://www.spoj.com/problems/DIVCNT3/

40.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=5340

41.http://www.lydsy.com/JudgeOnline/problem.php?id=3512

42.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3881

43.http://www.lydsy.com/JudgeOnline/problem.php?id=2693

44.http://www.lydsy.com/JudgeOnline/problem.php?id=2749

45.http://www.lydsy.com/JudgeOnline/problem.php?id=3930

46.http://www.lydsy.com/JudgeOnline/problem.php?id=2142

47.http://www.lydsy.com/JudgeOnline/problem.php?id=2629

注：$lucas$定理+$fft$+离散对数+高精度+分类讨论

一道不难且不错的题目，给定：质数$p=51061$，$n<p^{k}$，$k=10$

求组合数第$n$行关于模数$p$的分布，即给出$cnt[i]$表示余数恰好为$i$的元素个数

由于$n$为大整数且$p$不大，故联想到$lucas$定理，将$n$拆为$p$进制数$n_tn_{t-1}\cdots n_0$

则有：$\binom{n_t}{k_t}\binom{n_{t-1}}{k_{t-1}}\cdots \binom{n_0}{k_0}=i\pmod{p}$

由于$\binom{n_j}{k_j}=\frac{n_j!}{k_j!(n_j-k_j)!}$，故显然可以$O(p)$复杂度求其关于模$p$的分布(假设有$q$个$p$进制为，预处理复杂度显然为$O(q*p)$)

揉入上式，即得到一个狄利克雷循环卷积，利用离散对数转化为，普通循环和卷积，之后$fft$

注意答案中$0$这种情况可以特殊考虑，因为$0$元素没有离散对数，与$lucas$结合也很容易变为数位$dp$

事实上，只要简单容斥一下，即用总数$n+1$减去其余情况数量之和即可；而余数不为$0$的和也等于$\prod_{i=0}^t(n_i+1)$

另外注意，本题虽然结果模$29$，但是$10$重卷积，$fft$不特殊处理可能仍然溢出

48.http://www.lydsy.com/JudgeOnline/problem.php?id=3992

注：比较基础的离散对数，化狄利克雷循环卷积为普通循环卷积，基础的生成函数用到多项式循环乘方，由于空间开不下，还是牺牲一个$log$复杂度用快速幂好，注意每次循环叠加清空

49.http://www.lydsy.com/JudgeOnline/problem.php?id=4128

注：经典的矩阵同余方程(A模p意义下一定要可逆)，一般情况是不大容易解的，数据保证$p$以内有解；利用$BSGS$的分块思想，随机向量判矩阵相等$A=B\times C$的$hash$思想

50.http://www.lydsy.com/JudgeOnline/problem.php?id=2480

51.http://www.lydsy.com/JudgeOnline/problem.php?id=1420

52.http://www.lydsy.com/JudgeOnline/problem.php?id=3527

53.http://www.lydsy.com/JudgeOnline/problem.php?id=2194

54.http://www.lydsy.com/JudgeOnline/problem.php?id=2179

55.http://www.lydsy.com/JudgeOnline/problem.php?id=3456

56.http://www.lydsy.com/JudgeOnline/problem.php?id=3557

57.http://www.lydsy.com/JudgeOnline/problem.php?id=3160

58.http://www.lydsy.com/JudgeOnline/problem.php?id=3771

59.http://www.lydsy.com/JudgeOnline/problem.php?id=4555

60.http://acm.hdu.edu.cn/showproblem.php?pid=5322

61.http://acm.hdu.edu.cn/showproblem.php?pid=5896

62.http://acm.hdu.edu.cn/showproblem.php?pid=5730

63.http://acm.hdu.edu.cn/showproblem.php?pid=3634

64.http://acm.hdu.edu.cn/showproblem.php?pid=5279

65.http://acm.hdu.edu.cn/showproblem.php?pid=5126

66.http://acm.hdu.edu.cn/showproblem.php?pid=1402

67.http://acm.hdu.edu.cn/showproblem.php?pid=5197

68.http://acm.hdu.edu.cn/showproblem.php?pid=5751

69.http://acm.hdu.edu.cn/showproblem.php?pid=3864

70.http://acm.hdu.edu.cn/showproblem.php?pid=3939

71.http://acm.hdu.edu.cn/showproblem.php?pid=6211

72.http://acm.hdu.edu.cn/showproblem.php?pid=2815

73.http://acm.hdu.edu.cn/showproblem.php?pid=1320

74.http://acm.hdu.edu.cn/showproblem.php?pid=2522

75.http://acm.hdu.edu.cn/showproblem.php?pid=2814

76.http://acm.hdu.edu.cn/showproblem.php?pid=6034

77.http://www.lydsy.com/JudgeOnline/problem.php?id=3301

78.http://www.lydsy.com/JudgeOnline/problem.php?id=3143

79.http://www.lydsy.com/JudgeOnline/problem.php?id=3118

80.http://www.lydsy.com/JudgeOnline/problem.php?id=4269

81.http://www.lydsy.com/JudgeOnline/problem.php?id=2844

82.http://www.lydsy.com/JudgeOnline/problem.php?id=1778

83.http://www.lydsy.com/JudgeOnline/problem.php?id=1770

84.http://www.lydsy.com/JudgeOnline/problem.php?id=3817

85.http://poj.org/problem?id=2987

86.http://www.lydsy.com/JudgeOnline/problem.php?id=2705

87.http://www.lydsy.com/JudgeOnline/problem.php?id=2694

88.http://www.lydsy.com/JudgeOnline/problem.php?id=4820

89.http://www.lydsy.com/JudgeOnline/problem.php?id=1101

90.http://poj.org/problem?id=2154

91.http://www.lydsy.com/JudgeOnline/problem.php?id=1407

92.http://www.lydsy.com/JudgeOnline/problem.php?id=3782

93.http://www.lydsy.com/JudgeOnline/problem.php?id=1951

94.http://acm.hdu.edu.cn/showproblem.php?pid=1573

95.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1028

96.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1348

97.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1514

98.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1387

99.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1172

100.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1258

101.http://www.lydsy.com/JudgeOnline/problem.php?id=3684

102.http://www.lydsy.com/JudgeOnline/problem.php?id=4735

103.http://www.lydsy.com/JudgeOnline/problem.php?id=4911

104.http://www.lydsy.com/JudgeOnline/problem.php?id=4504

105.http://www.lydsy.com/JudgeOnline/problem.php?id=4589

106.http://codeforces.com/problemset/problem/449/D

107.http://codeforces.com/contest/663/problem/E

108.http://acm.hdu.edu.cn/showproblem.php?pid=5823

109.http://acm.hdu.edu.cn/showproblem.php?pid=6057

110.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1773

111.http://acm.hdu.edu.cn/showproblem.php?pid=5909

112.http://www.spoj.com/problems/VECTAR1/

113.http://www.spoj.com/problems/TSUM/en/

114.http://www.spoj.com/problems/VFMUL/

115.http://www.ifrog.cc/acm/problem/1028

116.http://codeforces.com/gym/101480    //F题

117.http://poj.org/problem?id=2389

118.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3899

119.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3874

120.http://codeforces.com/problemset/problem/901/E

121.http://codeforces.com/problemset/problem/906/D

122.http://codeforces.com/problemset/problem/919/E

123.http://codeforces.com/problemset/problem/920/G

124.http://acm.hdu.edu.cn/showproblem.php?pid=6298

125.https://nanti.jisuanke.com/t/30999

126.https://nanti.jisuanke.com/t/31444

127.https://nanti.jisuanke.com/t/31448

128.https://nanti.jisuanke.com/t/31456

129.http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1965

130.https://loj.ac/problem/6053

131.https://www.spoj.com/problems/DIVCNTK/

132.http://codeforces.com/problemset/problem/1031/F

133.https://www.lydsy.com/JudgeOnline/problem.php?id=5348

134.https://www.lydsy.com/JudgeOnline/problem.php?id=3122

注：经典问题，问一个值在一个线性同余递推数列中的最小出现下标，分类讨论，指数同余，离散对数

135.https://www.lydsy.com/JudgeOnline/problem.php?id=3285

注：基础题，拆开换元后，变成指数同余方程，离散对数

136.http://acm.hdu.edu.cn/showproblem.php?pid=6051

注：离散对数+数论函数求和

题意：令$f(i)$表示方程$(x+y)^i=x^i\pmod{p}$，$p$为质数且$x \in [1,p-1],y \in [1,m]$，给定$m,p$求$\sum_{i=1}^{p-1}if(i)$
$$
两边同取离散对数，得到：\\
ilog_g(x+y)=ilog_gx\pmod{p-1}\\
亦即：log_g(x+y)=log_gx\pmod{\frac{p-1}{gcd(i,p-1)}}\\
故有：log_g(1+\frac{y}{x})=0\pmod{\frac{p-1}{gcd(i,p-1)}}\\
注意：这里的\frac{1}{x}是模p意义下的，不是模那个约数意义下的，指标才是\\
分析1+\frac{y}{x}\ge 2的离散对数的可能取值，[1,p-2]且为那个约数模数的倍数，注意不能取0\\
故1+\frac{y}{x}，亦即\frac{y}{x}有gcd(i,p-1)-1种合法取值，而x\in[1,p-1]相当于循环群全集\\
而y\in[1,m]，限制更强，枚举并固定y，有gcd(i,p-1)-1种不同且合法的x与之对应\\
故：f(i)=m(gcd(i,p-1)-1)
$$
最后的求和是不值一提的，非本题的难点

137.http://acm.hdu.edu.cn/showproblem.php?pid=5478

注：2015上海区域赛真题，不认为是什么好题，可以直接用暴力完美代替离散对数，简单分析如下：

简单说，就是给一个方程对$n\in Z_+$恒成立，由于取$n$为奇数有比较好的性质，故公式可化为：
$$
(k_1n+b)log_ga-(k_2(n-1)+1)log_g(-b)=0\pmod{c-1}\\
令n=1，又可得到：\\
(k_1+b)log_ga-log_g(-b)=0\pmod{c-1}\\
立即解出x，令p=k_1k_2+bk_2-k_1：\\
p(n-1)x=0\pmod{c-1}，n为奇数\\
即：\\
nx=0\pmod{\frac{c-1}{2gcd(p,c-1)}记作p'}，n\in[0,+\infin)，分母的2如果不能整除就不除\\
显然这等价于：x=0\pmod{p'}，也就是只需要check\space O(gcd)级别的x(即a的指标)即可
$$

138.http://acm.hdu.edu.cn/showproblem.php?pid=5377zhu

注：批量$BSGS$，不能直接求离散对数，由于有多个模数，固定之，求以其原根为底的一大组数的离散对数

化为解线性同余方程，注意特殊情况的处理

139.http://acm.hdu.edu.cn/showproblem.php?pid=4861

注：简单的初等数论分析题，令$f(i)=\sum_{x=0}^{p-1}x^i\pmod{p}$，令集合$S=\{f(i),i\in[1,k]\}$，给定$p,k$($p$为质数)，求集合$S$分布；看起来这是等幂和模序列的形式，有经典的公式，但是最好是从原根的角度分析该问题：

令$g$为模$p$原根，因为$[1,p-1]$为模$p$的完系或循环群，故每个元素有唯一的指标，故：$f(i)=\sum_{t=0}^{p-2}(g^i)^t$，若$g^i=1\pmod{p}$为等差数列，即$f(i)=p-1$，$\phi(p)=p-1|i$，这样的$i$在$[1,k]$中显然有$\lfloor\frac{k}{p-1}\rfloor$；否则，由欧拉定理，$f(i)=\frac{1-g^{i(p-1)}}{1-g^i}=0$.

注意：以上公式在一些特殊情况下，如$i=p$，是有更直接的性质的，但是要千万小心小的特例，如$p=2,g=1$情况；这正如在经典的威尔逊定理中，小心$n=4$的情况是不成立的

140.http://acm.hdu.edu.cn/showproblem.php?pid=2619

注：求原根数量，一般的结论中注意原根存在才有$phi(phi(m))$个原根

141.https://ac.nowcoder.com/acm/contest/883/D

注：基础数论分析计数题

142.http://acm.hdu.edu.cn/showproblem.php?pid=6588

注：数论函数求和题
$$
\sum_{i=1}^ngcd(\lfloor\sqrt[3]{i}\rfloor,i)=\sum_{i=1}^n\sum_{d|gcd(\lfloor\sqrt[3]{i}\rfloor,i)}\phi(d)=\sum_{d=1}^{\lfloor\sqrt[3]{n}\rfloor}\phi(d)\sum_{1 \le i \le n \\ d| \lfloor\sqrt[3]{i}\rfloor \\\&\&d|i}1\\
=\sum_{d=1}^{\lfloor\sqrt[3]{n}\rfloor}\phi(d)\sum_{1 \le k \le \lfloor\sqrt[3]{n}\rfloor\\ \&\&d|k}\sum_{d|i \\ 1\le i \le n}[\lfloor\sqrt[3]{i}\rfloor=k]\\
最后一部分等价于求[k^3,min((k+1)^3-1,n)]中的d的倍数的个数\\
=\sum_{d=1}^{\lfloor\sqrt[3]{n}\rfloor}\phi(d)\sum_{1 \le k \le \lfloor\sqrt[3]{n}\rfloor\\ \&\&d|k}(\lfloor\frac{min((k+1)^3-1,n)}{d}\rfloor-\lfloor\frac{k^3-1}{d}\rfloor) \\
时间复杂度O(\sqrt[3]{n}logn)会T，需要进一步优化：\\
注意到：\frac{(k+1)^3-1}{d}=\frac{(k+1)^3-1}{d}=\frac{k}{d}(k^2+3k+3)\\
而：\lfloor\frac{k^3-1}{d}\rfloor=\frac{k^3}{d}-1\\
带入化简求和，可以得到O(\sqrt[3]{n})的公式，同时不超出longlong
$$

143.http://acm.hdu.edu.cn/showproblem.php?pid=6584

注：二分+$SternBrocot$树+莫比乌斯反演+类欧几里得算法

题目求分母不超过$n \le 10^6$的既约分数中数值第$k$小的，保证答案$\in[0,1]$

- 令$k=\frac{p}{q}$，令$f(k)$表示分母不超过$n$的且数值不超过$k$的既约分数个数，即$k$在其中的排名
  $$
  为求f(k)，我们统计分数\frac{j}{i} \le k，等价于j \le ki.\\
  f(k)=\sum_{i=1}^n\sum_{j=1}^{\lfloor ki\rfloor}[gcd(i,j)=1]=\sum_{i=1}^n\sum_{j=1}^{\lfloor ki\rfloor}\sum_{d|i\&\&d|j}\mu(d)=\sum_{d=1}^n\mu(d)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\lfloor ki \rfloor\\
  注意最后一步用到整除函数性质：\lfloor\frac{\lfloor x \rfloor}{c}\rfloor=\lfloor\frac{ x }{c}\rfloor
  $$

- 在$0$和$1$中二分答案$k$，用$f(k)$与题目给的$k’$比较，得到严格小于的最大分数

- $k$带入到$SBT$中求其后继即可

- 另一个算法：直接在$SBT$上游走，从根开始，用排名$f(x)$与题目$k$比较，向左走必定变小，向右走必定变大，只要每次二分一个方向走多少步即可，可以避免使用$\_\_int128$，在树上复杂度大约$log^2$

144.http://acm.hdu.edu.cn/showproblem.php?pid=6607

注：稍复杂的数论函数求和，$min\_25$+杜教筛+等幂和
$$
ret=\sum_{d=1 \& d \in \operatorname{prime}}^{n} d^{k+1} \sum_{i=1}^{n/d} i^{2} \varphi(i)
$$

145.http://acm.hdu.edu.cn/showproblem.php?pid=6605

注：计算路径条数显然用点分治。

将两条路径拼起来，写出方程 $10 ^hx + y \equiv 0 \; (mod \; k)$，这个方程在将所有项同除以 $gcd(10^h, k)$ 下只有一个解。观察到 $k / gcd(10^h, k)$ 只有 log 个，预处理出这 log 个。

复杂度 $O(nlog_2nlog_2k)$ 。

146.https://atcoder.jp/contests/agc003/tasks/agc003_d

注：分解质因子+分析，给定$n$个数$a_i$，求其最大独立集，使得集合中任意两个数乘积不为完全立方数，$n \le 10^5,a_i \le 10^{10}$

对一个数$x$，如果我们将其分解质因子，所有质数的指数对$3$取模，所得的数令为$f(x)$，令$y=f(x)$，将$y$的所有非$0$指数$t_i$设为$3-t_i$，得到一个数$g(y)$，统计$f(x)$的分布，即每种取值有多少个$x$与之对应

我们考虑$f(x)$的分布结构，将数$y$与其对称的数$g(y)$连边，发现只有二元联通块；因此，只要知道$f(x)$的分布，就很容易得到答案

考虑对$x$分解质因数，$\sqrt[3]{x}$以内的质数暴力分解，令剩余$x'$，若$x'=p*q$，则$g(x')=x'^2$，否则$x'=p^2,g(x')=p$，而$f(x')$总是为$x'$，故$O(1)$可处理$x$的剩余部分

147.http://hihocoder.com/problemset/problem/1872

注：难题，圆内整点计数，本元勾股数通项+莫比乌斯函数反演

148.http://acm.hdu.edu.cn/showproblem.php?pid=4794

注：基础题，矩阵$BSGS$算法，求最小的正整数$k$满足$A^k=E(\%n)$，给定$n \le 4 \times 10^9$，矩阵$A=[1,1;1,2]$。直接求出逆矩阵，可以比较方便的使用$BSGS$，最好使用好的哈希表。本题有斐波那契循环节做法。










##【题目：组合】

1.http://www.lydsy.com/JudgeOnline/problem.php?id=1008

2.http://www.lydsy.com/JudgeOnline/problem.php?id=1089

3.http://www.lydsy.com/JudgeOnline/problem.php?id=1227

4.http://www.lydsy.com/JudgeOnline/problem.php?id=2012

5.http://www.lydsy.com/JudgeOnline/problem.php?id=2111

6.http://www.lydsy.com/JudgeOnline/problem.php?id=2729

7.http://www.lydsy.com/JudgeOnline/problem.php?id=3198

8.http://www.lydsy.com/JudgeOnline/problem.php?id=3505

9.http://www.lydsy.com/JudgeOnline/problem.php?id=3622

10.http://www.lydsy.com/JudgeOnline/problem.php?id=4086

11.http://www.lydsy.com/JudgeOnline/problem.php?id=4305

12.http://www.lydsy.com/JudgeOnline/problem.php?id=4403

13.http://www.lydsy.com/JudgeOnline/problem.php?id=1101

14.http://www.lydsy.com/JudgeOnline/problem.php?id=2005

15.http://www.lydsy.com/JudgeOnline/problem.php?id=2154

16.http://www.lydsy.com/JudgeOnline/problem.php?id=2190

17.http://www.lydsy.com/JudgeOnline/problem.php?id=2301

18.http://www.lydsy.com/JudgeOnline/problem.php?id=2671

19.http://www.lydsy.com/JudgeOnline/problem.php?id=2705

20.http://www.lydsy.com/JudgeOnline/problem.php?id=3309

21.http://www.lydsy.com/JudgeOnline/problem.php?id=3529

22.http://www.lydsy.com/JudgeOnline/problem.php?id=3834

23.http://www.lydsy.com/JudgeOnline/problem.php?id=3994

24.http://www.lydsy.com/JudgeOnline/problem.php?id=3944

25.http://www.lydsy.com/JudgeOnline/problem.php?id=1025

26.http://www.lydsy.com/JudgeOnline/problem.php?id=1902

27.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3638

28.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3233

29.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3556

30.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3868

31.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2836

32.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3435

33.http://acm.hdu.edu.cn/showproblem.php?pid=1085

34.http://acm.hdu.edu.cn/showproblem.php?pid=1171

35.http://acm.hdu.edu.cn/showproblem.php?pid=1398

36.http://acm.hdu.edu.cn/showproblem.php?pid=2079

37.http://acm.hdu.edu.cn/showproblem.php?pid=2082

38.http://acm.hdu.edu.cn/showproblem.php?pid=2110

39.http://acm.hdu.edu.cn/showproblem.php?pid=2152

40.http://acm.hdu.edu.cn/showproblem.php?pid=2189

41.http://acm.hdu.edu.cn/showproblem.php?pid=2566

42.http://www.lydsy.com/JudgeOnline/problem.php?id=1488

43.http://www.lydsy.com/JudgeOnline/problem.php?id=1004

44.http://acm.hdu.edu.cn/showproblem.php?pid=2865

45.http://poj.org/problem?id=2888

46.http://acm.hdu.edu.cn/showproblem.php?pid=3923

47.https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1542

48.http://codeforces.com/problemset/problem/914/G

49.http://codeforces.com/problemset/problem/932/E

50.http://codeforces.com/problemset/problem/938/E

51.http://codeforces.com/problemset/problem/955/C

52.http://acm.hdu.edu.cn/showproblem.php?pid=5245

53.http://acm.hdu.edu.cn/showproblem.php?pid=6390

54.http://codeforces.com/problemset/problem/958/F3

[经典]求x1+x2+...xk==n的有上下界的不定方程整数解组数

注：分治fft/启发式合并fft

55.https://www.codechef.com/problems/CUTTREE

56.https://nanti.jisuanke.com/t/31453

57.https://nanti.jisuanke.com/t/31713

58.https://www.lydsy.com/JudgeOnline/problem.php?id=3625

[经典]类卡特兰数列递推，生成函数，多项式开根和求逆

59.https://codeforces.com/problemset/problem/852/F

60.http://codeforces.com/problemset/problem/1045/H

61.https://vjudge.net/contest/274676#problem/J

62.https://vjudge.net/contest/274500#problem/L

63.http://codeforces.com/gym/101955/problem/C

64.http://codeforces.com/gym/101955/problem/M

65.http://codeforces.com/gym/102012/problem/G

66.http://codeforces.com/gym/101981/attachments J题

67.http://codeforces.com/problemset/problem/1091/D

68.http://codeforces.com/problemset/problem/1096/E

69.http://codeforces.com/problemset/problem/1096/G

70.http://codeforces.com/problemset/problem/1097/D

71.http://codeforces.com/problemset/problem/1097/F

注：gcd卷积，二进制(模2)意义下bitset优化，容斥或者莫比乌斯函数反演变换，一些简单的预处理技巧；关于gcd卷积的简单介绍，参见上面的知识点讲解

72.http://codeforces.com/problemset/problem/1097/G

注：树形dp，树上合并式背包，斯特林变换公式，k次幂组合意义，容斥原理

斯特林公式：
$$
n^k=\sum_{i=1}^kS(k,i)*i!*C(n,i)
$$
注意：此公式是转化形如n^k元素的有用途径，当然可以很方便的在公式表中找到

73.http://codeforces.com/problemset/problem/1010/F

注：经典题目，树上多项式合并：树上差分+基础组合+树链剖分+重链上分治+fft/ntt

二叉树，树上每个叶子多项式为x+1，每个中间节点多项式等于儿子多项式乘积*x+1；

重链剖分，重链上每个节点缓存其轻儿子贡献和(*x)，再对重链分治：重链上每个节点等于重儿子+1之后乘自己的多项式，求重链根的多项式，相当于简单的分治法，求以下表达式的值：

$$
a_1(a_2(a_3(a_4+1)+1)+1)=a_1a_2a_3a_4+a_1a_2a_3+a_1a_2+a_1\\

=a_1a_2(a_3a_4+a_3)+a_1a_2+a_1
$$

直接按照项数将表达式一分为二，左边简单提取之后，发现很容易维护二元组(各数乘积f，表达式值g)的合并：

$$
\left\{
\begin{aligned}
f=f_lf_r \\
g=f_lg_r+g_l
\end{aligned}
\right.
$$

时间复杂度是n(logn)^3，树剖、分治、fft各占一个log


74.https://www.lydsy.com/JudgeOnline/problem.php?id=5093

75.http://codeforces.com/problemset/problem/286/E

注：思维题+背包+闭包/线性空间+fft

76.http://codeforces.com/problemset/problem/662/C

注：比较隐蔽的异或卷积模型，已知隐蔽的函数f(x)=x的二进制表示中0和1的个数最小值

求
$$
min \sum_if(a_i \oplus x), x \in [0,2^n)\\

denote: A_i=f(i),B_i=count(i),or that:B_{a_i}++\\

fwt:A \oplus B
$$

77.http://codeforces.com/problemset/problem/632/E

注：简单生成函数+多项式乘方，注意只需要知道最终结果每个系数是否为0，ntt双模数hash思想

78.http://codeforces.com/problemset/problem/827/E

注：求带?的01串的所有可能周期，等价于对周期t，任意i有：a[i]与a[i-kt]不矛盾，fft/ntt可用差卷积求a[i]与a[i-t]的矛盾性，数组ret[t]并上所有t倍数的矛盾性，即ret[kt]即可


79.http://codeforces.com/problemset/problem/715/E

注：考察卷积的组合意义，fft/ntt+容斥/二项式反演+第一类斯特林数


80.http://codeforces.com/problemset/problem/755/G

注：特征根法解行生成函数的递推方程+多项式基本操作(求逆，乘方，开方等)

做法1：

$$
f[i][j]=f[i-1][j]+f[i-1][j-1]+f[i-2][j-1] \\

那么 f[n] 作为行生成函数满足： \\

\begin{array}{l}{f_{n}(x)=f_{n-1}(x)+x f_{n-1}(x)+x f_{n-2}(x)} \\ {=(x+1) f_{n-1}(x)+x f_{n-2}(x)}\end{array}\\

f_{i}=C_{1} * T 1(x)^{i}+C_{2} * T_{2}(x)^{i}\\

T1和T2为以下特征根方程的两根：\\

T^{2}(x) - (x+1)T(x) - x = 0\\

\triangle=x^2+6x+1\\

T_{1}(x)=\frac{1+x+\sqrt\triangle}{2}\\

T_{2}(x)=\frac{1+x-\sqrt\triangle}{2}\\

已知:\\

f_0=C_1+C_2=1\\

f_1=C_1*T_1+C_2*T_2=1+x\\

故：\\

C_1=\frac{T_2-(1+x)}{T_2-T_1}\\

C_2=\frac{T_1-(1+x)}{T_1-T_2}\\

注意到，由韦达定理：\\

T_1+T_2=-\frac{b}{a}=1+x\\

T_2-T_1=\sqrt\triangle\\

故：\\

C_1=\frac{T_1}{\sqrt\triangle}\\

C_2=-\frac{T_2}{\sqrt\triangle}\\

则：\\

\large f_n=\frac{T_1^{n+1}-T_2^{n+1}}{\sqrt\triangle}\\

由于：T_2常数项为0，故T_2^{n+1}最低次超过n\\

故：只需计算f_n=\frac{T_1^{n+1}}{\sqrt\triangle}\\
$$

做法2：多项式倍增



81.http://codeforces.com/problemset/problem/1119/H

注：取值稀疏的特殊情况下，多重异或卷积的fwt优化

fwt原理/性质+特殊值法构造方程组

题目：若干个数组求其多重异或卷积，每个数组由一个三元组(a,b,c)构造，表示T[a]=x,T[b]=y,T[c]=z,(x,y,z)对所有数组相同且题目给定

关键点1：一步转化，如果直接对某个数组T做fwt变换后，所有下标均被填上值，且值的种类最多8种

而如果我们对元祖$(a,b,c)$进行变换$(0,b\oplus a,c \oplus a)$，此步操作相等于对数组做一个异或卷积，卷积数组为$P$($P[a]=1$,其余为$0$)，最终将结果还原回来即可（数组下标变换异或$X=$所有$a$的异或和）

此步转化，将fwt后的值的种类减少为最多4种

这4种值固定为：

$$
v_1=x+y+z\\

v_2=x+y-z\\

v_3=x-y+z\\

v_4=x-y-z\\
$$

关键点2：考虑fwt的如下性质：

$$
fwt(A+B)=fwt(A)+fwt(B)\\

fwt(A \circ B)=fwt(A)*fwt(B)\\

考虑将所有数组fwt之后相乘，下标j的结果p中包含A_j个v_1，B_j个v_2，C_j个v_3，D_j个v_4\\

故：A_j*v_1+B_j*v_2+C_j*v_3+D_j*v_4=p\\

即：\\

A_j*(x+y+z)+B_j*(x+y-z))+C_j*(x-y+z)+D_j*(x-y-z)=p\\

整理为：\\

x*(A_j+B_j+C_j+D_j)+y*(A_j+B_j-C_j-D_j)+Z*(A_j-B_j+C_j-D_j)=p\\

注意这里是x，y，z不局限于题目读入的数据，可以带入任意的整数：\\

考虑任意三元组都可以分拆为单位向量的线性组合，故我们取单位向量带入：\\

A_j+B_j+C_j+D_j=a\\

A_j+B_j-C_j-D_j=b\\

A_j-B_j+C_j-D_j=c\\

还少一个方程，但是线性空间已经用完，需要挖掘一个新的：\\

我们考虑取：对于元祖(a,b,c)，取T[b xor c]++\\

fwt(\sum_{i=1}^{n}T_i)=fwt(\sum_{i=1}^{n}P_i\circ Q_i)\\

=\sum_{i=1}^{n}fwt(P_i\circ Q_i)=\sum_{i=1}^{n}fwt(P_i)fwt(Q_i)\\

考虑两个数组P和Q，第一个只有y=1(b xor a)，第二个只有z=1(c xor a)，二者分别fwt：\\

任意位置都是+-1，b xor c得到的数组，等于这两个的卷积，那么fwt之后，就是对应位置的乘积\\

观察v_1,v_2,v_3,v_4的构造，取x=0,发现y=1和z=1交换时，v_2和v_3会变号，v_1和v_4不变号，\\

因而新的值v和旧的值v二者相乘，中间两个数变为-1，故B_j和C_j是乘-1，其余两个乘1，故得到：\\

A_j-B_j-C_j+D_j=d\\

逐位解方程，快速幂计算ret[]之后，UFWT，再下标异或X变换回去即可\\
$$



82.http://codeforces.com/problemset/problem/528/D

注：预处理+fft/ntt，预处理每个下标每个字母是否可以放，然后每种字母独立考虑做一次差卷积

83.http://codeforces.com/problemset/problem/993/E

注：01数组，问有多少个区间使得其区间和为k，0<=k<=n，输出n+1个答案

中国剩余定理crt+fft/ntt，答案没有取模，采用两个模数ntt合并

84.https://www.lydsy.com/JudgeOnline/problem.php?id=5478

85.https://www.lydsy.com/JudgeOnline/problem.php?id=5411

86.https://www.lydsy.com/JudgeOnline/problem.php?id=5475

87.https://www.lydsy.com/JudgeOnline/problem.php?id=5330

88.https://www.lydsy.com/JudgeOnline/problem.php?id=5298

89.https://www.lydsy.com/JudgeOnline/problem.php?id=5283

90.https://www.lydsy.com/JudgeOnline/problem.php?id=5221

91.https://www.lydsy.com/JudgeOnline/problem.php?id=5217

92.http://codeforces.com/problemset/problem/754/E

注：二维单模式串匹配问题，模式串带通配符，bitset或者二维fft应用

传统的独立考虑每种字母方法，由于字符集有一定规模，外加fft/ntt常数较大，远远超时；

考虑应用于复数域序列变换的二维fft，对主串中每个元素(字母)，如果不是通配符，填充$e^{i\theta},\theta=2\pi/M*k,k\in[0,M-1]$其中M为字符集大小，k为字符编号，通配符填充复数cp{0,0}

对模式串每个字母，选用$\theta'=-\theta$即可，且统计模式串中非通配符的字符数量tot，考虑与模式串同规模的主串子矩形，与模式串对应做点积，由于通配符与任意字符直接相乘为0，对于两个非通配符字母来说，当且仅当为同种字母时，相乘才为1(否则，乘积的实部一定小于1，只要有一对不匹配，最终结果就一定严格小于tot)，比较点积结果实部是否为tot即可

另外，如果主串也带通配符，那么就应该用两次二维fft，第二次中令模式串和主串的通配符为整数0，其他字母为整数1，这样卷积可以算出每个位置为起点的理应达到的点积整数值(如果匹配成功)，取代原来的全局tot变量，然后逐位相比较即可

其他做法，一个在一维世界中流行的做法：

就是构造一对字符的匹配函数h(x,y)使得当x和y为同种字符函数值取0，其他搭配函数值取正整数值；

构造两个等长字符串(带通配符)的匹配函数H(s,t)意义同上，构造过程为以上函数的对应叠加；考虑快速计算每个位置的匹配函数值，一般反转模式串，将表达式拆开为若干部分，分别做卷积即可

93.https://www.lydsy.com/JudgeOnline/problem.php?id=4503

注：上面这题的一维弱化版本，同样的，仅模式串带通配符

94.http://codeforces.com/problemset/problem/472/G

注：分块+fft，对第一个串分块，预处理每一个块和第二个串整串的差卷积；

技巧：沿用上面这题的思想，考虑将0字符填充为-1,1字符填充为1，那么两个等长序列的匹配数x或者不匹配数y(相同字符数目或者不同字符数目)，可以通过解方程组确定：卷积得到x-y，而x+y为序列长度

思想：主要思想就是单位根，相同字符点积为1，不同为-1，其实1和-1是2次单位复数根

注意：这个题目比较卡时间，暴力压64位或者bitset可能会更快，最好使用fft_fast模板来减少fft的常数，加速其变换过程

95.http://codeforces.com/group/aUVPeyEnI2/contest/243687 G

注：抽屉原理/鸽巢原理+处理gcd



96.http://codeforces.com/problemset/problem/981/H

注：树dp+生成函数+分治fft/ntt+暴力多项式除法+简单容斥

复杂度分析用到：树上子树大小sz[]数组，最多只会有根号种不同取值

一些经典的树上计数问题，常常将路径分为两类，垂直链和非垂直链，分开计算答案，常常维护根到点的信息并

非垂直链可以用使用容斥原理，在垂直链上计算负的贡献



97.http://uoj.ac/problem/272

98.http://codeforces.com/problemset/problem/1103/E

注：k进制FWT模板题，注意模数为$2^{58}$，$long long$可以不取模；当然十进制意义下，用五阶单位根表示数，可以节约一半的时间

99.http://acm.hdu.edu.cn/showproblem.php?pid=4447

100.http://codeforces.com/problemset/problem/1054/H

注：中国剩余定理crt+离散对数与原根+二维狄利克雷循环卷积+小型容斥

狄利克雷循环卷积取离散对数转化为普通循环卷积，循环卷积扩充一倍体积转为普通卷积，二维fft

注意这里循环卷积循环周期不是一个质数，要分解为若干质数独立考虑；

而分解的实质是，对于每个下标$i$，将$i$变换为一个元祖$\overrightarrow{a}$(高维空间中的一个点)，其中$a_k$表示$i$对质数$p_k$的余数的离散对数；在高维空间对矩阵或者张量做$DFT$，计算好卷积之后，再进行压缩变换，变为一维序列；所以需要预处理一定范围内的离散对数和高维空间点与序列下标的对应映射关系

101.http://codeforces.com/problemset/problem/145/D

注：复杂的计数结构题，所谓计数结构是这样一种机制，保证可以不重复不遗漏的计数对象

枚举左边区间的右端点，步进其左端点，遇到新的未出现的关键点，去右边区间更新"不交线段并"，维护右边区间的非法数目，容斥原理

102.http://codeforces.com/problemset/problem/848/E

注：环状计数dp+生成函数/多项式求逆/分治fft

首先分类讨论表示多个dp状态，推导出简单的卷积递推式，此时可以分治fft；

表示成生成函数的方程组，解方程组，此时可以多项式求逆；

对生成函数进行进一步化简，使得其分子分母次数界不超过40，此时就可以暴力计算多项式乘除了

参考题解：*注意题解公式部分有误*

https://www.luogu.org/problemnew/solution/CF848E

核心公式如下：
$$
生成函数方程组：\\

\begin{aligned} F_{0}(z) &=G_{0}(z)+G_{0}(z) F_{0}(z) z+G_{1}(z) F_{1}(z) z^{3} \\ F_{1}(z) &=G_{1}(z)+G_{1}(z) F_{0}(z) z+G_{2}(z) F_{1}(z) z^{3} \\ F_{2}(z) &=G_{2}(z)+G_{1}(z) F_{1}(z) z+G_{2}(z) F_{2}(z) z^{3} \end{aligned}
$$

$$
解得：\\

\begin{aligned} F_{0}(z)=& \frac{G_{1}^2(z) z^{3}-G_{0}(z)\left(G_{2}(z) z^{3}-1\right)}{\left(G_{0}(z) z-1\right)\left(G_{2}(z) z^{3}-1\right)-G_{1}^{2}(z) z^{4}} \\ F_{1}(z)=& \frac{G_{1}(z)}{\left(G_{0}(z) z-1\right)\left(G_{2}(z) z^{3}-1\right)-G_{1}^{2}(z) z^{4}} \\ & F_{2}(z)=\frac{G_{2}(z)+G_{1}(z) z F_{1}(z)}{1-G_{2}(z) z^{3}} \end{aligned}
$$

$$
令：\\\begin{array}{c}{Q(z)=-z^{12}-3 z^{10}+5 z^{6}-3 z^{2}+1} \\ {P_{0}(z)=16 z^{8}+12 z^{6}+20 z^{4}+4 z^{2}} \\ {P_{1}(z)=9 z^{8}+2 z^{6}+23 z^{4}+6 z^{2}+1} \\ {P_{2}(z)=4 z^{8}-4 z^{6}+24 z^{4}+4 z^{2}+4}\end{array}
$$

$$
G可表示为：\\

G_{0,1,2}(z)=\frac{P_{0,1,2}(z)}{Q(z)}
$$

$$
代入即得：\\

\begin{aligned} F_{0}(z) &=\frac{P_{1}^2(z) z^{3}-P_{0}(z)\left(P_{2}(z) z^{3}-Q(z)\right)}{\left(P_{0}(z) z-Q(z)\right)\left(P_{2}(z) z^{3}-Q(z)\right)-P_{1}^{2}(z) z^{4}} \\ F_{1}(z) &=\frac{P_{1}(z) Q(z)}{\left(P_{0}(z) z-Q(z)\right)\left(P_{2}(z) z^{3}-Q(z)\right)-P_{1}^{2}(z) z^{4}} \end{aligned}
$$

$$
F_{1}(z)=\frac{M(z)}{N(z)}
$$

$$
F_{2}(z)=\frac{N(z) P_{2}(z)+P_{1}(z) M(z) z}{N(z)\left(Q(z)-P_{2}(z) z^{3}\right)}
$$

$$
最终答案：\\

ans=(g(n-1)+g(n-3))(n-1)^{2} + \\

\sum_{i=2}^{n-2} i(i-1)^{2}\left(g(i-1) f_{0}(n-i-1)+2 g(i-2) f_{1}(n-i-2)+g(i-3) f_{2}(n-i-3)\right)
$$

103.https://www.lydsy.com/JudgeOnline/problem.php?id=4161

注：k阶线性递推模板题，复杂度$k^2logn$

104.https://ac.nowcoder.com/acm/contest/881/B

注：生成函数部分分式定理，也可以用留数定理

105.https://ac.nowcoder.com/acm/contest/881/D

注：状压$dp$预处理+基础代数函数性质分析+$fwt$正变换实质+卷积定理

给定$n*m$数组，$n \le 10^5,m\le 10$，求序列$cnt[x],x\in [0,2^k-1],k \le 20$

其中$cnt[x]$表示将整个数组二进制$and$上$x$后，有多少行满足该行所有元素二进制数位上$1$的个数为奇数个

分析：初读题目，完全无法入手，转而将条件用数学语言形式简单表示出来

令$|x|$表示$x$中的二进制中$1$的个数奇偶性，则有分配率$|x|\oplus|y|=|x \oplus y|$，知识点中有讲
$$
cnt[x]=\sum_{i=1}^n\prod_{j=1}^m\frac{1-(-1)^{|a_{ij}\&x|}}{2}=\frac{1}{2^m}\sum_{i=1}^n\prod_{j=1}^m(1-(-1)^{|a_{ij}\&x|})\\
\large=\frac{1}{2^m}\sum_{i=1}^n\sum_{k=0}^m(-1)^k(-1)^{\sum_{1\le j_1<j_2<\cdots<j_k \le m}\sum_{p=1}^k|a_{ij_p}\&x|}\\
其中:\sum_{p=1}^k|a_{ij_p}\&x|=\oplus_{p=1}^k|a_{ij_p}\&x|=|\oplus_{p=1}^k(a_{ij_p}\&x)|=|(\oplus_{p=1}^ka_{ij_p})\&x|\\
\large\sum_{k=0}^m(-1)^k(-1)^{\sum_{1\le j_1<j_2<\cdots<j_k \le m}|(\oplus_{p=1}^ka_{ij_p})\&x|}\\
\large=\sum_{j=0}^{2^m-1}(-1)^{|j|}(-1)^{|(\oplus_j(a_i))\&x|}\\
其中\oplus_j(a_i)表示在j的二进制表示中是1的那些a_i的对应列异或和\\
令b_{\oplus_j(a_i)}+=(-1)^{|j|}，则有：\\
\large上式=h_x=\sum_{y=0}^{2^k-1}(-1)^{|y\&x|}b_y,x\in[0,2^k-1)\\
易知h=fwt(b),由卷积定理知,H=fwt(B)\\
故最后带入得：cnt=\frac{1}{2^m}H
$$
注意仅仅这样是不够的，由于填充数组那一步我们暴力是$2^{m-1}m$的，会被卡掉，要用状压$dp$预处理$a_i$的子集异或和

106.http://acm.hdu.edu.cn/showproblem.php?pid=6591

注：观察分析+分类讨论+组合计数

问题相当于：给定一个棋盘，有一些格子上有障碍物，询问两个格子之间最短路以及方案数。

通过观察可以发现将每一个包含 $4$ 个格子的正方形空地当作下图的一个蓝色菱形，下图的顶点对应表示棋盘的格子，这样就转化为在下图中计算。![1001](H:/2019-hdu-multi-2/tutorial/1001.png)

可以先确定询问的两个点在这个图中是哪两个块，然后先考虑块间的移动顺序，可以发现连续走一个方向会比转方向多走 $1$ ，所以块间移动要使横着和竖着移动尽量错开，然后再考虑到点在块内也有个初始位置，所以可以枚举起点块出去的位置（顶点）和终点块进入的位置（顶点），最短路就是对四种情况取最小值。设每种情况最少连续同一个方向走的次数是 $t$ ，

$最短路方案数 = 块间移动的方案数  \times  2^t  \times  两个端点到出去方向的方案数$。

块间移动的方案数可以用组合计数算出。

107.http://acm.hdu.edu.cn/showproblem.php?pid=6593

注：求$\frac{b}{c+e^{ax+d}}$的泰勒展开式第$n$项系数，多次询问$n$参数不变，其他参数变化

指数型生成函数+$sigmoid$函数性质+算子展开理论应用+多项式ntt+多项式多点求值
$$
f(x)=\frac{b}{c+e^{ax+d}} \\
容易想到把分母乘到左边再双端求导得：\\
(c+e^{ax+d})f(x)=b\\
ae^{ax+d}f(x)+(c+e^{ax+d})f'(x)=0 \\
f'(x)=-af(x)(1-\frac{c}{c+e^{ax+d}}) \\
f'(x)=-\frac{a}{b}f(x)(b-cf(x)) \\
假设这里 a 暂时吃掉了 b 并且取了相反数,得到：\\
f'(x)=af(x)(b-cf(x)) \\
令X=f'(x)即有： \\
X'=aX(b-cX) \\
至此，可以看出X的任意阶导数都是关于X的多项式\\
且形如X^{(n)}=XP_n(X)，n \ge 0 \\
对上式再次求导，得到：\\
X^{(n+1)}=X'P_n(X)+XP_n'(X)X'=X'(P_n(X)+XP_n'(X)) \\
=aX(b-cX)(P_n(X)+XP_n'(X))=XP_{n+1}(X) \\
P_{n+1}(X)=a(b-cX)(P_n(X)+XP_n'(X))\\
以x代X,下面将多项式看成关于x的多项式：\\
P_{n+1}=a(b-cx)(xP_n)'\\
不难发现，上式可改写成：\\
P_{n+1}=(a(b-c\int)Dx)\circ P_n=(abDx-acx)\circ P_n \\
P_{n+1}=a(b(xP_n)'-cxP_n)=(\frac{abxP_n}{e^{\frac{c}{b}x}})'e^{\frac{c}{b}x} \\
假设这里a吐出了刚才吃掉的b：\\
\frac{P_{n+1}}{e^{\frac{c}{b}x}}=(\frac{axP_n}{e^\frac{c}{b}x})'\\
令B_n=\frac{P_n}{e^{\frac{c}{b}x}}带入得到：\\
B_{n+1}=(axB_n)'=aDx \circ B_n \\
故显然有：\\
B_n=a^n(Dx)^n\circ B_0 \\
亦即：\\
P_n=(a^n(Dx)^n\circ (e^{-\frac{c}{b}x}))e^{\frac{c}{b}x} \\
令A_k=\{a^n(k+1)^n(-\frac{c}{b})^k\frac{1}{k!}\}\\
B_k=\{(\frac{c}{b})^k\frac{1}{k!}\} \\
P_n=A \times B,P_n第k项乘k! \\
注意这里\times表示序列卷积
$$

$$
得到P_n之后，答案ret=\frac{1}{n!}XP_n(X),X=f(x_0)\\
但是这只是回答了一个询问，显然不能每个询问都去做卷积\\
不同询问变化的参数是a,b,c,d，不变的参数是n，考虑变化的参数的影响\\
不难发现，a对答案的影响就是a^n，b的影响就是乘b，d显然没有影响\\
考虑c的影响，首先X=f(x_0)发生变化，其次P_n中x^k这一项系数乘c^k\\
不妨令a=b=c=d=1,然后得到P_n之后，在逐个询问进行微观调整\\
易得：ans=\frac{1}{n!}\frac{a^nb}{c+1}P_n(\frac{c}{c+1})\\
然后主要任务就转化为对已知的多项式P_n，进行多点求值\\
而这是多项式的经典问题，可以使用时间复杂度为O(nlog^2n)的算法
$$



108.http://acm.hdu.edu.cn/showproblem.php?pid=6596

注：基础的fwt练习题

一共有 $n^3$ 个单位立方体，将每两个不同单位立方体之间连一条边，边权为这两个单位立方体的价值乘积。如果将一个块 $A$ 切成块 $B$ 和块 $C$ ，显然就切断了 $B$ 与 $C$ 的联系，获得了它们之间的边权之和，因此无论怎么切，其实答案是一样的。

令 $N = n ^ 3$ ，$a_i$ 表示第 $i$ 个单位立方体的价值。$ans = \sum_{1\le i<j\le N}a_i*a_j=\frac{(\sum_{i=1}^Na_i)^2-\sum_{i=1}^Na_i^2}{2}$。使用 $fwt$ 计算出所有单位立方体值得分布（也就是计算每种值各有多少个）即可解出该式。

109.http://acm.hdu.edu.cn/showproblem.php?pid=6589

注：基础的生成函数，多重前缀和变种

110.https://atcoder.jp/contests/agc003/tasks/agc003_f

注：偏观察的递推题

给定$n*m$的$01$矩阵$A$，定义$B_0$为$1*1$单位阵，$B_{i+1}$由$B_i$中每个$1$元素被$A$取代，而$0$元素被与$A$同规模的全$0$矩阵取代之所得，求$B_k$的$1$的连通块个数($4$连通)，$n,m\le 1000,k \le 10^{18}$，保证$A$中$1$连通

- 令矩阵$A$与$A$横向连接的时候，之间连通接壤的行的个数为$cnth$，同样纵向连接，列个数为$cntl$
- 若上述两个均为$0$，显然答案为$a^{k-1}$；都不为$0$，答案为$1$；其中$a$为$A$中$1$数量
- 剩下的情况，由对称性，不妨设$cnth$不为$0$，令$b$为$A$中水平相邻两个单元格均为$1$的对数，令$c=cnth$
- 答案具有递推式：$P_{n+1}=aP_n-bc^n$，这是因为$P_n$中恰有$c^n$个水平相邻且均为$1$的对，蕴含着一个简单的容斥
- 可以求出通项公式，也可以用矩阵快速幂，矩阵为$[a,-b;0,c]$，初始向量为$[1,1]$，答案在最终向量的第一个数，即$T^{k-1}[1,1](0)$

111.http://codeforces.com/gym/102222/problem/M

注：与图的色多项式有关的组合题目：给定$n,m$，对无向完全二分图$K_{n,m}$的边定向，使其变为$DAG$，问定向方案数；分析：本来这是一道很难的组合数学题目，需要学习过图的色多项式的相关理论，但是题目中有两段文字介绍了基本知识，诱导了选手使用拉格朗日插值。令$f_G(c)$表示使用不超过$c$种颜色对图$G$中的点染色，使得相邻的点异色的方案数，这是一个$n+m$次多项式；则$|f_G(-1)|=(-1)^{n+m}f_G(-1)$就是所求定向的方案数；故我们只要求出$f_G(i),i \in [0,n+m]$，即可插值求出$f_G(-1)$。容易发现：
$$
f_G(c)=\sum_{k=0}^c\binom{c}{k}k!S(n,k)(c-k)^m,其中S(n,k)表示第二类斯特林数
$$

注意：本题需要任意模数拆位$fft$，故最好不要引入负的系数，防止与模板内部优化实现冲突

112.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=1477 $H$题

注：基础题，$dp$+容斥原理；给定$n\le 2000$的数组$a_i \in [0,1e9]$，问序列$x$的数量满足 $x_i \le x_{i+1},x_i \in [0,a_i]$；等价于从第$1$行逐行走入最后一行，每行踏入不严格升的列号；转化为$(0,0)$走入$(n+1,a_{n+1}=a_{n})$的偏序路径计数；令$f_i$表示从$(0,0)$

113.https://www.51nod.com/Challenge/Problem.html#problemId=1544

注：基础题，变系数斐波那契数列，其系数是一个除了有限多个点除外的周期序列，线段树维护矩阵连乘积；没有变化的周期不用重新算，直接快速幂，在有变化的周期中单点修改矩阵，取连乘积即可

114.https://www.51nod.com/Challenge/Problem.html#problemId=1341

注：基础题，矩阵快速幂优化线性递推，关键在于构造转移矩阵；令$f(n)$为答案，$f(n+1)=f(n)*q+a_{n+1}*b_0,a_{n+1}=p*a_n+r$，构造向量为$[a_{n+1},1,f(n+1)]^T$，转移矩阵为
$$
A=\left(\begin{array}{ccc}{p} & {r} & {0} \\ {0} & {1} & {0} \\ {b_{0}*p} & {b_0*r} & {q}\end{array}\right)
$$
115.http://www.51nod.com/Challenge/Problem.html#problemId=1195

注：中档题，斐波那契循环节，二次剩余

116.https://www.51nod.com/Challenge/Problem.html#problemId=1361

注：难题，$PE$题，给定序列$a_1=1,a_{n+1}=6a_n^2+10a_n+3$，求$a_n\%p$，$p$为质数

一般的二次递推是无法直接用矩阵加速的，考虑转化得到特殊的形式：

令$b_n=6a_n+5$，则得到$b_{n+1}=b_{n}^2-2$，考虑采用代数代换$x+\frac{1}{x}$消去常数$2$

由$b_0=x+\frac{1}{x}=11$，解得$\alpha =\frac{11+3\sqrt{13}}{2},\beta =\frac{11-3\sqrt{13}}{2}$，为$x^2-11x+1=0$两根

由韦达定理得：$\alpha + \beta =11,\alpha*\beta=1$，故$\alpha = \frac{1}{\beta}$

$b_1=x^{2^1}+\frac{1}{x^{2^1}},b_2=x^{2^2}+\frac{1}{x^{2^2}}...$

易知：$b_n=x^{2^n}+\frac{1}{x^{2^n}}$，取$x=\alpha$得到：$b_n=\alpha^{2^n}+\beta^{2^n}$

现在考虑求$b_n$，由于$n$是$1e18$级别，无法求出$2^n$，考虑令$c_n=\alpha^n+\beta^n$，考虑求出$c_n$的一个周期，就可以将$c_{2^n}$转化为$c_t,t<1e18$；由特征根理论知$c_n=11c_{n-1}-c_{n-2}$，$p^2-1$一定是个周期，最小正周期是其约数；有人指出只要$117$是$p$的二次剩余，$p-1$就是其一个周期，否则$p+1$就是其一个周期

117.http://www.51nod.com/Challenge/Problem.html#problemId=1407

注：中档题，容斥原理+$fwt$；给定$n \le 10^6$个数$a[i] \le 10^6$，求其$and$和恰好为$0$的非空子集数量；考虑与起来每位都要为$0$，用全集减去打破一个位限制的，加上打破两个位限制的...等价于求每个二进制状态$s$，$f(s)$表示$s$中那些位严格为$1$，其他位没有限制的方案数，即$f(s)$表示状态为$s$超集的方案数，令$cnt[x]++$，对$cnt$做高维后缀和，即$fwt\_and$，即得$f$；对$f$做容斥即可，$ans=\sum_{s=0}^{2^M-1}f(s)(-1)^{num(s)}$，$num(x)$表示二进制$1$数量

118.https://www.51nod.com/Challenge/Problem.html#problemId=1358

注：基础题，递推函数，下标涉及到低精度$double$，只要翻倍到整数即可，矩阵快速幂

119.https://www.51nod.com/Challenge/Problem.html#problemId=1248

注：中档题，递推数列+对称式处理+计算贡献；给定递推序列$f(0)=1,f(1)=3,f(n)=6f(n-1)-f(n-2)$；给定一个序列$a$，求$\sum_{V是a的子序列，x=sum(V)}f(|S-2x|)$。

首先考虑到这个递推序列有一定特殊性，故求出其通项公式：$f(n)=\frac{p^n+q^n}{2}$，注意这里$pq=1$，故$f(x)$为偶函数，可以去掉绝对值。且计算答案，可以拆开单独计算贡献，考虑计算$p^n$对应的部分答案。考虑$a$的一个前缀，此时的答案为若干$p$的幂次之和，即$\sum_{t}p^t$，考虑新增一个元素$a[i]=y$，若不取，$S-2x$增加$y$，故$\sum_{t}p^{t+y}$，同理，若取了$y$，则减少$y$，故$\sum_{t}p^{t-y}$。稍加提取，记得$ret[i]=ret[i-1]*(p^y+p^{-y})$，即$ret[n]=\prod_{i=1}^n(p^{a[i]}+p^{-a[i]})$，注意到$p,q$对称性，故最终答案$ans=ret[n]=2^n \prod_{i=1}^nf(a[i])$

120.https://www.51nod.com/Challenge/Problem.html#problemId=1034

注：难题，$100*100$的标准多米诺骨牌覆盖方案数计数，$FKT$算法

121.https://www.51nod.com/Challenge/Problem.html#problemId=2031

注：中档题，生成函数基础，计算$f_n(k)=\sum_{t=0}^k\binom{n+t+1}{n+1}a^{k-t}$，$a,k \in [1,1e18]$，$n \in [1,1e7]$

注意到这是两个无限序列的卷积，其普通型生成函数为$G_n(x)=A(x)B(x)=\frac{1}{(1-ax)(1-x)^{n+2}}$，由于$k$巨大，无法直接求$[x^k]G_n(x)=g_n(k)$，考虑构造一个关于$n$的递推式：

- 方法$1$：将$G_n(x)$利用部分分式拆开，$G_n(x)=(a-1)x(\frac{1}{(1-ax)(1-x)^{n+1}}-\frac{1}{(1-x)^{n+2}})$，故$g_n(k)=(a-1)(g_{n-1}(k-1)-\binom{n+k}{n+1})$
- 方法$2$：观察生成函数的形式，其实就是一个几何级数(等比数列)，做$n+2$轮前缀和得到的序列；考虑找点规律，令$S_t(k)$表示等比数列做$t$次前缀和之后得到序列的第$k$项，不难发现：$S_n(k)=\frac{1}{a-1}(aS_{n-1}(k)-[x^k]\frac{1}{(1-x)^n})$，注意小心特判$a$同余$1$的特殊情况

122.https://www.51nod.com/Challenge/Problem.html#problemId=1383

注：基础题，问正整数$n$的二进制拆分数量(即拆分为若干个$2$的幂次之和，无序拆分)，递推序列

- 若$n$为奇数，显然至少需要一个$1$，去掉之后规约为$n-1$；若$n$为偶数，讨论是否有$1$，转化为$n-1$和$n/2$
- $f(n)=f(n-1),n为奇数;f(n)=f(n-1)+f(n/2),n为偶数$

123.https://www.51nod.com/Challenge/Problem.html#problemId=1251

注：中档题，容斥原理，求长度为$n$的每个数$\in [1,m]$的不严格升的数组方案数；稍加转化：等价于不定方程解计数，$x_1+x_2+..+x_m=n,x_i \in [0,n]$且$x_i$最大值只出现一次，令$g(m,n)$表示$x_i \ge 0$的同规模方案数，则$g(m,n)=\binom{n+m-1}{m-1}$；令$f(m,k,n)$表示最大值$\le k$且最大值不要求只出现一次的方案数，由容斥原理知：$f(m,k,n)=\sum_{t=0}^m(-1)^t\binom{m}{t}g(m-t,n-t(k+1))$，则计算答案考虑枚举最大值$k$，由于只出现一次，则其余数$\le k-1$，$ans=\sum_{k=0}^nmf(m-1,k-1,n-k)$。将$f$带入，并且交换求和顺序，可以发现若先枚举$t$，再枚举$k$，则$k$为$O(n/t)$，故实际总复杂度$O(nlognT)$。

124.http://acm.hdu.edu.cn/showproblem.php?pid=3723

注：基础题，默慈金数模板题

125.https://www.51nod.com/Challenge/Problem.html#problemId=1556

注：基础题，默慈金数，最后不要求回到$x$轴：$f[i+1]=3f[i]-M[i]$

126.https://www.51nod.com/Challenge/Problem.html#problemId=1829

注：基础题，第二类斯特林数模板题，算一项可以$O(klogn)$，使用卷积通项公式+快速幂即可，$nlogn$使用$ntt$计算整个序列卷积算一行

127.https://www.51nod.com/Challenge/Problem.html#problemId=1103

注：基础题，抽屉原理+构造，对一个长度为$n$的数组选择一个下标子集，使得数的和为$n$的倍数；考虑前缀和模序列，若两两不同余，则必有一个余$0$。主动加强命题。

128.http://www.51nod.com/Challenge/Problem.html#problemId=1309

注：中档题，好题，基础组合，概率论；给定有重复元素的数组$a$，多次询问，每次给出$m$，回答对$a$的每个本质不同的多重排列$find(a'[],m)$函数之和，$find$定义为从左到右扫描数组$a$，对$\le m$的元素求和，一旦发现元素大于$m$立刻$break$，具体见题目伪代码。每次询问，根据$m$二分出严格大于$m$的元素个数$k$，令$P$为$a$的多重排列个数，令$S$表示$\le m$的元素之和，则答案为$ans=\frac{P}{k+1}*S$，复杂度$O((n+m)logn)$。正确性，考虑计算元素$a[i]=x \le m$的贡献次数，注意到只要$x$在排列中的下标在那些$k$个大于$m$的元素前面即可，这$k+1$个元素符合此要求的概率为$\frac{1}{k+1}$，故有$\frac{P}{k+1}$个多重排列计算了$a[i]$，而事实上别的$a[j]$贡献是相似的。为什么多重排列可以直接除，考虑全排列，计算好总答案之后，考虑一个具体排列，有$cnt$个排列与自己相同，这些排列的贡献是一样的，故全局可除以$cnt$；化简之后得到总是可由多重排列直接消重计算的。

129.http://www.51nod.com/Challenge/Problem.html#problemId=1436

注：基础题，$(a_1\&a_2)|(a_2\&a_3)|...|(a_{n-1} \& a_{n})=k$，且$a_i \in [0,2^l)$，给定$n,k,l$求$a$方案数。

按位分析，每位独立，转化为$01$变量；若$k$此位为$0$，表示没有相邻$a_i,a_{i+1}$同取$1$，否则为其补集。方案数为类斐波那契数列递推。

130.http://www.51nod.com/Challenge/Problem.html#problemId=1365

注：基础题，求斐波那契数的$(F_n\%F_k)\%10^9+7$，给出几个基本结论：
$$
F_{-n}=(-1)^{n-1}F_{n}\\
\sum_{i=1}^nF_i=F_{n+2}-1 \\
\sum_{i=1}^n(-1)^iF_i=(-1)^nF_{n-1}-1 \\
F_n=F_kF_{n-k+1}+F_{k-1}F_{n-k} \\
F_{k-1}^2+F_{k-1}F_{k}-F_{k}^2=(-1)^k \\
故有：F_{k-1}^2=(-1)^k(\%F_k)且F_{k-1}^2=(-1)^k(\%F_{k-2}) \\
F_n\%F_k=F_{k-1}F_{n-k}=F_{k-1}^2F_{n-2k}=...=F_{k-1}^{n/k}F_{n\%k}
$$
进一步推导，可得到本题较简的结论：
$$
令n=ki+j \\
F_{n} \% F_{k}=F_{k-1}^{i} F_{j}=\left\{\begin{array}{ll}{(-1)^{\frac{i}{2} k} F_{j},} & {i \% 2=0} \\ {(-1)^{\frac{i+1}{2} k+k-j-1} F_{k-j},} & {i \% 2=1}\end{array}\right.
$$
131.http://www.51nod.com/Challenge/Problem.html#problemId=1399

注：难题，计算$\sum_{i=1}^n(F_i\%F_k)$；令$d=n/k,r=n\%k$。

若$k$为偶数：
$$
\begin{aligned} \sum_{j=1}^{k-1}\left(F_{k-1}^{i} F_{j}\right)=\left\{\begin{array}{ll}{\sum_{j=1}^{k-1} F_{j}} & {=F_{k+1}-1, \quad i \% 2=0} \\ {\sum_{j=1}^{k-1}(-1)^{j-1} F_{j}} & {=F_{k-2}+1+\frac{k-1}{2} F_{k}, \quad i \% 2=1}\end{array}(0 \leq i<d)\right.\\ \sum_{j=1}^{r} F_{k-1}^{d} F_{j}=\left\{\begin{array}{ll}{\sum_{j=1}^{r} F_{j}=F_{r+2}-1,} & {d\%2=0} \\ {\sum_{j=1}^{r} F_{j}=F_{k-2}+(-1)^{r+1} F_{k-r-2}+\left(\frac{r}{2}\right) F_{k},} & {d\%2=1}\end{array}\right.\end{aligned}
$$

$$
\begin{aligned} A N S &=\frac{d+1}{2}\left(F_{k+1}-1\right)+\frac{d}{2}\left(F_{k-2}+1+\frac{k-1}{2} F_{k}\right) & \\ &+\left\{\begin{array}{ll}{F_{r+2}-1,} & {d \% 2=0} \\ {F_{k-2}+(-1)^{r+1} F_{k-r-2}+\frac{r}{2} F_{k},} & {d \% 2=1}\end{array}\right.\end{aligned}
$$

若$k$为奇数：
$$
\begin{aligned} A N S=\left[d \% 4==1\right.& \text { or }d \% 4=2]\left(F_{k+1}-1\right)+\frac{d+1}{4}(k-1) F_{k} \\ &+\left[d \% 4==2 \quad \text { or } \quad d \% 4=3\right]\left(F_{k-2}-1\right)+\frac{d}{2} \frac{k-1}{2} F_{k} \\ &+\left\{\begin{array}{c}{(-1)^{\frac{d}{2}}\left(F_{r+2}-1\right)+\left[d \%  4=2\right]\left(r F_{k}\right),} & {d \% 2=0} \\ {(-1)^{\frac{d-1}{2}}\left(F_{k-2}+(-1)^{r+1} F_{k-r-2}\right)+\frac{\tau}{2} F_{k}} & {} \\ {+\left[r \% 2 ==1\right.} \space  {  and\space d \% 4==3] F_{k}, \quad d \% 2=1}\end{array}\right.\end{aligned}
$$
132.http://www.51nod.com/Challenge/Problem.html#problemId=1355

注：难题，斐波那契数列其中$n$项的$lcm$，下标$\in [1,10^6]$；强整除数列的性质，$min-max$容斥，参见相关词条

133.http://www.51nod.com/Challenge/Problem.html#problemId=1350

注：难题，定义$f(n)$表示$n$的最短斐波那契拆分的项数(允许重复)，则令$F(n)$为其前缀和，求$F(n)$。

令$S(i)$表示从第$i$项开始连续的$f(i-1)$项之和，即$f(i)+...+f(i+f(i-1)-1)$；其存在递推式：$S(i)=S(i-1)+S(i-2)+f(i-3)$。虽然$n$很大，但是不断跳跃式步进，逼近速度很快。

134.http://www.51nod.com/Challenge/Problem.html#problemId=1263

注：基础题，求类斐波那契数列最小周期(二阶递推)；参见笔记，选择质数$p$，枚举$p^2-1$或$p-1$(讨论判别式$\triangle$是否是$p$的二次剩余)的约数，进行$check$，枚举有个技巧，可以分解质因数，枚举每个质因子的指数；多选择几个质数，用$lcm$合并。或者直接用矩阵离散对数$BSGS$算法解$A^k=I$的最小正整数$k$，注意可能无解。

135.http://www.51nod.com/Challenge/Problem.html#problemId=1228

注：模板题，序列求和$1$，自然数等幂和模板题，$n \le 10^{18},k \le 2000$

136.http://www.51nod.com/Challenge/Problem.html#problemId=1236

注：中档题，序列求和$3$，计算斐波那契数列前$n$项的$k$次幂之和，$n \le 10^{18}, k \le 10^5$

考虑一个暴力的想法，写出通项公式$f_n=a*x^n+b*y^n$，假设系数存在模意义下表示，即$\sqrt{5}$可被表示；则暴力$k$次幂求和，二项式定理展开后，只需要交换求和次序，即得到一个等比数列求和。时间复杂度$O(klogn)$。

137.http://www.51nod.com/Challenge/Problem.html#problemId=1258

注：基础题，序列求和$4$，计算等幂和，$\sum_{i=1}^ni^k,n\le 10^{18},k\le50000$

- 伯努利数做法：$\sum_{i=1}^n i^k=\frac{1}{k+1}\sum_{i=0}^kB_iC_{k+1}^i(n+1)^{k+1-i}$，朴素的伯努利数预处理是平方递推，这里可以使用其指数型生成函数预处理，这实质是一个多项式求逆，复杂度是$O(klogk)$
- 拉格朗日插值做法：令$f(x)=\sum_{i=1}^xi^k$是一个关于$x$的$k+1$次多项式，取其$k+2$个点值$f(1),f(2)...f(k+2)$，预处理复杂度$O(klogk)$，插值复杂度$O(k)$

138.http://www.51nod.com/Challenge/Problem.html#problemId=1229

注：中档题，序列求和$2$，计算$S(k)=\sum_{i=1}^ni^k*r^i$，$n,r \le 10^{18},k \le 2000$
$$
\begin{aligned}S(k)=&\sum_{i=1}^n i^k r^i\\ r·S(k)=&\sum_{i=2}^{n+1} (i-1)^k r^i \\ (r-1)S(k)=& r^{n+1}n^k-r+ \sum_{i=2}^{n} r^i((i-1)^k-i^k)\\ (r-1)·S(k)=& r^{n+1} n^k-r+\sum_{j=0}^{k-1}  (-1)^{k-j}   \begin{pmatrix} k\\ j \end{pmatrix} \Big(\sum_{i=2}^{n}i^jr^i \Big) \\S(k)=& {r^{n+1} n^k-r+\sum_{j=0}^{k-1}  (-1)^{k-j}   \begin{pmatrix} k \\ j \end{pmatrix} \big( S(j)-r\big) \over r-1}  \end{aligned}
$$
时间复杂度$O(k^2)$，注意需要特判$r \le 1$，当$r=1$时为普通的等幂和

139.http://www.51nod.com/Challenge/Problem.html#problemId=1822

注：难题，序列求和$5$，计算$f_k(n)=S(k)=\sum_{i=1}^ni^k*r^i$，$ n,r \le 10^{18},k \le 2 \times 10^5 $

- 特殊情况：当$r=1$时，问题退化为普通的等幂和，拉格朗日插值法或者伯努利数均可，其中一种推导如下：

  - 容易发现，$f_k(n)$是关于$n$的$k+1$次多项式，故$f_{m-1}(n)$可以写成$m+1$个组合数的线性组合，即$f_{m-1}(n)=\sum_{i=0}^m \binom{n}{i}a_i$，这是因为$\binom{n}{m}$是关于$n$的$m$次多项式
  - 对特定$m$，视$a_i,i \in [0,m]$为有限序列，即$a_i=0,i>m$，故上式可标准化修正为$ f_{m-1}(n)=\sum_{i=0}^n \binom{n}{i}a_i $；使用二项式反演，$a_n=\sum_{i=0}^n(-1)^{n-i} \binom{n}{i} f_{m-1}(i)$，代入得：

  $$
  f_{m-1}(n)=\sum_{j=0}^m\binom{n}{j}a_j 
  =\sum_{j=0}^m \binom{n}{j}\sum_{i=0}^j(-1)^{j-i} \binom{j}{i} f_{m-1}(i)\\
  =\sum_{i=0}^mf_{m-1}(i)\sum_{j=i}^m(-1)^{j-i} \binom{n}{j} \binom{j}{i}
  =\sum_{i=0}^mf_{m-1}(i) \binom{n}{i} \sum_{j=i}^m(-1)^{j-i}  \binom{n-i}{j-i} \\
  =\sum_{i=0}^mf_{m-1}(i) \binom{n}{i}(-1)^{m-i} \binom{n-i-1}{m-i} \\
  =\sum_{i=0}^mf_{m-1}(i) (-1)^{m-i} \frac{\prod_{j=0 \&\& j \neq i}^m(n-j)}{i!(m-i)!}
  $$

  - 注意上述推导，适用于一般意义下任何一个关于$n$的$m$次多项式$f_{m-1}(n)$，而不局限于本题；其主要思想是：若要求一个次数为$k$的多项式在$x=n$处的点值，$n$很大，但是$k$很小，且前$k+1$项点值$f(0),f(1),f(2),\cdots,f(k)$容易求出；则$x=n$处点值可以表示为前$k+1$项的线性组合
  - 本题前$k+1$项点值可以$O(klogk)$暴力快速幂求出，但是其中$i^k,i \in [0,k]$可由欧拉筛线性预处理得到，故复杂度$O(k)$；合并答案的时候，由于分子拆成了两部分，可以前后缀预处理再合并，$O(k)$

140.http://www.51nod.com/Challenge/Problem.html#problemId=1146

141.http://www.51nod.com/Challenge/Problem.html#problemId=1026

142.http://www.51nod.com/Challenge/Problem.html#problemId=1221

143.http://www.51nod.com/Challenge/Problem.html#problemId=1170

144.http://www.51nod.com/Challenge/Problem.html#problemId=1747

145.http://www.51nod.com/Challenge/Problem.html#problemId=1599

146.http://acm.hdu.edu.cn/showproblem.php?pid=5514

注：中档题，偏序空间不完整的容斥原理；给定$m \in [1,10^9]$，给定若干个$m$的约数$a_i$，求它们的倍数集合(不超过$m$)的并的元素之和。筛出$m$的所有约数排成一行，在上面做容斥；令$f(x)$表示$x$的倍数(不超过$m$)之和，反向枚举$x$，从$f(x)$中扣去所有$f(y)$，$y$是$x$倍数(至少两倍)且是$m$约数；则得到的$f(x)$表示$x$的倍数却不是其他$y$的倍数，$y$是$m$约数，且$y$是某个$a_i$倍数；$ans$即为所有$f(k)$之和，$k|m$且$k$是某个$a_i$的倍数。这种不完整的偏序空间最好画出其$hass$图，在其上做容斥和求和。画出$m$的所有约数在整除关系下的$hass$图，每个点有个贡献，但可能重复，每个点直接扣去其父亲的真实贡献(从上往下，从父亲到儿子)，即得到自己的真实贡献；叠加答案时，其实是叠加“这些点”的真实贡献，这些点构成$\{a_i\}$在此偏序集中的理想(他们向上走到的集合并)。

147.http://acm.hdu.edu.cn/showproblem.php?pid=5519

注：基础题，简单的指数型生成函数+任意模数$fft$；注意本题有状压$dp$+二进制容斥原理做法

令$f[i][j][mask]$表示确定了前$i$个位置，最终有特定的严格$j$种数超出限制，目前$mask$中$1$的数已经超出了限制

转移讨论$a[i]$这个位置放哪种数(使不使得$mask$变化)，注意如果使得$mask$变化，即新增加一种数，且这是一种需要超出限制的数，可以一次性将$cnt[x]+1$个$x$全部放入，且$a[i]$固定为$x$，后面$x$就没有限制了；这样方案不会算重。
$$
f[i][j][mask] = f[i - 1][j][mask] \cdot (5 - j + |mask|) +\\
\sum_{mask中含k} f[i - (cnt[k] + 1)][j][mask - (1 << k)] \cdot \binom{i-1}{cnt[k]}
$$

148.http://acm.hdu.edu.cn/showproblem.php?pid=5528

注：中档题，$2015icpc$长春；狄利克雷卷积。计算$\sum_{m|n}\sum_{i=0}^{m-1}\sum_{j=0}^{m-1}[m|ij]$。
$$
\sum_{i=1}^m \sum_{j=1}^m[m|ij]=\sum_{g|m}\sum_{g|i,1 \le i \le m}\sum_{j=1}^m[m/g|j] [gcd(i,m)=g]\\
=\sum_{g|m} g \sum_{g|i,1 \le i \le m}[gcd(i,m)=g]=\sum_{g|m} g \phi(m/g)=id \circ \phi \\
原式=id \circ id \circ \mu \circ I=id \circ id =n\sigma_0
$$

原题需要用$n$的约数平方和减去此答案，类似于约数和公式；另外本题有积性函数做法(上式公式是积性的)。

149.http://acm.hdu.edu.cn/showproblem.php?pid=5530

注：难题，题意较复杂，分块$fft$+二分

150.http://acm.hdu.edu.cn/showproblem.php?pid=5534

注：中档题，给定$n\le 2015$，和数组$f[]$，求$n$个点的点带标号无根树中点权之和的最大值，$x$点权为$f[x的度]$。

利用$prufer$编码，转化为题意：计算$\max_{x_0+x_1+x_2+\cdots+x_{n-2}=n-2}\prod_{i=0}^{n-2}f(x_i+1)$，令$g[i]=f[i+1]$，这实质上是关于$g$的一个多重$max$自卷积，暴力计算两个序列$max$卷积是$O(n^2)$的，结合快速幂即可。

151.http://acm.hdu.edu.cn/showproblem.php?pid=4779

注：中档题，基础组合数学，$2013icpc$杭州$J$题；给定$n \times m$网格，在格子中放不超过$p$个$1$和$q$个$2$，满足$1$不与任何数字在同行或同列，$2$最多与一个数字在同行或同列，求方案数($n,m,p,q \in [1,200]$)，有$200$次询问；考虑部分$2$作用与$1$一样，独占同行同列，考虑枚举这种元素的个数，再枚举有几个$2$充当这种元素，抽取这些行列转化为只有配对$2$的情形；考虑这时候一对$2$或者占据$2$行$1$列，或者占据$1$行$2$列，枚举总对数，枚举第一种对数，选择行列，分配分组，最后配对。令$g[n][m][k]$表示$n \times m$网格放入$k$个$2$且两两配对的方案数，$G[n][m][k]$表示其第三维前缀和，$f[n][m][p][q]$表示询问答案。
$$
k为偶数，g[n][m][k]=\sum_{a+b=k/2} \binom{n}{2a+b}\binom{m}{2b+a} \\ 
\frac{1}{a!}\frac{1}{b!}\binom{2a+b}{2,2,\cdots,2,1,1,\cdots,1}\frac{1}{a!}\frac{1}{b!}\binom{2b+a}{2,2,\cdots,2,1,1,\cdots,1}a!b!，前者a个2,b个1，后者相反 \\
k为奇数，g[n][m][k]=0 \\
n*m=k=0,g[n][m][k]=1 \\
G[n][m][k]=\sum_{i=0}^kg[n][m][i] \\
f[n][m][p][q]=\sum_{k=0}^{p+q}\sum_{i=0}^{\min(k,q)}[k-i \le p]\binom{n}{k} \binom{m}{k}k!\binom{k}{i}G[n-k][m-k][q-i] \\
时间复杂度O(200^4)
$$

152.http://codeforces.com/gym/259514    $M$题

注：中档题，拉格朗日插值，$2019icpc$南昌；给定$n \in [1,10^5],m \in [1,10^{18}]$，计算$g(n,m)=\sum_{k=1}^n \sum_{x=1}^mf(x^k) \%10^9+7$，其中$f(n)$表示前$n$个正整数异或和。

容易得到，$g(n,m)=\sum_{k=1}^n2^kS_k(m/2)+\lfloor \frac{m+3}{4} \rfloor n+\lfloor \frac{m+1}{4} \rfloor \lfloor \frac{n}{2} \rfloor +\lfloor \frac{m+2}{4} \rfloor$

不难发现，由于$S_k(m)$是关于$m$的$k+1$次多项式，而$2^k$是与$m$无关的常数，故$n$个不同次数的多项式之和仍然为关于$m$的多项式，故对此进行拉格朗日插值即可
$$
\sum_{k=1}^n2^kS_k(m)=\sum_{i=1}^mi^k\sum_{k=1}^n2^k=\sum_{i=1}^m\sum_{k=1}^n(2i)^k=\sum_{i=1}^m\frac{2i(1-(2i)^n)}{1-2i} \%10^9+7
$$
利用上式求前$k+10$项点值，由于$k$只是$1e5$级别的，分母存在逆元，所以不会存在问题；时间复杂度$O(nlogn)$

153.http://codeforces.com/gym/259514    $J$题

注：中档题，$polya$计数法+$dp$+分块矩阵快速幂优化；给定$n \le 10^6$和若干个四元序列$(a_i,b_i,c_i,d_i)$，求在顺时针旋转意义下非同构的长度为$n$的项链的$4-$染色方案数，且满足任意相邻四个元素不能匹配任何一个给定的四元颜色序列；根据$polya$相关理论：$ans=\frac{1}{n}\sum_{k=1}^nf(gcd(n,k))$，其中$f(n)$表示长度为$n$的带标号的环，$4$染色方案数，满足不出现题给模式，注意长度小于$4$时，模式可以重叠覆盖(如$0,1,2,0$)；$f(n)$可以$dp$求得，考虑优化：利用矩阵快速幂，由于只需要求出$n$的约数地方的点值，故可分块矩阵快速幂，即预处理$A^0,A^1,A^2,A^3,...,A^{B-1}$，$A^k=(A^{k/B})^BA^{k\%B}$

154.https://codeforces.com/gym/102411    $D$题

注：难题，容斥原理，双回文串问题；给定$n \le 10^5$，字符集大小$k$，求长度不超过$n$的回文串或双回文串个数(一个串只计算一次)。双回文串定义为可分成非空两段，且每段都是回文串的字符串；本原回文串定义是回文串且不是双回文串的字符串；本原双回文串定义为切割方式唯一的双回文串。令$f(n)$表示长度为$n$的回文串个数；我们取出所有回文串，并且加上任意两个非空回文串的连接，相比于问题所求，我们没有遗漏，但是有算重，令这样得到的长度为$n$的字符串总个数为$F(n)$；令$h(n)$表示长度为$n$的本元串个数(本元回文串和本元双回文串)；令$g(n)$为长度为$n$的题目所求串个数，即回文串或双回文串；求其前缀和即为答案$ans$。主要公式如下，复杂度$O(nlogn)$：
$$
f(n)=k^{\lfloor \frac{n+1}{2} \rfloor}  \\
F(n)=f(n)+\sum_{x+y=n \\ x,y \ge 1} f(x)f(y)=\begin{cases} k^{n/2}(k+1)n/2 & n为偶数 \\ k^{(n+1)/2}n & n为奇数  \end{cases} \\
F(n)=\sum_{d|n}\frac{n}{d}h(d) \to h(n)=F(n)-\sum_{d|n \\ d<n} \frac{n}{d}h(d) \\
g(n)=\sum_{d|n}h(d)
$$
应用到以下性质：

- 一个回文串若不是本原的，则必可划分成若干段，每段都是相同的本元回文串，即$S=X^k$
- 一个双回文串若不是本原的，则必可划分成若干段，每段都是相同的本元双回文串，即$S=(AB)^k$
- 按照之前$F(n)$的计算方法，一个串(分为$k$本原段)的计算次数为$k$；其中回文串本身就计算了一次，且段与段分界处计算一次；双回文串每一段中选择$AB$之间的唯一分界线
- 在$F(n)$中每个串只计算一次，即为答案$g(n)$

总结：

一些比较复杂且容易算重的组合计数问题中，可以考虑寻找一种简单的方法能够不遗漏的计数，然后考虑每种对象在其中的计算次数，将计数对象适当分成若干类，每类计算次数相同，导出和式；然后利用容斥原理或者反演技术，计算出每类的元素数目，最后枚举分类叠加即可

155.http://codeforces.com/problemset/problem/1278/F

注：中档题，经典的二项分布随机变量$k$次幂的期望；给定$n,m \le 998244353,k \le 5000$，长度为$n$的数组$a$，每个元素$a_i$均为伯努利随机变量，且以概率$p=1/m$取$1$，以概率$q=1-p$取$0$，令随机变量$X=\sum_{i=1}^na_i$，求$E(X^k)$。

- 根据定义有：
  $$
  ans=\sum_{t=0}^n \binom{n}{t}p^tq^{n-t}t^k\\
  注意到:t^k=\sum_{i=1}^{t或k}S(k,i)t^{\underline{i}},其中S表示第二类Stirling数\\
  故ans=\sum_{t=0}^{n}\binom{n}{t}p^tq^{n-t}\sum_{i=1}^kS(k,i)t^{\underline{i}}\\
  =\sum_{i=1}^kS(k,i)\sum_{t=0}^n\binom{n}{t}p^tq^{n-t}t^{\underline{i}}\\
  注意到:\sum_{t=0}^n \binom{n}{t}p^tq^{n-t}x^t=(px+q)^n为二项分布的概率生成函数\\
  对此式求i阶导且令x=1，即得阶乘矩:E(t^{\underline{i}})=n^{\underline{i}}p^i\\
  故ans=E(t^k)=\sum_{i=1}^kS(k,i)E(t^{\underline{i}})=\sum_{i=1}^kS(k,i)n^{\underline{i}}p^i\\
  时间复杂度O(k^2)或O(klogk)
  $$

- 根据组合意义：考虑计算有序下标$k$元组$(x_1,x_2,\cdots,x_k)$的贡献，其中$x_i \in [1,n]$，当且仅当这些下标对应的随机变量全部取$1$时，对答案有$1$的贡献，故这是个伯努利随机变量，期望贡献为其概率。考虑这$k$个下标中共出现$i$种不同下标，枚举这$i$种下标$\binom{n}{i}$，将这有序$k$维分配到$i$个有标号的篮子中$S(k,i)i!$，这样的一种情况对答案的期望贡献为其概率，即这$i$种下标对应的随机变量同时取$1$的概率$p^i$，求和即得到答案：$ans=\sum_{i=1}^k\binom{n}{i}S(k,i)i!p^i=\sum_{i=1}^kS(k,i)n^{\underline{i}}p^i$

- 扩展：若第$i$个随机变量$a_i$以概率$p_i$取$1$，$q_i=1-p_i$概率取$0$；则只需要将上式中$\binom{n}{i}p^i$换掉：这原本是所有$p_j$中任选$i$个乘积之和，根据基本对称多项式及简单的生成函数理论，只需要展开多项式$\prod_{i=1}^n(1+p_ix)$，取其$x^i$的系数替换之即可；而这可以使用分治$fft$在$O(nlog^2n)$时间内实现。若使用根据定义的方法，则需要对$\prod_{i=1}^n(p_ix+q_i)$求$i$阶导，并令$x=1$，得到$E(t^{\underline{i}})$，这可以先用分治$fft$展开，然后第$j$项乘$j^{\underline{i}}$，对所有系数求和，但是总复杂度达到了$O(n^2)$；最后使用第二类斯特林数加权求和部分不变。











##【题目：几何】

1.http://www.lydsy.com/JudgeOnline/problem.php?id=1043

2.http://www.lydsy.com/JudgeOnline/problem.php?id=2433

3.http://www.lydsy.com/JudgeOnline/problem.php?id=3203

4.http://www.lydsy.com/JudgeOnline/problem.php?id=4427

5.http://www.lydsy.com/JudgeOnline/problem.php?id=3533

6.http://www.lydsy.com/JudgeOnline/problem.php?id=3228

7.http://www.lydsy.com/JudgeOnline/problem.php?id=2657

8.http://www.lydsy.com/JudgeOnline/problem.php?id=2300

9.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3598

10.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3728

11.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3783

12.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1041

13.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2287

14.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3913

15.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2675

16.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2967

17.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1081

18.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2394

19.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1049

20.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1696

21.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1648

22.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1450

23.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1090

24.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2287

25.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3203

26.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3762

27.http://acm.hdu.edu.cn/showproblem.php?pid=3548

28.http://acm.hdu.edu.cn/showproblem.php?pid=5784

29.http://acm.hdu.edu.cn/showproblem.php?pid=2202

30.http://acm.hdu.edu.cn/showproblem.php?pid=2510

31.http://acm.hdu.edu.cn/showproblem.php?pid=1451

32.http://acm.hdu.edu.cn/showproblem.php?pid=2105

33.http://acm.hdu.edu.cn/showproblem.php?pid=4142

34.http://acm.hdu.edu.cn/showproblem.php?pid=2039

35.http://acm.hdu.edu.cn/showproblem.php?pid=4709

36.http://acm.hdu.edu.cn/showproblem.php?pid=5135

37.http://acm.hdu.edu.cn/showproblem.php?pid=3629

38.http://acm.hdu.edu.cn/showproblem.php?pid=4798

39.http://acm.hdu.edu.cn/showproblem.php?pid=1007

40.http://acm.hdu.edu.cn/showproblem.php?pid=4458

41.http://acm.hdu.edu.cn/showproblem.php?pid=4720

42.http://acm.hdu.edu.cn/showproblem.php?pid=2187

43.http://acm.hdu.edu.cn/showproblem.php?pid=5251

44.http://poj.org/problem?id=2187

45.http://poj.org/problem?id=2079

46.http://www.spoj.com/problems/CIRU/

47.http://acm.fzu.edu.cn/problem.php?pid=1007

48.http://acm.fzu.edu.cn/problem.php?pid=1510

49.http://acm.fzu.edu.cn/problem.php?pid=1485

50.http://acm.fzu.edu.cn/problem.php?pid=1482

51.http://acm.fzu.edu.cn/problem.php?pid=1472

52.http://acm.fzu.edu.cn/problem.php?pid=1393

53.http://acm.fzu.edu.cn/problem.php?pid=1333

54.http://acm.fzu.edu.cn/problem.php?pid=1332

55.http://acm.fzu.edu.cn/problem.php?pid=1331

56.http://acm.fzu.edu.cn/problem.php?pid=1329

57.http://acm.fzu.edu.cn/problem.php?pid=1302

58.http://acm.fzu.edu.cn/problem.php?pid=1195

59.http://acm.fzu.edu.cn/problem.php?pid=1129

60.http://acm.fzu.edu.cn/problem.php?pid=1120

61.http://acm.fzu.edu.cn/problem.php?pid=1088

62.http://acm.fzu.edu.cn/problem.php?pid=1066

63.http://acm.fzu.edu.cn/problem.php?pid=1035

64.http://acm.fzu.edu.cn/problem.php?pid=1032

65.http://acm.fzu.edu.cn/problem.php?pid=1015

66.http://acm.fzu.edu.cn/problem.php?pid=1014

67.http://www.lydsy.com/JudgeOnline/problem.php?id=1069

68.http://www.lydsy.com/JudgeOnline/problem.php?id=1185

69.http://www.lydsy.com/JudgeOnline/problem.php?id=3680

70.http://www.lydsy.com/JudgeOnline/problem.php?id=1845

71.http://www.lydsy.com/JudgeOnline/problem.php?id=2618

72.http://acm.hdu.edu.cn/showproblem.php?pid=2297

73.http://acm.hdu.edu.cn/showproblem.php?pid=5462

74.http://acm.hdu.edu.cn/showproblem.php?pid=3761

75.http://www.lydsy.com/JudgeOnline/problem.php?id=3190

76.http://www.lydsy.com/JudgeOnline/problem.php?id=1137

77.http://www.lydsy.com/JudgeOnline/problem.php?id=2732

78.https://vjudge.net/contest/187746#problem/H

79.http://www.lydsy.com/JudgeOnline/problem.php?id=4418

80.http://www.spoj.com/problems/CIRU/

81.http://www.spoj.com/problems/CIRUT/

82.http://acm.hdu.edu.cn/showproblem.php?pid=1724

83.https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=446&page=show_problem&problem=4077

84.https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=23&page=show_problem&problem=2119

85.http://www.lydsy.com/JudgeOnline/problem.php?id=2178

86.http://www.lydsy.com/JudgeOnline/problem.php?id=1502

87.https://vjudge.net/contest/189689#problem/D

88.https://nanti.jisuanke.com/t/30993

89.https://nanti.jisuanke.com/t/31446

90.http://codeforces.com/gym/101955/problem/L

91.http://codeforces.com/gym/102012/problem/M

92.http://codeforces.com/gym/101981/attachments D题

[注]空间最小球覆盖经典几何模型

93.https://codeforces.com/gym/101611/problem/J

注：找一个在矩形中，但不在n个三角形内或上的点；n个三角形为整点三角形且在矩形内，且面积和不超过矩形面积：二分+三角形与矩形交/差分扫描线算法

94.http://codeforces.com/group/aUVPeyEnI2/contest/243686 L题

注：经典的差分扫描线算法+利用截面积函数做定积分算体积(牛顿莱布尼兹定理)

95.http://codeforces.com/group/aUVPeyEnI2/contest/243687 K题

注：简单多边形+三角剖分，将其分成两部分面积相等，且均为简单多边形

96.https://codeforces.com/problemset/problem/70/D

注：动态凸包模板题，动态加点，动态查询给定点是否在凸包内

97.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10433 L题

注：毒瘤的几何压轴题，求三维空间内三个半径两两不等且两两不交的球体的三维凸包体积，内含球体公切面等模板

98.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10433 H题

注：不错的几何题，给定$k$维空间(坐标$\in [0,1e5]$)$n \le 18$个平行于坐标面的超立方体，求一个未被覆盖的字典序最小的单元超立方小格；贪心+二分+容斥+优化

字典序最小，往往逐维贪心，二分判断超立方体体积并在某一维上的坐标前缀中是否是满的(假设前面的维度被压缩到某个点值，当前维度取前缀，后面的维度取满)；由于中间结果可能巨大无比，最好用哈希思想判满；

体积并的投影，相当于体积投影的并，可以将一些二分中的可预处理的量提出去，降低复杂度

超立方体体积并是几何中经典问题，使用容斥原理

99.https://ac.nowcoder.com/acm/contest/883/H

注：基础几何签到题，给$n$个点，寻找一条直线平分点集，不过任意点，坐标绝对值不超过$10^3$

100.http://acm.hdu.edu.cn/showproblem.php?pid=6590

注：基础的凸包判交问题

101.http://acm.hdu.edu.cn/showproblem.php?pid=6158

注：圆反演变换，或者笛卡尔定理

102.http://acm.hdu.edu.cn/showproblem.php?pid=6097

注：圆反演变换

103.https://codeforces.com/contest/1252/problem/I

注：计算几何+图论，寻路问题，给定一个大的矩形区域表示空间，$n$个相离的圆，起点$s$和终点$t$坐标；从$s$到$t$寻一条路，每次走直线段，且拐弯最多$1000$次，中间不能经过圆边界，但可以和圆以及矩形边界相切。枚举圆，起点，终点，矩形等几何对象；求出主要的切线和公切线，每一条取两个切点，判定这两个切点之间的线段是否经过圆，不经过将该线段加入集合；为了方便，可以将集合里的线段看成点，两条线段共端点，则可以连边，从与$s$相连的线段出发，寻一条到达与$t$相连的线段的路径，$bfs$即可。

104.http://acm.hdu.edu.cn/showproblem.php?pid=5533

注：基础题，给定$n$个平面点坐标，判断是否构成正$n$边形。只要求出点次序后，逐一判断是否边长相等，且夹角相等即可。夹角判断可以用：$tan$值等于叉积绝对值除以点积值。

105.http://acm.hdu.edu.cn/showproblem.php?pid=4793

注：基础题，$2013icpc$长沙$C$题，有一对以$X$为圆心的同心圆半径为$R$和$r$，有一枚以$Y$为圆心$c$为半径的硬币以速度向量$v=(vx,vy)$运动，设同心圆中小圆是实心的且固定，大圆透明可穿过，硬币若撞击小圆会镜面反射，求硬币在大圆范围中的时间，只要与大圆接触就算在范围内(包括完整在大圆内)。关键在于求三个关键点，与大小圆分别相切的时刻，到达$X$与速度直线垂足的时刻，后半段时间由于是对称的，可以乘$2$。分三种不同的运动情况讨论，注意初始速度远离大圆的情况特判。

106.http://acm.hdu.edu.cn/showproblem.php?pid=4116

注：难题，$2011icpc$成都$F$题，水果忍者，一条直线最多经过多少个圆；圆周扫描线经典题

107.http://acm.hdu.edu.cn/showproblem.php?pid=4816

注：中档题，给定若干条线段构成的一条折线段，求一个长度为$2d$的横坐标区间$[L,R]$使得此区间与折线段和$x$轴围成的面积最大。用左右端点的限制，扣出左端点的所有连续区间，当左端点在此区间运动时，右端点不会跨过任何一条线段的端点。然后每个区间单独考虑，最值在两个端点或者中间的等高点(指纵坐标相等)处取到(如果存在)。

108.http://acm.hdu.edu.cn/showproblem.php?pid=4773

注：中档题，圆反演变换，$2013icpc$杭州$D$题；给定两个圆(已知圆心半径)，和一定点$P$，满足两两相离；求所有满足过点$P$且与两给定圆均外切的圆(给出圆心半径)；选择点$P$为反演中心，任意合适的反演幂$r^2$，将给定圆反演变换成两个新的圆，所求圆被反演为一条与两个圆均相切的直线；故求出两圆所有公切线，检查其不过反演点$P$，将其反演回圆，检查是否与两给定圆外切；注意开$long \space double$，减少精度误差

109.https://codeforces.com/gym/102431/   $E$题

注：$CCPC\_Final 2019$，基础题，题意等价于：给定一个边长相等且已知的平面正方形集合，不断操作，每次先选择(并且删去)得分最大的正方形(输出编号)，删去其他的正方形中与自己的面积交大于给定常数$\alpha$的正方形。由于这种面积限制引出了双曲线图像较为复杂，所以考虑画格子的计算几何方法，该方法对于圆也很适用。













##【题目：线代】

1.http://codeforces.com/problemset/problem/845/G

2.http://codeforces.com/problemset/problem/724/G

3.http://codeforces.com/problemset/problem/938/G

4.http://codeforces.com/problemset/problem/388/D

5.http://codeforces.com/problemset/problem/895/C

6.http://codeforces.com/problemset/problem/587/E

7.http://codeforces.com/problemset/problem/504/D

8.https://www.lydsy.com/JudgeOnline/problem.php?id=2460

9.https://www.lydsy.com/JudgeOnline/problem.php?id=4184

10.https://www.lydsy.com/JudgeOnline/problem.php?id=3811

11.https://www.lydsy.com/JudgeOnline/problem.php?id=4568

12.https://www.lydsy.com/JudgeOnline/problem.php?id=4004

13.https://www.lydsy.com/JudgeOnline/problem.php?id=2115

14.https://www.lydsy.com/JudgeOnline/problem.php?id=2844

15.https://www.lydsy.com/JudgeOnline/problem.php?id=3105

16.https://www.lydsy.com/JudgeOnline/problem.php?id=4269

17.https://www.lydsy.com/JudgeOnline/problem.php?id=4671

18.https://www.lydsy.com/JudgeOnline/problem.php?id=3563

19.https://www.lydsy.com/JudgeOnline/problem.php?id=3569

20.https://www.lydsy.com/JudgeOnline/problem.php?id=3759

21.https://www.lydsy.com/JudgeOnline/problem.php?id=4644

22.https://www.lydsy.com/JudgeOnline/problem.php?id=3237

23.https://www.lydsy.com/JudgeOnline/problem.php?id=2322

24.http://acm.hdu.edu.cn/showproblem.php?pid=3949

25.http://acm.hdu.edu.cn/showproblem.php?pid=5544

26.http://codeforces.com/problemsets/acmsguru/problem/99999/275

27.https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1577

28.https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1323

注：基础题，$20*20$矩阵，每个元素可选可不选，要求每行每列均选择严格奇数个元素，且乘积为完全平方数，求方案数；模$2$意义下高斯消元，转为线性基，求自由变量个数即可

29.http://acm.hdu.edu.cn/showproblem.php?pid=5244

30.http://codeforces.com/problemset/problem/959/F

31.http://codeforces.com/problemset/problem/958/D2

注：模意义下整数向量的线性子空间基的计算处理和hash

32.http://acm.hdu.edu.cn/showproblem.php?pid=6395

33.https://www.nowcoder.com/acm/contest/147/A

34.https://nanti.jisuanke.com/t/31000

35.https://nanti.jisuanke.com/t/31463

36.https://codeforces.com/gym/101611/problem/I

注：平方算法解异或方程组





37.https://www.lydsy.com/JudgeOnline/problem.php?id=3811

或者http://uoj.ac/problem/36

注：异或空间上的概率期望经典问题，异或空间的投影与投影空间

给定一个序列，随机选择一个子序列(可以为空)，求异或和$k$次幂的数学期望，$1 \le k \le 5$

将序列插入线性基，构造异或空间，令$m$表示空间中的最大二进制长度，令随机变量$X$表示子序列异或和
$$
\large E(X^k)=E((\sum_{i=0}^{m-1}x_i*2^i)^k)=E(\sum_{i_1=0}^{m-1}\sum_{i_2=0}^{m-1}\sum_{i_3=0}^{m-1}\dots\sum_{i_k=0}^{m-1}2^{\Large{\sum_{t=1}^ki_t}}\prod_{t=1}^{k}x_{i_t}) \\
\large =\sum_{i_1=0}^{m-1}\sum_{i_2=0}^{m-1}\sum_{i_3=0}^{m-1}\dots\sum_{i_k=0}^{m-1}2^{\Large{\sum_{t=1}^ki_t}}E(\prod_{t=1}^{k}x_{i_t}) \\
\large =\sum_{i_1=0}^{m-1}\sum_{i_2=0}^{m-1}\sum_{i_3=0}^{m-1}\dots\sum_{i_k=0}^{m-1}2^{\Large{\sum_{t=1}^ki_t}}P(\prod_{t=1}^{k}x_{i_t}=1) \\
\large 令随机变量Y=X[i_1;i_2;i_3;\dots;i_k]=(x_{i_1}x_{i_2}x_{i_3}\dots x_{i_k})_2 \\
\large 则P(\prod_{t=1}^{k}x_{i_t}=1)=P(Y=2^k-1)
$$

我们转而研究随机变量$Y$，注意到$Y$是随机变量$X$在二进制表示上的一种投影变量，令投影变换为$T$

假设选取概率空间中一个元素(实质是一个元祖)：$e=(a_1,a_2,..,a_j)$，这里只是$a$数组中任$j$个不同下标

则：异或空间对应的元素为$X(e)=a_1 \space xor \space a_2 \space xor \space \space \dots \space xor \space a_j$

$$
\large Y(e)=T(X(e))=T(xor_{i=1}^ja_i)=xor_{i=1}^jT(a_i)=X(T(e)) \\
\large 故Y是投影概率空间\{T(e)\}上的异或和随机变量
$$
**子集概率空间和异或空间的关系性质**

假设$n$个元素的序列的子集构成概率空间，那么显然概率空间中有$2^n$个元素，那么作用于这些元素的异或和随机变量$X$的分布构成另一个空间称之为异或空间，假设异或空间具有$m$个线性异或无关的异或基向量(将这$n$个元素插入到线性基结构中得到$size$为$m$的一组基)，那么异或空间有$2^m$个元素，每种对应概率空间的$2^{n-m}$个元素

证明：这$n$个元素中，一定可以找到一组$size$为$m$的线性基，剩下的$n-m$个元素，称为非基元素，事实上很容易用一一对应理论证明，非基元素的子集与异或和为$y$的方案一一对应；取上述任一子集，若子集中元素异或和为$x$，则在基元素集合中，一定可以找到$x \space xor \space  y$的唯一分解或者表示，并之即得一唯一确定方案；取任一方案，其在非基元素集合上的投影显然是唯一确定的

寻找给定异或空间元素$y$的一组在原序列上的拆分表示，即是寻找一个概率空间的元素$e$与之对应，确定一组基之后，$y$可以唯一的表示为基的线性组合，$y$具有唯一的坐标，是一个长度为$m$的二进制串

**本题思路**

我们可以先求出原序列的投影序列，然后插入到线性基结构中构造投影异或空间，但是当投影变换本身是一个枚举量且序列$a$中元素较多时，时间成本太高；其实我们可以先求出原序列的一组线性基，然后只要对基向量进行投影即可，注意到投影变换本质上是一种降维变换，所以投影过后的基向量组可能是有维度信息冗余的，所以再将新的基向量插入到线性基结构，即可构造出新的线性基及其异或空间

令新的线性基$size=m'$，如果元素$2^k-1$在新的异或空间出现，则必与其他元素等概率出现，故$P(Y=2^k-1)=\frac{1}{2^{m'}}$
$$
E(X^k)=\sum_{i_1=0}^{m-1}\sum_{i_2=0}^{m-1}\sum_{i_3=0}^{m-1}\dots\sum_{i_k=0}^{m-1}[2^k-1 \space \in \space V]2^{\Large{\sum_{t=1}^ki_t}-m'}，V表示新的异或空间
$$
事实上，$\sum_{t=1}^ki_t-m' \ge -1$，这表示结果乘$2$一定是整数，证明如下：

假设$i_1,i_2,i_3,\dots,i_k$中，不同的数有$p$个，那么考虑投影序列中的每个数是个$p$维向量，若干个$p$维向量的最大线性无关组元素个数最多为$p$($p$个基足以表示$p$维空间)，因此$m' \le p$，而$\sum_{t=1}^ki_t \ge 0+1+2+\dots+(p-1)=(p-1)*p/2$，故$\sum_{t=1}^ki_t-m' +1 \ge (p-1)*p/2-p+1=(p-1)(p-2)/2 \ge 0，\forall \space p \ge 1$

**总结**

在异或空间中，线性基不光可以求与给定数$x$做$xor$的最值(同或$\sim x$转异或)，还可以求与给定数$x$做$and$的最值，当然也可以求与给定数$x$做$or$的最值，这是因为：$(y \space or \space x)_{op}=(y \space and \space \sim x) _{op}\space or \space x$





38.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10433 E题

注：经典问题：求高维空间两直线间最小距离，目前已知本题有4种做法

**做法1**：二次型，换主元思想

设直线$AB$与$CD$上各有一点$P$和$Q$，则$P:a\overrightarrow{A}+b\overrightarrow{B},a+b=1$

同理，$Q$的参数设为$c,d$；故

$$
|PQ|^2=(a\overrightarrow{A}+b\overrightarrow{B}-c\overrightarrow{C}-d\overrightarrow{D})^2\\
=a^2\overrightarrow{A}^2+b^2\overrightarrow{B}^2+c^2\overrightarrow{C}^2+d^2\overrightarrow{D}^2\\
+2ab\overrightarrow{A}\cdot\overrightarrow{B}+2cd\overrightarrow{C}\cdot\overrightarrow{D} \\
-2ac\overrightarrow{A}\cdot\overrightarrow{C}-2bd\overrightarrow{B}\cdot\overrightarrow{D} \\
-2bc\overrightarrow{B}\cdot\overrightarrow{C}-2ad\overrightarrow{A}\cdot\overrightarrow{D}\\
=x_1a^2+x_2b^2+x_3c^2+x_4d^2 \\ 
+2abx_5+2cdx_6-2acx_7-2bdx_8-2bcx_9-2adx_{10} \\
将b=1-a,d=1-c带入得：\\
=X_1a^2+X_2a+X_3c^2+X_4c+X_5ac+X_6
$$

其中：
$$
X_1=x_1+x_2-2x_5 \\
X_2=2x_5+2x_8-2x_{10}-2x_2 \\
X_3=x_3+x_4-2x_6 \\
X_4=2x_6+2x_8-2x_9-2x_4 \\
X_5=2x_9+2x_{10}-2x_7-2x_8 \\
X_6=x_2+x_4-2x_8
$$
考虑拉格朗日极值法，令其偏导为$0$得到方程组：
$$
2aX_1+X_2+X_5c=0 \\
2cX_3+X_4+X_5a=0 \\
解得：\\
a=\frac{2X_2X_3-X_4X_5}{X_5^2-4X_1X_3} \\
c=\frac{2X_1X_4-X_2X_5}{X_5^2-4X_1X_3}
$$
带入得到一般情况答案：
$$
ans=\frac{-X_2^2X_3-X_1X_4^2+X_2X_4X_5+4X_1X_3X_6-X_5^2X_6}{4X_1X_3-X_5^2}
$$
注意当原题意两直线平行时，要特判：因为$a,c$解出来分母为$0$，此种情况可以用向量点积直接求出答案



**做法2：**二次型化为标准型

需要二次型的线代模板



**做法3：**推广三维情形，寻找法向量求点积；这是一种几何与代数结合的方法，计算量较小

*三维情形：*

当两直线平行时，即$|\overrightarrow{AB}\cdot \overrightarrow{CD}|=|\overrightarrow{AB}||\overrightarrow{CD}|$，令$l=\frac{|\overrightarrow{AC}\cdot\overrightarrow{AB}}{|\overrightarrow{AB}|}|,d^2=\overrightarrow{AC}^2-l^2$

当两直线不平行时，过其中一条做平行于另一条的平面，将问题转化为求直线到与其平行(或共面)的一平面距离，令该平面法向量$\overrightarrow{n}=\overrightarrow{AB}\times\overrightarrow{CD},d=\frac{|\overrightarrow{AC}\cdot\overrightarrow{n}|}{|\overrightarrow{n}|}$

*推广：*

平行时，可以推广；不平行时，由于我们对于高维空间内两向量叉积定义不明晰，所以不利于推广

我们从三维情形，发现不平行时，最短距离满足一个几何性质：如果我们可以找到$p\in AB,q\in CD$且$pq \perp AB,pq \perp CD$，则$d=|pq|$

故代数化：令$p=a\overrightarrow{A}+b\overrightarrow{B},a+b=1$，$q=c\overrightarrow{C}+d\overrightarrow{D},c+d=1$
$$
\overrightarrow{pq}\perp\overrightarrow{AB},\overrightarrow{pq}\perp\overrightarrow{CD} \\
等价于\\
a\overrightarrow{A}\cdot\overrightarrow{AB}+b\overrightarrow{B}\cdot\overrightarrow{AB}-c\overrightarrow{C}\cdot\overrightarrow{AB}-d\overrightarrow{D}\cdot\overrightarrow{AB}=0 \\
a\overrightarrow{A}\cdot\overrightarrow{CD}+b\overrightarrow{B}\cdot\overrightarrow{CD}-c\overrightarrow{C}\cdot\overrightarrow{CD}-d\overrightarrow{D}\cdot\overrightarrow{CD}=0\\
换元并代入消元:\\
p_1a+p_2(1-a)+p_3c+p_4(1-c)=0\\
q_1a+q_2(1-a)+q_3c+q_4(1-c)=0\\
整理并换元:\\
s_1a+s_2c=s_3\\
t_1a+t_2c=t_3\\
解得:\\
a=\frac{s_2t_3-s_3t_2}{s_2t_1-s_1t_2}=\frac{r_1}{p}\\
c=\frac{s_3t_1-s_1t_3}{s_2t_1-s_1t_2}=\frac{r_2}{p}\\
代入|\overrightarrow{pq}|^2中计算答案:\\
ans=\frac{|r_1\overrightarrow{A}+(p-r_1)\overrightarrow{B}-r_2\overrightarrow{C}-(p-r_2)\overrightarrow{D}|^2}{p^2}
$$
**做法4:**

二分+$SternBrocot$树，目前尚不明晰其具体做法



**总结**

对于这种偏向量表述的几何题，有时候也是很受算法竞赛欢迎的；

最好是可以结合几何与代数的方法，几何上寻找一些明显的性质，代数上用细致的推理；

这样有利于得到精确解，如果对精度要求不高的话，可以用二分三分等逼近算法





39.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10433  K题

注：简单的高斯消元模板题，构造方案



40.https://ac.nowcoder.com/acm/contest/881/C

注：拉格朗日乘子法/水桶贪心

给定$a_i$，求点$A$到有界超平面最短欧几里得距离平方$||A-P||_2^2=\sum_{i=1}^n(a_i/m-p_i)^2$;

有界超平面满足如下约束：

- $p_1,p_2,\cdots,p_n \ge 0$且$\in R$
- $\sum_{i=1}^np_i=1$

贪心的做法是：现寻找一个点$A$在上述平面的投影点，直接按比例分配坐标和的差值即可；然后要使得所有坐标非负，相当于排序后，从负到正逐维贪心，每次将本维强制改为非负，代价均摊在后面各维

拉格朗日乘子法：

由于同时存在等式约束和不等式约束条件，直接使用拉格朗日乘子法与$KKT$条件的纯代数方法比较复杂，不如只考虑等式约束，保留不等式约束，将一些特殊性的分析和代数方法结合，从而减少计算量

引拉格朗日乘子$\lambda$，构造拉格朗日函数$f(\overrightarrow{p},\lambda)=\sum_{i=1}^n(a_i-p_i)^2+2\lambda(\sum_{i=1}^np_i-1)$，本来该函数是要对所有变量都求偏导，构成一个方程组，但是由于存在不等式约束，所以意义不大，因为驻点很可能不符合条件

但是注意由于等式约束的存在，故$\partial f/\partial \lambda=0$必须成立，因为我们将其放入了构造的函数中，拉格朗日乘子法的主要思想就是将限制条件，想办法放入函数中，是一种惩罚机制求最值或者优化问题的思想
$$
f(\overrightarrow{p},\lambda)-\sum_{i=1}^na_i^2=\sum_{i=1}^np_i^2-2\sum_{i=1}^na_ip_i+2\lambda\sum_{i=1}^np_i-2\lambda\\
=\sum_{i=1}^np_i^2+\sum_{i=1}^n2(\lambda-a_i)p_i-2\lambda\\
=\sum_{i=1}^n(p_i+(\lambda-a_i))^2-2\lambda-\sum_{i=1}^n(\lambda-a_i)^2\\
注意到p_i是独立的，且分析前面的平方项:\\
当\lambda-a_i<0时，可以取到0; \\
当\lambda-a_i \ge 0时，可以取到\lambda-a_i;\\
即平方项可以取到max(\lambda-a_i,0)^2\\
将a_i从小到大排序，逐段考虑\lambda取值，是个分段二次函数\\
不妨设\lambda\in[a_k,a_{k+1}):\\
f(\overrightarrow{p},\lambda)-\sum_{i=1}^na_i^2=\sum_{i=1}^k(\lambda-a_i)^2-\sum_{i=1}^n(\lambda-a_i)^2-2\lambda\\
=-\sum_{i=k+1}^n(\lambda-a_i)^2-2\lambda\\
上式是个关于\lambda的二次函数，注意一定要在对称轴处取极值\\
即如果对称轴不在区间[a_k,a_{k+1})中，则此段极值不合法\\
最后在所有极值中取最小值
$$
总结：这种分析关键在于，把不等式约束通过调整和分类的方法转化掉，在一种情况中，拉格朗日函数的最值与参数$\overrightarrow{p}$无关，只与参数$\lambda$有关，便可以直接对$\lambda$求导，注意只能在导函数为$0$的点处求最值，最终合并所有情况的最值



41.https://ac.nowcoder.com/acm/contest/881/H

注：前后缀线性基合并，线性空间值的分布基本性质



42.https://ac.nowcoder.com/acm/contest/884/B

注：线性基求交+线段树，模板题



43.https://loj.ac/problem/2409

注：难题，牛顿恒等式+生成函数+分治$ntt$



44.http://hihocoder.com/problemset/problem/1876

注：难题，$2018$北京区域赛$G$题；牛顿恒等式

45.https://www.51nod.com/Challenge/Problem.html#problemId=1343

注：基础题，转化为计算矩阵行列式，$|A|=|A^T|$

46.https://codeforces.com/problemset/problem/963/E

注：难题，网格图随机游走问题，单一起点；直接消元法/列主元法

47.https://codeforces.com/gym/102268/problem/E

或者   http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001531    $E$题

注：难题，平面图随机游走，由于边数是$O(|V|)$的，所以是稀疏图；直接消元法$O(n^2)$

47.http://acm.hdu.edu.cn/showproblem.php?pid=5755

注：有多种做法，网格图的三进制高斯消元，主元法、直接消元法、bitset优化三进制向量等方法都可以通过。

48.http://acm.hdu.edu.cn/showproblem.php?pid=4920

注：bitset优化三进制矩阵乘法

49.https://codeforces.com/gym/102394/problem/G

注：通过nim-K博弈转化后需要维护三进制带权最大线性基，用bitset优化

50.http://acm.hdu.edu.cn/showproblem.php?pid=4818

注：图上稳定状态可以用高斯消元求解，但是这题还要对n号点每次加一条边求解一下，发现方程组只改变了一列，所以可以把这一列放在最后，后边接这一列的变化，一起消元，注意消元时枚举列号不能超过真实的最后一列，这个优化是普适的，什么方程组都可使用

51.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001538   $I$题

注：难题，给定$n,m \le 10^9$，计算由$[0,m-1]$中元素构成的$n \times n$矩阵的方案数，满足每行和，每列和，主对角线和和副对角线和关于$m$同余。结论是：$ans=(1+[n=4且m为偶数])m^{n^2-2n}$；证明可以参见高斯消元之后的自由元个数，即矩阵秩相关理论。







##【题目：积分/多项式/概率期望】

1.http://acm.hdu.edu.cn/showproblem.php?pid=4808

2.http://acm.hdu.edu.cn/showproblem.php?pid=6305

3.http://acm.hdu.edu.cn/showproblem.php?pid=6410

4.http://acm.hdu.edu.cn/showproblem.php?pid=6362

5.http://cogs.pro:8080/cogs/problem/problem.php?pid=2189

6.https://loj.ac/problem/151

7.http://codeforces.com/problemset/problem/1096/F

8.http://codeforces.com/problemset/problem/1139/D

注：概率期望+容斥原理

经典的概率期望问题，维护一个多重集合$S$，开始为空，每次从$[1,m]$中随机生成一个数，插入到$S$中

该过程直到$gcd(S)=1$停止，求$E(sz(S))$

**非负整数随机变量数学期望的性质**：期望转概率和
$$
E(X)=\sum_{i \ge 1}P(X \ge i) \\
直接用定义证明： \\
E(X)=\sum_{x \ge 1}x*P(X=x)=\sum_{x \ge 1}P(X=x)\sum_{i=1}^x1=\sum_{i \ge 1} \sum_{x \ge i}P(X=x)=\sum_{i \ge 1}P(X \ge i)
$$
**莫比乌斯函数$O(nlogn)$容斥预处理**：代码短
$$
\sum_{d|n}\mu(d)=[n=1] \space \Rightarrow \space \mu(n)=-\sum_{d|n \\ d<n}\mu(d),n>1 \\
\mu(j)-=\mu(i),i|j,j>i
$$

**本题思路**
$$
令停止时sz(S)-1为随机变量X,其中1为停止所花的代价 \\
P(X \ge i)表示长度为i的gcd>1的序列概率, \\
p(i)表示一次随机生成一个i的倍数的元素概率：\\
p(i)=\lfloor\frac{m}{i}\rfloor/m \\
P(X \ge i)=-\sum_{k \ge 2}\mu(k) p(k)^i \\
E(X)=\sum_{i \ge 1}P(X \ge i)=-\sum_{i \ge 1}\sum_{k \ge 2}\mu(k)p(k)^i=-\sum_{k \ge 2}\mu(k)\sum_{i \ge 1}p(k)^i=-\sum_{k \ge 2}\mu(k)\frac{p(k)}{1-p(k)}
$$



9.https://ac.nowcoder.com/acm/contest/882/B

注：基础的概率论模型

一维单方向等概率随机游走问题，每次随机向右走$1 \cdots k$步，问从$0$走到$x$的概率

本身是个简单的线性递推模板题，但是题目追加了一问，求$x \to \infin$的概率极限

下面采用几种不同的方法得到极限意义下的概率：

- 感性认识

  - 每次向右走的期望步数是$\frac{k+1}{2}$

  - 在极限意义下，周边点看成是等概率的，答案是期望步数的倒数

    感性的理解为，$x$被经过，需要是期望步数的倍数，这概率就是那个倒数

- 概率生成函数方法

  - 计算其生成函数
    $$
    f(x)=\frac{1}{1-\frac{x^{k}+x^{k-1}+\ldots+x}{k}}=\frac{k}{k-\left(x^{k}+x^{k-1}+\ldots+x\right)}
    $$

  - 令其分母为$g(x)$，分析其根的情况，共有$k$个根

    - 显然$x_0=1$为一个根

    - 其他根$|x_i|>1,i\in[1,k-1]$

      由绝对值不等式知：当$|x|<1$有：
      $$
      \left|1-\frac{x^{k}+x^{k-1}+\ldots+x}{k}\right| \geq 1-\left|\frac{x^{k}+x^{k-1}+\ldots+x}{k}\right| \geq 1-\frac{\left|x^{k}\right|+\left|x^{k-1}\right|+\ldots+|x|}{k} \geq 0
      $$

    - 无重根

      假设有重根，则$g(x)=0,g'(x)=0$:
      $$
      \begin{array}{l}{(1-x)\left(x^{k-1}+2 x^{k-2}+\ldots+(k-1) x+k\right)=0} \\ {k x^{k-1}+(k-1) x^{k-2}+\ldots+1=0}\end{array}
      $$
      很快推得：$x^k=1$，这与前面$|x_i|>1$矛盾

  - 分解为部分分式：
    $$
    f(x)=\frac{a_{0}}{x-x_{0}}+\frac{a_{1}}{x-x_{1}}+\ldots+\frac{a_{k-1}}{x-x_{k-1}}
    $$
    其中$x_0=1$，$|x_m|>1$故有：
    $$
    \frac{1}{x-x_{m}}=-\frac{1}{x_{m}} \frac{1}{1-\frac{x}{x_{m}}}=-\frac{1}{x_{m}} \sum_{j=0}^{+\infty}\left(\frac{x}{x_{m}}\right)^{j}=-\sum_{j=0}^{+\infty}\left(\frac{1}{x_{m}}\right)^{j+1} x^{j}
    $$
    可以看到当$j\to \infin$时，系数极限为$0$，故只要求$a_0$:

    两边同乘$x-a_0$，令$x=a_0$，转化为求极限，用洛必达得到：$a_0=-\frac{k+1}{2}$

  - 答案是$-a_0=\frac{k+1}{2}$

  - 推广
    - 期望步数为$E=\sum_{i=1}^kip_i$
    - 答案$P=\frac{1}{E}$适用于任何概率分布

- 补集转化，从反面列非齐次线性方程

  - 假设不经过$x$，而$x$之前最后走到点$y$，显然$y \in[x-k+1,x-1]$

    - 这里注意$y$一步必须严格超过$x$

  - 令$p(x)$表示经过$x$概率，显然有：
    $$
    1-p(x)=\sum_{i=1}^{k}\frac{i}{k-1}p(x-(k-i))\\
    令这些序列项p都等于ans\\
    即有：ans=\frac{2}{k+1}
    $$

  - 推广

    - $1-p(x)=\sum_{i=1}^kp(x-(k-i))\sum_{j=k-i+1}^kp_j$，数列$p_j$表示走$j$步的概率
    - $\large ans=\frac{1}{\sum_{i=1}^kip_i}$

10.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=1483 E题

注：概率期望中档题，给定$n(n \le 10^4)$，随机生成$n$个有序的无限长$01$串，令两两$lcp$的最大值为随机变量，求其数学期望；分析：化期望为概率之和，级数求和
$$
E(L)+1=\sum_{k \ge 0}P(L \ge k)=\sum_{k \ge 0}(1-\frac{\binom{2^k}{n}n!}{2^{nk}}) \\
其中\frac{\binom{2^k}{n}n!}{2^{nk}}=\frac{\prod_{i=0}^{n-1}(2^k-i)}{2^{nk}}=\prod_{i=1}^{n-1}(1-\frac{i}{2^k})=\sum_{t=0}^{n-1}(-1)^t2^{-kt}\sum_{1 \le i_1<i_2<\dots<i_t \le n-1}\prod_{j=1}^ti_j \\
=\sum_{t=0}^{n-1}(-1)^t2^{-kt}f(n-1,t)，其中f(n,k)表示[1,n]中任选k个元素乘积之和\\
f(n,k)=S[n+1][n-k+1]为第一类斯特林数\\
E(L)+1=\sum_{k \ge 0}\sum_{t=1}^{n-1}(-1)^{t+1}2^{-kt}f(n-1,t)=\sum_{t=1}^{n-1}(-1)^{t+1}f(n-1,t)\frac{1}{1-2^{-t}}
$$



11.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=1459 F题

注：与全期望有关的有趣的概率期望中档题，随机线性递推序列：$a_0=1$，$\forall n \ge 1,a_n = a_{i}+a_{j},i,j\in[0,n-1]$，这里$i,j$均独立随机等概率选取，求方差$V(a_n)$

分析：等价于求期望$E(a_n)$和平方期望$E(a_n^2)$，为叙述方便，引入几个定义：
$$
S_n=\sum_{i=0}^na_i \\
E(n)=E(a_n) \\
E_2(n)=E(a_n^2) \\
E_2S(n)=\sum_{i=0}^nE_2(i) \\
ES(n)=\sum_{i=0}^nE(i) \\
ES_2(n)=E(S_n^2)
$$
先求期望：
$$
E(n)=\frac{1}{n^2}\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}E(a_i+a_j)=\frac{2}{n}\sum_{i=0}^{n-1}E(i)=\frac{2}{n}ES(n-1)=\frac{2}{n}E(S_{n-1}) \\
2ES(n-1)=nE(n),2ES(n)=(n+1)E(n+1)\\
2E(n)=(n+1)E(n+1)-nE(n),\frac{E(n)}{n+1}=\frac{E(n+1)}{n+2}=\frac{E(0)}{1}=1,故E(n)=n+1\\
另一方面：E(a_n|S_{n-1})=\frac{2}{n}S_{n-1}\\
E(a_nS_{n-1})=E(E(a_nS_{n-1}|S_{n-1}))=E(S_{n-1}E(a_n|S_{n-1}))=\frac{2}{n}E(S_{n-1}^2)=\frac{2}{n}ES_2(n-1)
$$
再求平方的期望：
$$
E_2(n)=\frac{1}{n^2}\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}E((a_i+a_j)^2)=\frac{2}{n}E_2S(n-1)+\frac{2}{n^2}ES_2(n-1)\\
ES_2(n)=E(S_{n-1}^2)+E(a_n^2)+2E(a_nS_{n-1})=\frac{n+4}{n}ES_2(n-1)+E_2(n)
$$
递推即可

12.https://hihocoder.com/problemset/problem/1876

注：多项式相关理论，韦达定理

13.http://www.51nod.com/Challenge/Problem.html#problemId=1144

或者 http://acm.timus.ru/problem.aspx?space=1&num=1677

注：中档题，概率期望/随机过程基本结论：对于一个长度为$n$的字符串$S$，字符集为$m$，若从空开始每次随机在末尾插入等概率字符集中的一个字符，以$S$结尾即停止；期望长度(插入次数)为$ans=\sum_{k=1}^nm^k[k为公共前后缀即border]$，可视为一个$m$进制数，那些$border$的$bit$为取$1$










【基础题集合】

1.http://codeforces.com/problemset/problem/929/C

2.http://codeforces.com/problemset/problem/938/C

3.http://codeforces.com/problemset/problem/954/E

4.http://codeforces.com/contest/145/problem/D

注：简单枚举+容斥+线段判交，整点线段上整点个数公式：$gcd(|x1-x2|,|y1-y2|)+1$






【签到级别数学题】

1.https://nanti.jisuanke.com/t/30990

2.https://nanti.jisuanke.com/t/31716

3.https://vjudge.net/contest/274500#problem/C

4.http://codeforces.com/problemset/problem/1093/D

5.http://codeforces.com/problemset/problem/1096/C

6.http://codeforces.com/problemset/problem/1152/C

注：gcd/lcm的性质+约数枚举

7.http://acm.hdu.edu.cn/showproblem.php?pid=6600

注：最优的方案必然是每次询问一个位的具体值，一共有 $n$ 个二进制位，方案数显然为 $n!$。

复杂度 $O(min(n, P)) , P=1e6+3$ 。

8.https://codeforces.com/gym/102431/   $L$题

注：给定$n,m \le 200$，考虑$n \times m$网格，选择一个格子为起点和一个初始方向，每次可以直走或者向右拐，要求将所有格子都访问一次且仅一次，求不同的访问路径方案数；结论为：当$n=m=1,ans=1$；当$n=1或m=1,ans=2$；否则$ans=2n+2m-4$。




【基础几何】

1.http://codeforces.com/problemset/problem/958/E1

【递归数列专题】

1.http://acm.hdu.edu.cn/showproblem.php?pid=6304

【二进制按位贪心】

1.https://vjudge.net/contest/274676#problem/G

【表达式计算】

1.https://nanti.jisuanke.com/t/31443

2.https://www.lydsy.com/JudgeOnline/problem.php?id=3360

3.http://acm.hdu.edu.cn/showproblem.php?pid=1237

4.http://acm.hdu.edu.cn/showproblem.php?pid=1296

5.http://acm.hdu.edu.cn/showproblem.php?pid=4192

6.http://acm.hdu.edu.cn/showproblem.php?pid=5553

7.http://codeforces.com/group/aUVPeyEnI2/contest/243686 J题



【游戏状态设计和转移】

1.http://codeforces.com/gym/101955/problem/K

【区间背包和/多项式区间乘积】

1.http://codeforces.com/gym/101955/problem/M

【容斥原理小专题：邻接型容斥】

1.http://codeforces.com/gym/102012/problem/G

2.https://vjudge.net/contest/274676#problem/J

【群论基础】

1.http://codeforces.com/problemset/problem/1091/C

注：置换的乘方，等差数列求和

【括号序列】

1.http://codeforces.com/problemset/problem/1095/E





# 8.高级暴力

cf上的题目建议多看写别人的代码，如果我以前有做的，可以看我的：


【1】分块思想（重点）

1.http://www.lydsy.com/JudgeOnline/problem.php?id=2141

2.http://www.lydsy.com/JudgeOnline/problem.php?id=2120

3.http://www.lydsy.com/JudgeOnline/problem.php?id=3798

4.http://acm.hdu.edu.cn/showproblem.php?pid=5213

5.http://acm.hdu.edu.cn/showproblem.php?pid=3333

6.http://acm.hdu.edu.cn/showproblem.php?pid=4391

7.https://vjudge.net/problem/CodeChef-FNCS

8.http://acm.hdu.edu.cn/showproblem.php?pid=4677

9.http://acm.hdu.edu.cn/showproblem.php?pid=5840

10.http://acm.hdu.edu.cn/showproblem.php?pid=5110

11.http://acm.hdu.edu.cn/showproblem.php?pid=6035

12.http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1654

13.http://acm.hdu.edu.cn/showproblem.php?pid=4676

14.http://codeforces.com/contest/551/problem/E

15.http://codeforces.com/contest/19/problem/E

16.http://codeforces.com/contest/103/problem/D

17.http://codeforces.com/contest/101/problem/E

18.http://www.lydsy.com/JudgeOnline/problem.php?id=3674（用分块做）

19.https://www.lydsy.com/JudgeOnline/problem.php?id=1086

20.https://nanti.jisuanke.com/t/31451

21.http://acm.hdu.edu.cn/showproblem.php?pid=4366

22.http://acm.hdu.edu.cn/showproblem.php?pid=4858

23.http://acm.hdu.edu.cn/showproblem.php?pid=5919

24.http://acm.hdu.edu.cn/showproblem.php?pid=6394

25.http://acm.hdu.edu.cn/showproblem.php?pid=5057

26.https://loj.ac/problem/6278

27.https://loj.ac/problem/6281

28.https://loj.ac/problem/6283

29.https://loj.ac/problem/6284

30.http://acm.hdu.edu.cn/showproblem.php?pid=4960

31.http://acm.hdu.edu.cn/showproblem.php?pid=1166

32.http://acm.hdu.edu.cn/showproblem.php?pid=5145

33.http://acm.hdu.edu.cn/showproblem.php?pid=4787

34.http://acm.hdu.edu.cn/showproblem.php?pid=5412

35.https://www.lydsy.com/JudgeOnline/problem.php?id=5087

36.https://www.lydsy.com/JudgeOnline/problem.php?id=3585

37.https://www.lydsy.com/JudgeOnline/problem.php?id=3343

38.https://www.lydsy.com/JudgeOnline/problem.php?id=4765

39.https://www.lydsy.com/JudgeOnline/problem.php?id=2388

40.https://www.lydsy.com/JudgeOnline/problem.php?id=4216

41.https://www.lydsy.com/JudgeOnline/problem.php?id=3236

42.https://www.lydsy.com/JudgeOnline/problem.php?id=4241

43.https://www.lydsy.com/JudgeOnline/problem.php?id=4537

44.https://www.lydsy.com/JudgeOnline/problem.php?id=5089

45.https://www.lydsy.com/JudgeOnline/problem.php?id=4867

46.https://www.lydsy.com/JudgeOnline/problem.php?id=5016

47.https://www.lydsy.com/JudgeOnline/problem.php?id=2741

48.http://codeforces.com/problemset/problem/1093/E

注：分块+二维树状数组(主要解决二维树状数组空间太大的问题)

49.http://codeforces.com/problemset/problem/13/E

注：简单分块+并查集，也可以用lct(注意模板中rev标记不能删除)

50.https://ac.nowcoder.com/acm/contest/883/A

注：维护集合是否相等通过对每个元素随机初始值用异或和表示，然后通过对边分块来实现，但这时空间还比较大，通过对度分类讨论可以将空间缩小为O(M)

51.https://ac.nowcoder.com/acm/contest/881/G

**题解：**可持久化分块。

考虑经典的求本质不同子串的问题是先将所有后缀进行排序，相邻两个后缀的 lcp 之和就是答案。

考虑本题的每个后缀，用每个元素与其上次出现的距离的差（如果上次没出现就记为 0 ）表示这个串。因为后缀 [i, n] 与 后缀 [i + 1, n] 只会有两个位置不一样，因此可持久化分块即可。

**实现时需注意：**（代码见比赛记录）

每个后缀只用到整个串的后半部分，但是都存下来会比较好写。

查询子串应该用两个前缀相减。

52.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=1477  $F$题

注：不错的题目，分块+高维前缀和；给定$n \le 2 \times 10^5$个$d \le 16$的$d$维$01$向量(即二进制串)，求非空子序列的不严格$\le$的偏序子序列个数；偏序$\le$定义为前者是后者子集。考虑以块大小$B$对序列进行分块，考虑一个暴力$dp$：$dp[i]=1+\sum_{j<i且a_j \in a_i}dp[j]$；考虑优化转移，对当前$i$前面且和$i$在同一个块的所有元素$j$，暴力扫描转移；对每个块求高维前缀和(叠加$dp$值)，再将$i$之前的整块叠加到数组$S[s]$中，则与$i$不再同一个块的$j$直接通过取$S[a_j]$获取到。一个块计算完了，立刻求高维前缀和，然后更新$S$；可以列出复杂度方程，解出$B$。











【2】莫队算法（重点）

http://hzwer.com/category/c/data-structure/basic-data-structure/piecemeal/



1.http://codeforces.com/contest/86/problem/D

2.http://codeforces.com/contest/13/problem/E

3.http://codeforces.com/contest/785/problem/E

4.http://codeforces.com/group/mbTSbPlZPV/contest/100513/problem/A

5.http://www.lydsy.com/JudgeOnline/problem.php?id=3289

6.http://www.lydsy.com/JudgeOnline/problem.php?id=3757

7.http://www.lydsy.com/JudgeOnline/problem.php?id=2038

8.http://www.lydsy.com/JudgeOnline/problem.php?id=4358

9.http://acm.hdu.edu.cn/showproblem.php?pid=6333

10.http://acm.hdu.edu.cn/showproblem.php?pid=4638




【带修改】

1.http://www.lydsy.com/JudgeOnline/problem.php?id=2120

2.http://codeforces.com/problemset/problem/940/F

3.uva12345

4.https://www.lydsy.com/JudgeOnline/problem.php?id=1878



【树上莫队】

**子树树上莫队**

一个子树对应的是dfs序上连续的一段

**路径树上莫队**

我们假设要询问一条路径a-b，设lca为p=lca(a,b)。不妨设st[a]<=st[b]（否则交换一下）。

当p=a时，这应该是一个比较简单的情形：a-b是一段父子链。

我们考虑这个新dfs序上[st[a],st[b]]的点，我们可以发现，a-b上的点被算了一遍，其他点都被算了2遍或0遍！那么我们统计的时候注意一下就可以了。

当p≠a时，我们也要一样统计[ed[a], st[b]]/[st[b], ed[a]的点（从ed[a]开始为保证a不会被排除掉），但是这回lca不会被统计到，所以要另外算一下。

1.http://uoj.ac/problem/58

2.https://www.lydsy.com/JudgeOnline/problem.php?id=3052

3.http://acm.hdu.edu.cn/showproblem.php?pid=6291

4.https://www.lydsy.com/JudgeOnline/problem.php?id=4129

5.https://www.lydsy.com/JudgeOnline/problem.php?id=3757

6.https://www.lydsy.com/JudgeOnline/problem.php?id=3460

7.https://www.lydsy.com/JudgeOnline/problem.php?id=2589

8.https://www.lydsy.com/JudgeOnline/problem.php?id=4940

9.https://vjudge.net/contest/274676#problem/E




【3】高维前缀和（重点）

1.http://codeforces.com/contest/449/problem/D

注 ：问一堆数有多少种方案and起来是0，用容斥转化为求有结果不为0的方案数，然后这个要用高维前缀和来处理有多少数字可选。	

(非)2.http://codeforces.com/problemset/problem/799/F

注 ：求所有和给定区间是不交或交长度是奇数的区间和，应该有数据结构的做法，不过有做法是用随机数加xor搞过去，和高维前缀和没什么关系，只是有不少前缀和而已

3.https://www.lydsy.com/JudgeOnline/problem.php?id=5092

注 ：符合前缀性质的都可以这样做，可以维护前缀min，这样可以知道固定几位的那种数字最早什么时候出现。

【4】常数优化论文（了解）

【5】整体二分和cdq分治

论文：

《浅谈数据结构题的几个非经典解法》


学习：http://blog.163.com/bill125_zjh/blog/static/2318010062014124101819643/

https://www.cnblogs.com/shanxieng/p/10175731.html

https://www.cnblogs.com/HQHQ/p/5966453.html

https://blog.csdn.net/fo0Old/article/details/78284212



1.http://www.lydsy.com/JudgeOnline/problem.php?id=3262

2.http://codeforces.com/contest/678/problem/F

3.http://codeforces.com/contest/607/problem/E

4.http://www.lydsy.com/JudgeOnline/problem.php?id=2683

5.http://www.lydsy.com/JudgeOnline/problem.php?id=3110

6.http://www.lydsy.com/JudgeOnline/problem.php?id=1492

7.http://codeforces.com/contest/396/problem/C

8.https://www.lydsy.com/JudgeOnline/problem.php?id=2001

9.https://www.lydsy.com/JudgeOnline/problem.php?id=2253

10.https://www.lydsy.com/JudgeOnline/problem.php?id=2716

11.https://www.lydsy.com/JudgeOnline/problem.php?id=1935

12.https://www.lydsy.com/JudgeOnline/problem.php?id=4700

13.https://www.lydsy.com/JudgeOnline/problem.php?id=4170

14.https://www.lydsy.com/JudgeOnline/problem.php?id=3263

15.https://www.lydsy.com/JudgeOnline/problem.php?id=2989

16.https://www.lydsy.com/JudgeOnline/problem.php?id=2773

17.https://www.lydsy.com/JudgeOnline/problem.php?id=2244

18.https://www.lydsy.com/JudgeOnline/problem.php?id=4137

19.http://codeforces.com/problemset/problem/762/E

20.http://codeforces.com/problemset/problem/938/G

21.http://codeforces.com/problemset/problem/669/E

22.http://codeforces.com/problemset/problem/848/C

23.https://www.lydsy.com/JudgeOnline/problem.php?id=3524

24.https://www.lydsy.com/JudgeOnline/problem.php?id=1901

25.https://www.lydsy.com/JudgeOnline/problem.php?id=2674

26.https://www.lydsy.com/JudgeOnline/problem.php?id=2738

27.https://www.lydsy.com/JudgeOnline/problem.php?id=4237

28.https://www.lydsy.com/JudgeOnline/problem.php?id=2527

29.https://www.lydsy.com/JudgeOnline/problem.php?id=3110

30.https://www.lydsy.com/JudgeOnline/problem.php?id=1146

31.https://www.lydsy.com/JudgeOnline/problem.php?id=2251

32.http://tsinsen.com/A1381


【6】二进制分组算法

1.http://codeforces.com/problemset/problem/710/F

**注**：经典的强制在线ac自动机，维护一个字符串集合，支持动态插入串，动态删除串，在线查询给定串在集合中子串数目

**消除动态删除**：维护两个ac自动机森林in和out，插入串插入到in，删除串插入到out，因为此种数目满足减法性质，分别查询相减即可(代价为一个2)

**消除在线插入**：ac自动机不可在线插入串，采用二进制分组算法，在线转离线，每次插入一个串，新建一个ac自动机，阶为1，如果与上一个ac自动机阶相同，就合并到上一个，暴力重构合并之后的自动机fail树和维护的相关信息(每个串最多合并log次)，此步本质上是一种离线做法(代价为一个log)

**在线查询**：在森林中每个自动机上分别查询，叠加即可；ac自动机查询是在线的

**技巧与注意点**：

1)0号点设立为森林中所有点共用的超级虚拟节点，每个自动机空串节点插入时再自己维护

2)设S=rt[k]为第k个自动机的根，也是当前要操作的根节点，千万注意在插入完之后的构建build过程和对每个自动机的查询过程中，都要初始化一下此自动机：将0号点的每一个转移都设为S，即：go[0][c]=S

3)特别注意不要构造trie图，保留节点的每个空转移

**关于ac自动机的合并**

1)本质是DAG的合并

2)注意合并的时候，不要忘记合并节点的标记，考虑标记合并时到底是或还是加的关系，也有可能是多规则合并

**本题其他参考做法**：

1)二进制分组+后缀自动机，思路类似

2)采用分类算法，对串长设立阈值，长一点的暴力插入ac自动机中并维护，短一点的存起来暴力kmp匹配，速度较快

3)字符串hash：用到基本思想，总串长为一定规模的若干字符串，其长度种类不超过根号种

对每种长度利用一个set维护插入串的hash值，查询时扫描所有不同长度种类，再扫描此种长度的所有子串，去指定set中查询此子串hash值是否存在，其总复杂度暂不明晰

2.http://acm.hdu.edu.cn/showproblem.php?pid=4787




【分治综合训练】

1.http://codeforces.com/contest/888/problem/G

2.http://codeforces.com/problemset/problem/1140/F

注：经典的线段树分治，提取每个插入操作的存活周期，抹除删除操作

线段树标记永久化思想(一个周期分成log段)，在线段树上dfs，递归时执行插入操作，回溯时撤销

使用可撤销并查集(按秩启发式合并)，在叶节点状态回答询问

维护答案：刚开始每个横坐标和纵坐标单独一个集合，每个集合维护其中横纵坐标个数；

插入一条边，即可能合并两个集合，对答案贡献为numx[p]*numy[q] + numy[p]*numx[p]

注意撤销时的操作顺序，不要忘了维护并查集结构

3.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=001423 g

**S = A + k * T + B**

如果进行分治，那么 **k * T** 一定跨过某个分治中心。

对于每个分治中心，枚举 **|T|** ，计算 **k** 。


【6】模拟退火算法

学习网站：http://blog.csdn.net/acdreamers/article/details/10019849
         http://blog.csdn.net/zk_j1994/article/details/53711410

1.http://poj.org/problem?id=2420

2.http://acm.split.hdu.edu.cn/showproblem.php?pid=4717

3.http://poj.org/problem?id=1379

4.http://acm.split.hdu.edu.cn/showproblem.php?pid=2297

5.http://www.lydsy.com/JudgeOnline/problem.php?id=3680

6.http://acm.split.hdu.edu.cn/showproblem.php?pid=3932

7.http://acm.split.hdu.edu.cn/showproblem.php?pid=1109

8.http://acm.split.hdu.edu.cn/showproblem.php?pid=3644

9.http://acm.split.hdu.edu.cn/showproblem.php?pid=5017

【7】bitset优化专题

1.http://codeforces.com/problemset/problem/914/F

2.http://codeforces.com/problemset/problem/1097/F

3.https://www.lydsy.com/JudgeOnline/problem.php?id=5245

4.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=1477 $B$题

注：基础题，给定$n \le 2000$个点的边不带权无向图，求两两最短路平方和；$bitset$优化$BFS$

5.http://acm.hdu.edu.cn/showproblem.php?pid=5529

注：中档题，二人博弈，给定一个字符串字典，和初始串$s$，每人每次可以在$s$的开头或者结尾删除一个字符，第一个将$s$转化为字典中的串的人获胜；给定$S$，多次询问，每次选取$S[l..r]$作为$s$，回答先手是否必胜。考虑使用$NP$状态定理设计$dp$，$dp[l][r]=!(dp[l][r-1]\&dp[l+1][r])$，稍加改造$dp[len][i]=!(dp[len-1][i]\&dp[len-1][i+1])$，用$bitset$表示$dp[len]$，则$dp[len]=!(dp[len-1]\&(dp[len-1]<<1))$。初始值可以使用$trie$图求出每个串的每次出现下标，设置初值为$0$。由于只会有根号种长度，也可以独立考虑每种字典串长度，做字符串$hash$暴力求出所有初始下标。

【8】三分专题

1.http://codeforces.com/problemset/problem/939/E

2.http://acm.hdu.edu.cn/showproblem.php?pid=5531

注：中档题，先求出可行区间，三分计算二次函数区间最值

【9】多重二分

1.http://codeforces.com/problemset/problem/965/C

【10】Method of Four Russians

[维基百科](https://en.wikipedia.org/wiki/Method_of_Four_Russians)





# 9.随机化算法

1.http://codeforces.com/problemset/problem/1091/G

2.https://ac.nowcoder.com/acm/contest/884/H

注：奇怪的数学题，线性递推BM模板+采样hash

采样hash：判定长度为2000的01串是否是长度为$2^{29}$的01圈的子串，在圈上每隔1600设置一个树桩，然后每个树桩向后取60项，构成01状态，加入集合S；以串中是否存在长度为60的子串在集合S中判定

该圈由一阶线性模递推序列给定，该算法在概率意义下正确

3.https://www.51nod.com/Challenge/Problem.html#problemId=1143

注：随机化构造题，构造$M*N$的矩阵，使得每个元素不超过$10^{17}$且是完全平方数，每行和、每列和均为完全平方数，且没有重复元素。

4.https://www.51nod.com/Challenge/Problem.html#problemId=1140

注：随机向量法，基础题，判断矩阵$AB=C$是否成立，$O(n^2)$




# 10.分治
1.https://www.lydsy.com/JudgeOnline/problem.php?id=4449

​	给一个多边形的三角剖分，询问两点最短路，用分治每次选一条边尽可能把两边点集分成一样大，然后裂成两个图，然后询问如果在两边肯定会结果选的边的一个端点，分别去bfs即可

2.https://www.lydsy.com/JudgeOnline/problem.php?id=2001

​	动态最小生成树，离线有分治做法，考虑如果有m条边权值不确定，图可以同过reduction和contraction操作缩减到O(m)，这样对询问序列去分治即可，这个过程和在二叉树上dfs差不多，所以直接求出下一层的边集并覆盖是没有问题的。

3.https://www.lydsy.com/JudgeOnline/problem.php?id=3897

​	应用贪心思想，每次可以抠掉最大值那个点，然后分别到两边去做，由于要查询区间最大值，所以是O(nlogn)的，可能有O(n)的做法。

4.https://www.lydsy.com/JudgeOnline/problem.php?id=2287

​	其实直接对背包做逆操作就可以了，但是像这种去掉一个点算剩下贡献可以用分治去实现。

5.https://www.lydsy.com/JudgeOnline/problem.php?id=2961

6.https://www.lydsy.com/JudgeOnline/problem.php?id=4979

​	对于全局查询有多少对区间符合一个限制，这个限制和区间端点和区间最值之类有关可以分治转成双指针维护

7.https://www.lydsy.com/JudgeOnline/problem.php?id=3745

​	求所有区间长度乘区间最大值最小值的和，分治后转为枚举一边另一边分类讨论求和

8.https://www.lydsy.com/JudgeOnline/problem.php?id=3181

​	不太算分治，就是对数据范围分类用不同的做法

9.https://ac.nowcoder.com/acm/contest/883/G

注：与最值有关的经典问题，统计一类区间个数，也可以通过2 * max > sum 这个限制来直接对每个最大值暴力计算区间，因为对每个端点只会被log个max计算到，所以复杂度可以优化到O(nlogn)

10.http://acm.hdu.edu.cn/showproblem.php?pid=5517

注：中档题，贪心+三维偏序



# 11.交互题

1.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10433 I题

注：与初等数论相关的概率意义下交互题，可以证明暴力的复杂度在概率意义下正确

2.http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10433 J题

注：有趣的思维题，利用$01$串汉明距离做$2-$聚类分析，化归为简单单串情形



# 12.模拟题/题意题/细节题

1.http://acm.hdu.edu.cn/showproblem.php?pid=5515

注：分类讨论，$2015icpc$沈阳。

2.https://hihocoder.com/problemset/problem/1250?sid=1544860

注：蜂窝象棋，复杂模拟题。求红方下次可以移动哪些棋子。

3.http://poj.org/problem?id=3765

注：蜂窝象棋，简单模拟题。给定棋子，画出棋盘。

4.http://acm.hdu.edu.cn/showproblem.php?pid=4120

注：差分+分类讨论+枚举

5.http://acm.hdu.edu.cn/showproblem.php?pid=4801

注：魔方暴搜模拟题




# 13.其他专题专项

【1】小型思维题/小型带数学证明题

1.http://codeforces.com/problemset/problem/930/A

2.http://codeforces.com/problemset/problem/940/B

3.http://codeforces.com/problemset/problem/1092/D1

4.http://codeforces.com/problemset/problem/1092/D2

注：经典问题：翻硬币，只能翻相邻两个同色的硬币，最终使得所有硬币正面朝上，或者同时反面朝上

5.https://codeforces.com/contest/1252/problem/C

注：基础题，给定长度为$n$的数组$a[],b[]$，令$n*n$的加法表$c[i][j]=a[i]+b[j]$，现在删除$c$中所有的奇数格子；每次询问两个偶数格子是否联通。只能走偶数格子，且自己也是偶数，故奇偶性不变，而每次$4$联通只改变横坐标或者纵坐标中的一个，故显然两维坐标独立，即两维坐标分别联通；想办法判定区间内有无奇数即可。

【2】递归式处理(半数学)题

1.http://codeforces.com/problemset/problem/949/B

2.http://www.51nod.com/Challenge/Problem.html#problemId=1617

【3】搜索优化：dancing links精确覆盖/可重复覆盖

【4】搜索优化：其他优化

1.http://www.51nod.com/Challenge/Problem.html#problemId=1109

注：基础题，采用同余性质进行$bfs$剪枝

2.http://www.51nod.com/Challenge/Problem.html#problemId=1111

注：难题，双向搜索

